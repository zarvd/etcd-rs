// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `rpc.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct ResponseHeader {
    // message fields
    pub cluster_id: u64,
    pub member_id: u64,
    pub revision: i64,
    pub raft_term: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseHeader {
    fn default() -> &'a ResponseHeader {
        <ResponseHeader as ::protobuf::Message>::default_instance()
    }
}

impl ResponseHeader {
    pub fn new() -> ResponseHeader {
        ::std::default::Default::default()
    }

    // uint64 cluster_id = 1;


    pub fn get_cluster_id(&self) -> u64 {
        self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: u64) {
        self.cluster_id = v;
    }

    // uint64 member_id = 2;


    pub fn get_member_id(&self) -> u64 {
        self.member_id
    }
    pub fn clear_member_id(&mut self) {
        self.member_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_member_id(&mut self, v: u64) {
        self.member_id = v;
    }

    // int64 revision = 3;


    pub fn get_revision(&self) -> i64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = v;
    }

    // uint64 raft_term = 4;


    pub fn get_raft_term(&self) -> u64 {
        self.raft_term
    }
    pub fn clear_raft_term(&mut self) {
        self.raft_term = 0;
    }

    // Param is passed by value, moved
    pub fn set_raft_term(&mut self, v: u64) {
        self.raft_term = v;
    }
}

impl ::protobuf::Message for ResponseHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cluster_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.member_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revision = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.raft_term = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cluster_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cluster_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.member_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.member_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(3, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.raft_term != 0 {
            my_size += ::protobuf::rt::value_size(4, self.raft_term, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cluster_id != 0 {
            os.write_uint64(1, self.cluster_id)?;
        }
        if self.member_id != 0 {
            os.write_uint64(2, self.member_id)?;
        }
        if self.revision != 0 {
            os.write_int64(3, self.revision)?;
        }
        if self.raft_term != 0 {
            os.write_uint64(4, self.raft_term)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseHeader {
        ResponseHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cluster_id",
                    |m: &ResponseHeader| { &m.cluster_id },
                    |m: &mut ResponseHeader| { &mut m.cluster_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "member_id",
                    |m: &ResponseHeader| { &m.member_id },
                    |m: &mut ResponseHeader| { &mut m.member_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "revision",
                    |m: &ResponseHeader| { &m.revision },
                    |m: &mut ResponseHeader| { &mut m.revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "raft_term",
                    |m: &ResponseHeader| { &m.raft_term },
                    |m: &mut ResponseHeader| { &mut m.raft_term },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResponseHeader>(
                    "ResponseHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResponseHeader {
        static mut instance: ::protobuf::lazy::Lazy<ResponseHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResponseHeader,
        };
        unsafe {
            instance.get(ResponseHeader::new)
        }
    }
}

impl ::protobuf::Clear for ResponseHeader {
    fn clear(&mut self) {
        self.cluster_id = 0;
        self.member_id = 0;
        self.revision = 0;
        self.raft_term = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RangeRequest {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub range_end: ::std::vec::Vec<u8>,
    pub limit: i64,
    pub revision: i64,
    pub sort_order: RangeRequest_SortOrder,
    pub sort_target: RangeRequest_SortTarget,
    pub serializable: bool,
    pub keys_only: bool,
    pub count_only: bool,
    pub min_mod_revision: i64,
    pub max_mod_revision: i64,
    pub min_create_revision: i64,
    pub max_create_revision: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RangeRequest {
    fn default() -> &'a RangeRequest {
        <RangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl RangeRequest {
    pub fn new() -> RangeRequest {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes range_end = 2;


    pub fn get_range_end(&self) -> &[u8] {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_end, ::std::vec::Vec::new())
    }

    // int64 limit = 3;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }

    // int64 revision = 4;


    pub fn get_revision(&self) -> i64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = v;
    }

    // .etcdserverpb.RangeRequest.SortOrder sort_order = 5;


    pub fn get_sort_order(&self) -> RangeRequest_SortOrder {
        self.sort_order
    }
    pub fn clear_sort_order(&mut self) {
        self.sort_order = RangeRequest_SortOrder::NONE;
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: RangeRequest_SortOrder) {
        self.sort_order = v;
    }

    // .etcdserverpb.RangeRequest.SortTarget sort_target = 6;


    pub fn get_sort_target(&self) -> RangeRequest_SortTarget {
        self.sort_target
    }
    pub fn clear_sort_target(&mut self) {
        self.sort_target = RangeRequest_SortTarget::KEY;
    }

    // Param is passed by value, moved
    pub fn set_sort_target(&mut self, v: RangeRequest_SortTarget) {
        self.sort_target = v;
    }

    // bool serializable = 7;


    pub fn get_serializable(&self) -> bool {
        self.serializable
    }
    pub fn clear_serializable(&mut self) {
        self.serializable = false;
    }

    // Param is passed by value, moved
    pub fn set_serializable(&mut self, v: bool) {
        self.serializable = v;
    }

    // bool keys_only = 8;


    pub fn get_keys_only(&self) -> bool {
        self.keys_only
    }
    pub fn clear_keys_only(&mut self) {
        self.keys_only = false;
    }

    // Param is passed by value, moved
    pub fn set_keys_only(&mut self, v: bool) {
        self.keys_only = v;
    }

    // bool count_only = 9;


    pub fn get_count_only(&self) -> bool {
        self.count_only
    }
    pub fn clear_count_only(&mut self) {
        self.count_only = false;
    }

    // Param is passed by value, moved
    pub fn set_count_only(&mut self, v: bool) {
        self.count_only = v;
    }

    // int64 min_mod_revision = 10;


    pub fn get_min_mod_revision(&self) -> i64 {
        self.min_mod_revision
    }
    pub fn clear_min_mod_revision(&mut self) {
        self.min_mod_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_mod_revision(&mut self, v: i64) {
        self.min_mod_revision = v;
    }

    // int64 max_mod_revision = 11;


    pub fn get_max_mod_revision(&self) -> i64 {
        self.max_mod_revision
    }
    pub fn clear_max_mod_revision(&mut self) {
        self.max_mod_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_mod_revision(&mut self, v: i64) {
        self.max_mod_revision = v;
    }

    // int64 min_create_revision = 12;


    pub fn get_min_create_revision(&self) -> i64 {
        self.min_create_revision
    }
    pub fn clear_min_create_revision(&mut self) {
        self.min_create_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_create_revision(&mut self, v: i64) {
        self.min_create_revision = v;
    }

    // int64 max_create_revision = 13;


    pub fn get_max_create_revision(&self) -> i64 {
        self.max_create_revision
    }
    pub fn clear_max_create_revision(&mut self) {
        self.max_create_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_create_revision(&mut self, v: i64) {
        self.max_create_revision = v;
    }
}

impl ::protobuf::Message for RangeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_end)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revision = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sort_order, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sort_target, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.serializable = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.keys_only = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.count_only = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_mod_revision = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_mod_revision = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_create_revision = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_create_revision = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.range_end);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(4, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sort_order != RangeRequest_SortOrder::NONE {
            my_size += ::protobuf::rt::enum_size(5, self.sort_order);
        }
        if self.sort_target != RangeRequest_SortTarget::KEY {
            my_size += ::protobuf::rt::enum_size(6, self.sort_target);
        }
        if self.serializable != false {
            my_size += 2;
        }
        if self.keys_only != false {
            my_size += 2;
        }
        if self.count_only != false {
            my_size += 2;
        }
        if self.min_mod_revision != 0 {
            my_size += ::protobuf::rt::value_size(10, self.min_mod_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_mod_revision != 0 {
            my_size += ::protobuf::rt::value_size(11, self.max_mod_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_create_revision != 0 {
            my_size += ::protobuf::rt::value_size(12, self.min_create_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_create_revision != 0 {
            my_size += ::protobuf::rt::value_size(13, self.max_create_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_bytes(2, &self.range_end)?;
        }
        if self.limit != 0 {
            os.write_int64(3, self.limit)?;
        }
        if self.revision != 0 {
            os.write_int64(4, self.revision)?;
        }
        if self.sort_order != RangeRequest_SortOrder::NONE {
            os.write_enum(5, self.sort_order.value())?;
        }
        if self.sort_target != RangeRequest_SortTarget::KEY {
            os.write_enum(6, self.sort_target.value())?;
        }
        if self.serializable != false {
            os.write_bool(7, self.serializable)?;
        }
        if self.keys_only != false {
            os.write_bool(8, self.keys_only)?;
        }
        if self.count_only != false {
            os.write_bool(9, self.count_only)?;
        }
        if self.min_mod_revision != 0 {
            os.write_int64(10, self.min_mod_revision)?;
        }
        if self.max_mod_revision != 0 {
            os.write_int64(11, self.max_mod_revision)?;
        }
        if self.min_create_revision != 0 {
            os.write_int64(12, self.min_create_revision)?;
        }
        if self.max_create_revision != 0 {
            os.write_int64(13, self.max_create_revision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RangeRequest {
        RangeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &RangeRequest| { &m.key },
                    |m: &mut RangeRequest| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "range_end",
                    |m: &RangeRequest| { &m.range_end },
                    |m: &mut RangeRequest| { &mut m.range_end },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &RangeRequest| { &m.limit },
                    |m: &mut RangeRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "revision",
                    |m: &RangeRequest| { &m.revision },
                    |m: &mut RangeRequest| { &mut m.revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RangeRequest_SortOrder>>(
                    "sort_order",
                    |m: &RangeRequest| { &m.sort_order },
                    |m: &mut RangeRequest| { &mut m.sort_order },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RangeRequest_SortTarget>>(
                    "sort_target",
                    |m: &RangeRequest| { &m.sort_target },
                    |m: &mut RangeRequest| { &mut m.sort_target },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "serializable",
                    |m: &RangeRequest| { &m.serializable },
                    |m: &mut RangeRequest| { &mut m.serializable },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "keys_only",
                    |m: &RangeRequest| { &m.keys_only },
                    |m: &mut RangeRequest| { &mut m.keys_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "count_only",
                    |m: &RangeRequest| { &m.count_only },
                    |m: &mut RangeRequest| { &mut m.count_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min_mod_revision",
                    |m: &RangeRequest| { &m.min_mod_revision },
                    |m: &mut RangeRequest| { &mut m.min_mod_revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "max_mod_revision",
                    |m: &RangeRequest| { &m.max_mod_revision },
                    |m: &mut RangeRequest| { &mut m.max_mod_revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min_create_revision",
                    |m: &RangeRequest| { &m.min_create_revision },
                    |m: &mut RangeRequest| { &mut m.min_create_revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "max_create_revision",
                    |m: &RangeRequest| { &m.max_create_revision },
                    |m: &mut RangeRequest| { &mut m.max_create_revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RangeRequest>(
                    "RangeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RangeRequest {
        static mut instance: ::protobuf::lazy::Lazy<RangeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RangeRequest,
        };
        unsafe {
            instance.get(RangeRequest::new)
        }
    }
}

impl ::protobuf::Clear for RangeRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.range_end.clear();
        self.limit = 0;
        self.revision = 0;
        self.sort_order = RangeRequest_SortOrder::NONE;
        self.sort_target = RangeRequest_SortTarget::KEY;
        self.serializable = false;
        self.keys_only = false;
        self.count_only = false;
        self.min_mod_revision = 0;
        self.max_mod_revision = 0;
        self.min_create_revision = 0;
        self.max_create_revision = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RangeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RangeRequest_SortOrder {
    NONE = 0,
    ASCEND = 1,
    DESCEND = 2,
}

impl ::protobuf::ProtobufEnum for RangeRequest_SortOrder {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RangeRequest_SortOrder> {
        match value {
            0 => ::std::option::Option::Some(RangeRequest_SortOrder::NONE),
            1 => ::std::option::Option::Some(RangeRequest_SortOrder::ASCEND),
            2 => ::std::option::Option::Some(RangeRequest_SortOrder::DESCEND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RangeRequest_SortOrder] = &[
            RangeRequest_SortOrder::NONE,
            RangeRequest_SortOrder::ASCEND,
            RangeRequest_SortOrder::DESCEND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RangeRequest_SortOrder", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RangeRequest_SortOrder {
}

impl ::std::default::Default for RangeRequest_SortOrder {
    fn default() -> Self {
        RangeRequest_SortOrder::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeRequest_SortOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RangeRequest_SortTarget {
    KEY = 0,
    VERSION = 1,
    CREATE = 2,
    MOD = 3,
    VALUE = 4,
}

impl ::protobuf::ProtobufEnum for RangeRequest_SortTarget {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RangeRequest_SortTarget> {
        match value {
            0 => ::std::option::Option::Some(RangeRequest_SortTarget::KEY),
            1 => ::std::option::Option::Some(RangeRequest_SortTarget::VERSION),
            2 => ::std::option::Option::Some(RangeRequest_SortTarget::CREATE),
            3 => ::std::option::Option::Some(RangeRequest_SortTarget::MOD),
            4 => ::std::option::Option::Some(RangeRequest_SortTarget::VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RangeRequest_SortTarget] = &[
            RangeRequest_SortTarget::KEY,
            RangeRequest_SortTarget::VERSION,
            RangeRequest_SortTarget::CREATE,
            RangeRequest_SortTarget::MOD,
            RangeRequest_SortTarget::VALUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RangeRequest_SortTarget", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RangeRequest_SortTarget {
}

impl ::std::default::Default for RangeRequest_SortTarget {
    fn default() -> Self {
        RangeRequest_SortTarget::KEY
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeRequest_SortTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RangeResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub kvs: ::protobuf::RepeatedField<super::kv::KeyValue>,
    pub more: bool,
    pub count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RangeResponse {
    fn default() -> &'a RangeResponse {
        <RangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl RangeResponse {
    pub fn new() -> RangeResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .mvccpb.KeyValue kvs = 2;


    pub fn get_kvs(&self) -> &[super::kv::KeyValue] {
        &self.kvs
    }
    pub fn clear_kvs(&mut self) {
        self.kvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_kvs(&mut self, v: ::protobuf::RepeatedField<super::kv::KeyValue>) {
        self.kvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kvs(&mut self) -> &mut ::protobuf::RepeatedField<super::kv::KeyValue> {
        &mut self.kvs
    }

    // Take field
    pub fn take_kvs(&mut self) -> ::protobuf::RepeatedField<super::kv::KeyValue> {
        ::std::mem::replace(&mut self.kvs, ::protobuf::RepeatedField::new())
    }

    // bool more = 3;


    pub fn get_more(&self) -> bool {
        self.more
    }
    pub fn clear_more(&mut self) {
        self.more = false;
    }

    // Param is passed by value, moved
    pub fn set_more(&mut self, v: bool) {
        self.more = v;
    }

    // int64 count = 4;


    pub fn get_count(&self) -> i64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = v;
    }
}

impl ::protobuf::Message for RangeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kvs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kvs)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.more = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.kvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.more != false {
            my_size += 2;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.kvs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.more != false {
            os.write_bool(3, self.more)?;
        }
        if self.count != 0 {
            os.write_int64(4, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RangeResponse {
        RangeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &RangeResponse| { &m.header },
                    |m: &mut RangeResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::kv::KeyValue>>(
                    "kvs",
                    |m: &RangeResponse| { &m.kvs },
                    |m: &mut RangeResponse| { &mut m.kvs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "more",
                    |m: &RangeResponse| { &m.more },
                    |m: &mut RangeResponse| { &mut m.more },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "count",
                    |m: &RangeResponse| { &m.count },
                    |m: &mut RangeResponse| { &mut m.count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RangeResponse>(
                    "RangeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RangeResponse {
        static mut instance: ::protobuf::lazy::Lazy<RangeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RangeResponse,
        };
        unsafe {
            instance.get(RangeResponse::new)
        }
    }
}

impl ::protobuf::Clear for RangeResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.kvs.clear();
        self.more = false;
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutRequest {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub lease: i64,
    pub prev_kv: bool,
    pub ignore_value: bool,
    pub ignore_lease: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PutRequest {
    fn default() -> &'a PutRequest {
        <PutRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutRequest {
    pub fn new() -> PutRequest {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // int64 lease = 3;


    pub fn get_lease(&self) -> i64 {
        self.lease
    }
    pub fn clear_lease(&mut self) {
        self.lease = 0;
    }

    // Param is passed by value, moved
    pub fn set_lease(&mut self, v: i64) {
        self.lease = v;
    }

    // bool prev_kv = 4;


    pub fn get_prev_kv(&self) -> bool {
        self.prev_kv
    }
    pub fn clear_prev_kv(&mut self) {
        self.prev_kv = false;
    }

    // Param is passed by value, moved
    pub fn set_prev_kv(&mut self, v: bool) {
        self.prev_kv = v;
    }

    // bool ignore_value = 5;


    pub fn get_ignore_value(&self) -> bool {
        self.ignore_value
    }
    pub fn clear_ignore_value(&mut self) {
        self.ignore_value = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_value(&mut self, v: bool) {
        self.ignore_value = v;
    }

    // bool ignore_lease = 6;


    pub fn get_ignore_lease(&self) -> bool {
        self.ignore_lease
    }
    pub fn clear_ignore_lease(&mut self) {
        self.ignore_lease = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_lease(&mut self, v: bool) {
        self.ignore_lease = v;
    }
}

impl ::protobuf::Message for PutRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lease = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prev_kv = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_value = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_lease = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if self.lease != 0 {
            my_size += ::protobuf::rt::value_size(3, self.lease, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prev_kv != false {
            my_size += 2;
        }
        if self.ignore_value != false {
            my_size += 2;
        }
        if self.ignore_lease != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if self.lease != 0 {
            os.write_int64(3, self.lease)?;
        }
        if self.prev_kv != false {
            os.write_bool(4, self.prev_kv)?;
        }
        if self.ignore_value != false {
            os.write_bool(5, self.ignore_value)?;
        }
        if self.ignore_lease != false {
            os.write_bool(6, self.ignore_lease)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutRequest {
        PutRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &PutRequest| { &m.key },
                    |m: &mut PutRequest| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &PutRequest| { &m.value },
                    |m: &mut PutRequest| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "lease",
                    |m: &PutRequest| { &m.lease },
                    |m: &mut PutRequest| { &mut m.lease },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prev_kv",
                    |m: &PutRequest| { &m.prev_kv },
                    |m: &mut PutRequest| { &mut m.prev_kv },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ignore_value",
                    |m: &PutRequest| { &m.ignore_value },
                    |m: &mut PutRequest| { &mut m.ignore_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ignore_lease",
                    |m: &PutRequest| { &m.ignore_lease },
                    |m: &mut PutRequest| { &mut m.ignore_lease },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PutRequest>(
                    "PutRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PutRequest {
        static mut instance: ::protobuf::lazy::Lazy<PutRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PutRequest,
        };
        unsafe {
            instance.get(PutRequest::new)
        }
    }
}

impl ::protobuf::Clear for PutRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.lease = 0;
        self.prev_kv = false;
        self.ignore_value = false;
        self.ignore_lease = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub prev_kv: ::protobuf::SingularPtrField<super::kv::KeyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PutResponse {
    fn default() -> &'a PutResponse {
        <PutResponse as ::protobuf::Message>::default_instance()
    }
}

impl PutResponse {
    pub fn new() -> PutResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // .mvccpb.KeyValue prev_kv = 2;


    pub fn get_prev_kv(&self) -> &super::kv::KeyValue {
        self.prev_kv.as_ref().unwrap_or_else(|| super::kv::KeyValue::default_instance())
    }
    pub fn clear_prev_kv(&mut self) {
        self.prev_kv.clear();
    }

    pub fn has_prev_kv(&self) -> bool {
        self.prev_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prev_kv(&mut self, v: super::kv::KeyValue) {
        self.prev_kv = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev_kv(&mut self) -> &mut super::kv::KeyValue {
        if self.prev_kv.is_none() {
            self.prev_kv.set_default();
        }
        self.prev_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_prev_kv(&mut self) -> super::kv::KeyValue {
        self.prev_kv.take().unwrap_or_else(|| super::kv::KeyValue::new())
    }
}

impl ::protobuf::Message for PutResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prev_kv {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prev_kv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prev_kv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prev_kv.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutResponse {
        PutResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &PutResponse| { &m.header },
                    |m: &mut PutResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::kv::KeyValue>>(
                    "prev_kv",
                    |m: &PutResponse| { &m.prev_kv },
                    |m: &mut PutResponse| { &mut m.prev_kv },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PutResponse>(
                    "PutResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PutResponse {
        static mut instance: ::protobuf::lazy::Lazy<PutResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PutResponse,
        };
        unsafe {
            instance.get(PutResponse::new)
        }
    }
}

impl ::protobuf::Clear for PutResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.prev_kv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRangeRequest {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub range_end: ::std::vec::Vec<u8>,
    pub prev_kv: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRangeRequest {
    fn default() -> &'a DeleteRangeRequest {
        <DeleteRangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRangeRequest {
    pub fn new() -> DeleteRangeRequest {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes range_end = 2;


    pub fn get_range_end(&self) -> &[u8] {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_end, ::std::vec::Vec::new())
    }

    // bool prev_kv = 3;


    pub fn get_prev_kv(&self) -> bool {
        self.prev_kv
    }
    pub fn clear_prev_kv(&mut self) {
        self.prev_kv = false;
    }

    // Param is passed by value, moved
    pub fn set_prev_kv(&mut self, v: bool) {
        self.prev_kv = v;
    }
}

impl ::protobuf::Message for DeleteRangeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_end)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prev_kv = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.range_end);
        }
        if self.prev_kv != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_bytes(2, &self.range_end)?;
        }
        if self.prev_kv != false {
            os.write_bool(3, self.prev_kv)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRangeRequest {
        DeleteRangeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &DeleteRangeRequest| { &m.key },
                    |m: &mut DeleteRangeRequest| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "range_end",
                    |m: &DeleteRangeRequest| { &m.range_end },
                    |m: &mut DeleteRangeRequest| { &mut m.range_end },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prev_kv",
                    |m: &DeleteRangeRequest| { &m.prev_kv },
                    |m: &mut DeleteRangeRequest| { &mut m.prev_kv },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteRangeRequest>(
                    "DeleteRangeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteRangeRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRangeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteRangeRequest,
        };
        unsafe {
            instance.get(DeleteRangeRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteRangeRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.range_end.clear();
        self.prev_kv = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRangeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRangeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRangeResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub deleted: i64,
    pub prev_kvs: ::protobuf::RepeatedField<super::kv::KeyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRangeResponse {
    fn default() -> &'a DeleteRangeResponse {
        <DeleteRangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRangeResponse {
    pub fn new() -> DeleteRangeResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 deleted = 2;


    pub fn get_deleted(&self) -> i64 {
        self.deleted
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = 0;
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: i64) {
        self.deleted = v;
    }

    // repeated .mvccpb.KeyValue prev_kvs = 3;


    pub fn get_prev_kvs(&self) -> &[super::kv::KeyValue] {
        &self.prev_kvs
    }
    pub fn clear_prev_kvs(&mut self) {
        self.prev_kvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev_kvs(&mut self, v: ::protobuf::RepeatedField<super::kv::KeyValue>) {
        self.prev_kvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prev_kvs(&mut self) -> &mut ::protobuf::RepeatedField<super::kv::KeyValue> {
        &mut self.prev_kvs
    }

    // Take field
    pub fn take_prev_kvs(&mut self) -> ::protobuf::RepeatedField<super::kv::KeyValue> {
        ::std::mem::replace(&mut self.prev_kvs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteRangeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prev_kvs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deleted = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prev_kvs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.deleted != 0 {
            my_size += ::protobuf::rt::value_size(2, self.deleted, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.prev_kvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.deleted != 0 {
            os.write_int64(2, self.deleted)?;
        }
        for v in &self.prev_kvs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRangeResponse {
        DeleteRangeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &DeleteRangeResponse| { &m.header },
                    |m: &mut DeleteRangeResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "deleted",
                    |m: &DeleteRangeResponse| { &m.deleted },
                    |m: &mut DeleteRangeResponse| { &mut m.deleted },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::kv::KeyValue>>(
                    "prev_kvs",
                    |m: &DeleteRangeResponse| { &m.prev_kvs },
                    |m: &mut DeleteRangeResponse| { &mut m.prev_kvs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteRangeResponse>(
                    "DeleteRangeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteRangeResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRangeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteRangeResponse,
        };
        unsafe {
            instance.get(DeleteRangeResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeleteRangeResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.deleted = 0;
        self.prev_kvs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestOp {
    // message oneof groups
    pub request: ::std::option::Option<RequestOp_oneof_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestOp {
    fn default() -> &'a RequestOp {
        <RequestOp as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RequestOp_oneof_request {
    request_range(RangeRequest),
    request_put(PutRequest),
    request_delete_range(DeleteRangeRequest),
    request_txn(TxnRequest),
}

impl RequestOp {
    pub fn new() -> RequestOp {
        ::std::default::Default::default()
    }

    // .etcdserverpb.RangeRequest request_range = 1;


    pub fn get_request_range(&self) -> &RangeRequest {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_range(ref v)) => v,
            _ => RangeRequest::default_instance(),
        }
    }
    pub fn clear_request_range(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_range(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_range(&mut self, v: RangeRequest) {
        self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_range(&mut self) -> &mut RangeRequest {
        if let ::std::option::Option::Some(RequestOp_oneof_request::request_range(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_range(RangeRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_range(&mut self) -> RangeRequest {
        if self.has_request_range() {
            match self.request.take() {
                ::std::option::Option::Some(RequestOp_oneof_request::request_range(v)) => v,
                _ => panic!(),
            }
        } else {
            RangeRequest::new()
        }
    }

    // .etcdserverpb.PutRequest request_put = 2;


    pub fn get_request_put(&self) -> &PutRequest {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_put(ref v)) => v,
            _ => PutRequest::default_instance(),
        }
    }
    pub fn clear_request_put(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_put(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_put(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_put(&mut self, v: PutRequest) {
        self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_put(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_put(&mut self) -> &mut PutRequest {
        if let ::std::option::Option::Some(RequestOp_oneof_request::request_put(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_put(PutRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_put(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_put(&mut self) -> PutRequest {
        if self.has_request_put() {
            match self.request.take() {
                ::std::option::Option::Some(RequestOp_oneof_request::request_put(v)) => v,
                _ => panic!(),
            }
        } else {
            PutRequest::new()
        }
    }

    // .etcdserverpb.DeleteRangeRequest request_delete_range = 3;


    pub fn get_request_delete_range(&self) -> &DeleteRangeRequest {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(ref v)) => v,
            _ => DeleteRangeRequest::default_instance(),
        }
    }
    pub fn clear_request_delete_range(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_delete_range(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_delete_range(&mut self, v: DeleteRangeRequest) {
        self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_delete_range(&mut self) -> &mut DeleteRangeRequest {
        if let ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(DeleteRangeRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_delete_range(&mut self) -> DeleteRangeRequest {
        if self.has_request_delete_range() {
            match self.request.take() {
                ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteRangeRequest::new()
        }
    }

    // .etcdserverpb.TxnRequest request_txn = 4;


    pub fn get_request_txn(&self) -> &TxnRequest {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_txn(ref v)) => v,
            _ => TxnRequest::default_instance(),
        }
    }
    pub fn clear_request_txn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_txn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_txn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_txn(&mut self, v: TxnRequest) {
        self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_txn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_txn(&mut self) -> &mut TxnRequest {
        if let ::std::option::Option::Some(RequestOp_oneof_request::request_txn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_txn(TxnRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_txn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_txn(&mut self) -> TxnRequest {
        if self.has_request_txn() {
            match self.request.take() {
                ::std::option::Option::Some(RequestOp_oneof_request::request_txn(v)) => v,
                _ => panic!(),
            }
        } else {
            TxnRequest::new()
        }
    }
}

impl ::protobuf::Message for RequestOp {
    fn is_initialized(&self) -> bool {
        if let Some(RequestOp_oneof_request::request_range(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestOp_oneof_request::request_put(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestOp_oneof_request::request_delete_range(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestOp_oneof_request::request_txn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_range(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_put(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_txn(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &RequestOp_oneof_request::request_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestOp_oneof_request::request_put(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestOp_oneof_request::request_delete_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestOp_oneof_request::request_txn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &RequestOp_oneof_request::request_range(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestOp_oneof_request::request_put(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestOp_oneof_request::request_delete_range(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestOp_oneof_request::request_txn(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestOp {
        RequestOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RangeRequest>(
                    "request_range",
                    RequestOp::has_request_range,
                    RequestOp::get_request_range,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutRequest>(
                    "request_put",
                    RequestOp::has_request_put,
                    RequestOp::get_request_put,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DeleteRangeRequest>(
                    "request_delete_range",
                    RequestOp::has_request_delete_range,
                    RequestOp::get_request_delete_range,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TxnRequest>(
                    "request_txn",
                    RequestOp::has_request_txn,
                    RequestOp::get_request_txn,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RequestOp>(
                    "RequestOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RequestOp {
        static mut instance: ::protobuf::lazy::Lazy<RequestOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RequestOp,
        };
        unsafe {
            instance.get(RequestOp::new)
        }
    }
}

impl ::protobuf::Clear for RequestOp {
    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseOp {
    // message oneof groups
    pub response: ::std::option::Option<ResponseOp_oneof_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseOp {
    fn default() -> &'a ResponseOp {
        <ResponseOp as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ResponseOp_oneof_response {
    response_range(RangeResponse),
    response_put(PutResponse),
    response_delete_range(DeleteRangeResponse),
    response_txn(TxnResponse),
}

impl ResponseOp {
    pub fn new() -> ResponseOp {
        ::std::default::Default::default()
    }

    // .etcdserverpb.RangeResponse response_range = 1;


    pub fn get_response_range(&self) -> &RangeResponse {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_range(ref v)) => v,
            _ => RangeResponse::default_instance(),
        }
    }
    pub fn clear_response_range(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_range(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_range(&mut self, v: RangeResponse) {
        self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_range(&mut self) -> &mut RangeResponse {
        if let ::std::option::Option::Some(ResponseOp_oneof_response::response_range(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_range(RangeResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_range(&mut self) -> RangeResponse {
        if self.has_response_range() {
            match self.response.take() {
                ::std::option::Option::Some(ResponseOp_oneof_response::response_range(v)) => v,
                _ => panic!(),
            }
        } else {
            RangeResponse::new()
        }
    }

    // .etcdserverpb.PutResponse response_put = 2;


    pub fn get_response_put(&self) -> &PutResponse {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_put(ref v)) => v,
            _ => PutResponse::default_instance(),
        }
    }
    pub fn clear_response_put(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_put(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_put(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_put(&mut self, v: PutResponse) {
        self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_put(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_put(&mut self) -> &mut PutResponse {
        if let ::std::option::Option::Some(ResponseOp_oneof_response::response_put(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_put(PutResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_put(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_put(&mut self) -> PutResponse {
        if self.has_response_put() {
            match self.response.take() {
                ::std::option::Option::Some(ResponseOp_oneof_response::response_put(v)) => v,
                _ => panic!(),
            }
        } else {
            PutResponse::new()
        }
    }

    // .etcdserverpb.DeleteRangeResponse response_delete_range = 3;


    pub fn get_response_delete_range(&self) -> &DeleteRangeResponse {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(ref v)) => v,
            _ => DeleteRangeResponse::default_instance(),
        }
    }
    pub fn clear_response_delete_range(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_delete_range(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_delete_range(&mut self, v: DeleteRangeResponse) {
        self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_delete_range(&mut self) -> &mut DeleteRangeResponse {
        if let ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(DeleteRangeResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_delete_range(&mut self) -> DeleteRangeResponse {
        if self.has_response_delete_range() {
            match self.response.take() {
                ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteRangeResponse::new()
        }
    }

    // .etcdserverpb.TxnResponse response_txn = 4;


    pub fn get_response_txn(&self) -> &TxnResponse {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(ref v)) => v,
            _ => TxnResponse::default_instance(),
        }
    }
    pub fn clear_response_txn(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_txn(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_txn(&mut self, v: TxnResponse) {
        self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_txn(&mut self) -> &mut TxnResponse {
        if let ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(TxnResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_txn(&mut self) -> TxnResponse {
        if self.has_response_txn() {
            match self.response.take() {
                ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(v)) => v,
                _ => panic!(),
            }
        } else {
            TxnResponse::new()
        }
    }
}

impl ::protobuf::Message for ResponseOp {
    fn is_initialized(&self) -> bool {
        if let Some(ResponseOp_oneof_response::response_range(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ResponseOp_oneof_response::response_put(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ResponseOp_oneof_response::response_delete_range(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ResponseOp_oneof_response::response_txn(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_range(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_put(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &ResponseOp_oneof_response::response_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ResponseOp_oneof_response::response_put(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ResponseOp_oneof_response::response_delete_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ResponseOp_oneof_response::response_txn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &ResponseOp_oneof_response::response_range(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ResponseOp_oneof_response::response_put(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ResponseOp_oneof_response::response_delete_range(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ResponseOp_oneof_response::response_txn(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseOp {
        ResponseOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RangeResponse>(
                    "response_range",
                    ResponseOp::has_response_range,
                    ResponseOp::get_response_range,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutResponse>(
                    "response_put",
                    ResponseOp::has_response_put,
                    ResponseOp::get_response_put,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DeleteRangeResponse>(
                    "response_delete_range",
                    ResponseOp::has_response_delete_range,
                    ResponseOp::get_response_delete_range,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TxnResponse>(
                    "response_txn",
                    ResponseOp::has_response_txn,
                    ResponseOp::get_response_txn,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResponseOp>(
                    "ResponseOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResponseOp {
        static mut instance: ::protobuf::lazy::Lazy<ResponseOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResponseOp,
        };
        unsafe {
            instance.get(ResponseOp::new)
        }
    }
}

impl ::protobuf::Clear for ResponseOp {
    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Compare {
    // message fields
    pub result: Compare_CompareResult,
    pub target: Compare_CompareTarget,
    pub key: ::std::vec::Vec<u8>,
    pub range_end: ::std::vec::Vec<u8>,
    // message oneof groups
    pub target_union: ::std::option::Option<Compare_oneof_target_union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Compare {
    fn default() -> &'a Compare {
        <Compare as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Compare_oneof_target_union {
    version(i64),
    create_revision(i64),
    mod_revision(i64),
    value(::std::vec::Vec<u8>),
}

impl Compare {
    pub fn new() -> Compare {
        ::std::default::Default::default()
    }

    // .etcdserverpb.Compare.CompareResult result = 1;


    pub fn get_result(&self) -> Compare_CompareResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = Compare_CompareResult::EQUAL;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Compare_CompareResult) {
        self.result = v;
    }

    // .etcdserverpb.Compare.CompareTarget target = 2;


    pub fn get_target(&self) -> Compare_CompareTarget {
        self.target
    }
    pub fn clear_target(&mut self) {
        self.target = Compare_CompareTarget::VERSION;
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: Compare_CompareTarget) {
        self.target = v;
    }

    // bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // int64 version = 4;


    pub fn get_version(&self) -> i64 {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::version(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_version(&mut self) {
        self.target_union = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::version(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::version(v))
    }

    // int64 create_revision = 5;


    pub fn get_create_revision(&self) -> i64 {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::create_revision(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_create_revision(&mut self) {
        self.target_union = ::std::option::Option::None;
    }

    pub fn has_create_revision(&self) -> bool {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::create_revision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_revision(&mut self, v: i64) {
        self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::create_revision(v))
    }

    // int64 mod_revision = 6;


    pub fn get_mod_revision(&self) -> i64 {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::mod_revision(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mod_revision(&mut self) {
        self.target_union = ::std::option::Option::None;
    }

    pub fn has_mod_revision(&self) -> bool {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::mod_revision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mod_revision(&mut self, v: i64) {
        self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::mod_revision(v))
    }

    // bytes value = 7;


    pub fn get_value(&self) -> &[u8] {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::value(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_value(&mut self) {
        self.target_union = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Compare_oneof_target_union::value(_)) = self.target_union {
        } else {
            self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::value(::std::vec::Vec::new()));
        }
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_value() {
            match self.target_union.take() {
                ::std::option::Option::Some(Compare_oneof_target_union::value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes range_end = 8;


    pub fn get_range_end(&self) -> &[u8] {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_end, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Compare {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.target, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::version(is.read_int64()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::create_revision(is.read_int64()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::mod_revision(is.read_int64()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::value(is.read_bytes()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != Compare_CompareResult::EQUAL {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        if self.target != Compare_CompareTarget::VERSION {
            my_size += ::protobuf::rt::enum_size(2, self.target);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.range_end);
        }
        if let ::std::option::Option::Some(ref v) = self.target_union {
            match v {
                &Compare_oneof_target_union::version(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Compare_oneof_target_union::create_revision(v) => {
                    my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Compare_oneof_target_union::mod_revision(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Compare_oneof_target_union::value(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != Compare_CompareResult::EQUAL {
            os.write_enum(1, self.result.value())?;
        }
        if self.target != Compare_CompareTarget::VERSION {
            os.write_enum(2, self.target.value())?;
        }
        if !self.key.is_empty() {
            os.write_bytes(3, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_bytes(8, &self.range_end)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target_union {
            match v {
                &Compare_oneof_target_union::version(v) => {
                    os.write_int64(4, v)?;
                },
                &Compare_oneof_target_union::create_revision(v) => {
                    os.write_int64(5, v)?;
                },
                &Compare_oneof_target_union::mod_revision(v) => {
                    os.write_int64(6, v)?;
                },
                &Compare_oneof_target_union::value(ref v) => {
                    os.write_bytes(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Compare {
        Compare::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Compare_CompareResult>>(
                    "result",
                    |m: &Compare| { &m.result },
                    |m: &mut Compare| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Compare_CompareTarget>>(
                    "target",
                    |m: &Compare| { &m.target },
                    |m: &mut Compare| { &mut m.target },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &Compare| { &m.key },
                    |m: &mut Compare| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "version",
                    Compare::has_version,
                    Compare::get_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "create_revision",
                    Compare::has_create_revision,
                    Compare::get_create_revision,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "mod_revision",
                    Compare::has_mod_revision,
                    Compare::get_mod_revision,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "value",
                    Compare::has_value,
                    Compare::get_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "range_end",
                    |m: &Compare| { &m.range_end },
                    |m: &mut Compare| { &mut m.range_end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Compare>(
                    "Compare",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Compare {
        static mut instance: ::protobuf::lazy::Lazy<Compare> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Compare,
        };
        unsafe {
            instance.get(Compare::new)
        }
    }
}

impl ::protobuf::Clear for Compare {
    fn clear(&mut self) {
        self.result = Compare_CompareResult::EQUAL;
        self.target = Compare_CompareTarget::VERSION;
        self.key.clear();
        self.target_union = ::std::option::Option::None;
        self.target_union = ::std::option::Option::None;
        self.target_union = ::std::option::Option::None;
        self.target_union = ::std::option::Option::None;
        self.range_end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Compare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Compare {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Compare_CompareResult {
    EQUAL = 0,
    GREATER = 1,
    LESS = 2,
    NOT_EQUAL = 3,
}

impl ::protobuf::ProtobufEnum for Compare_CompareResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Compare_CompareResult> {
        match value {
            0 => ::std::option::Option::Some(Compare_CompareResult::EQUAL),
            1 => ::std::option::Option::Some(Compare_CompareResult::GREATER),
            2 => ::std::option::Option::Some(Compare_CompareResult::LESS),
            3 => ::std::option::Option::Some(Compare_CompareResult::NOT_EQUAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Compare_CompareResult] = &[
            Compare_CompareResult::EQUAL,
            Compare_CompareResult::GREATER,
            Compare_CompareResult::LESS,
            Compare_CompareResult::NOT_EQUAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Compare_CompareResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Compare_CompareResult {
}

impl ::std::default::Default for Compare_CompareResult {
    fn default() -> Self {
        Compare_CompareResult::EQUAL
    }
}

impl ::protobuf::reflect::ProtobufValue for Compare_CompareResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Compare_CompareTarget {
    VERSION = 0,
    CREATE = 1,
    MOD = 2,
    VALUE = 3,
}

impl ::protobuf::ProtobufEnum for Compare_CompareTarget {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Compare_CompareTarget> {
        match value {
            0 => ::std::option::Option::Some(Compare_CompareTarget::VERSION),
            1 => ::std::option::Option::Some(Compare_CompareTarget::CREATE),
            2 => ::std::option::Option::Some(Compare_CompareTarget::MOD),
            3 => ::std::option::Option::Some(Compare_CompareTarget::VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Compare_CompareTarget] = &[
            Compare_CompareTarget::VERSION,
            Compare_CompareTarget::CREATE,
            Compare_CompareTarget::MOD,
            Compare_CompareTarget::VALUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Compare_CompareTarget", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Compare_CompareTarget {
}

impl ::std::default::Default for Compare_CompareTarget {
    fn default() -> Self {
        Compare_CompareTarget::VERSION
    }
}

impl ::protobuf::reflect::ProtobufValue for Compare_CompareTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnRequest {
    // message fields
    pub compare: ::protobuf::RepeatedField<Compare>,
    pub success: ::protobuf::RepeatedField<RequestOp>,
    pub failure: ::protobuf::RepeatedField<RequestOp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnRequest {
    fn default() -> &'a TxnRequest {
        <TxnRequest as ::protobuf::Message>::default_instance()
    }
}

impl TxnRequest {
    pub fn new() -> TxnRequest {
        ::std::default::Default::default()
    }

    // repeated .etcdserverpb.Compare compare = 1;


    pub fn get_compare(&self) -> &[Compare] {
        &self.compare
    }
    pub fn clear_compare(&mut self) {
        self.compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_compare(&mut self, v: ::protobuf::RepeatedField<Compare>) {
        self.compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_compare(&mut self) -> &mut ::protobuf::RepeatedField<Compare> {
        &mut self.compare
    }

    // Take field
    pub fn take_compare(&mut self) -> ::protobuf::RepeatedField<Compare> {
        ::std::mem::replace(&mut self.compare, ::protobuf::RepeatedField::new())
    }

    // repeated .etcdserverpb.RequestOp success = 2;


    pub fn get_success(&self) -> &[RequestOp] {
        &self.success
    }
    pub fn clear_success(&mut self) {
        self.success.clear();
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: ::protobuf::RepeatedField<RequestOp>) {
        self.success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_success(&mut self) -> &mut ::protobuf::RepeatedField<RequestOp> {
        &mut self.success
    }

    // Take field
    pub fn take_success(&mut self) -> ::protobuf::RepeatedField<RequestOp> {
        ::std::mem::replace(&mut self.success, ::protobuf::RepeatedField::new())
    }

    // repeated .etcdserverpb.RequestOp failure = 3;


    pub fn get_failure(&self) -> &[RequestOp] {
        &self.failure
    }
    pub fn clear_failure(&mut self) {
        self.failure.clear();
    }

    // Param is passed by value, moved
    pub fn set_failure(&mut self, v: ::protobuf::RepeatedField<RequestOp>) {
        self.failure = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failure(&mut self) -> &mut ::protobuf::RepeatedField<RequestOp> {
        &mut self.failure
    }

    // Take field
    pub fn take_failure(&mut self) -> ::protobuf::RepeatedField<RequestOp> {
        ::std::mem::replace(&mut self.failure, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TxnRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.compare {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.success {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.failure {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.compare)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.success)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.failure)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.success {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.failure {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.compare {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.success {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.failure {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnRequest {
        TxnRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Compare>>(
                    "compare",
                    |m: &TxnRequest| { &m.compare },
                    |m: &mut TxnRequest| { &mut m.compare },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestOp>>(
                    "success",
                    |m: &TxnRequest| { &m.success },
                    |m: &mut TxnRequest| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestOp>>(
                    "failure",
                    |m: &TxnRequest| { &m.failure },
                    |m: &mut TxnRequest| { &mut m.failure },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TxnRequest>(
                    "TxnRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxnRequest {
        static mut instance: ::protobuf::lazy::Lazy<TxnRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxnRequest,
        };
        unsafe {
            instance.get(TxnRequest::new)
        }
    }
}

impl ::protobuf::Clear for TxnRequest {
    fn clear(&mut self) {
        self.compare.clear();
        self.success.clear();
        self.failure.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxnRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub succeeded: bool,
    pub responses: ::protobuf::RepeatedField<ResponseOp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnResponse {
    fn default() -> &'a TxnResponse {
        <TxnResponse as ::protobuf::Message>::default_instance()
    }
}

impl TxnResponse {
    pub fn new() -> TxnResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // bool succeeded = 2;


    pub fn get_succeeded(&self) -> bool {
        self.succeeded
    }
    pub fn clear_succeeded(&mut self) {
        self.succeeded = false;
    }

    // Param is passed by value, moved
    pub fn set_succeeded(&mut self, v: bool) {
        self.succeeded = v;
    }

    // repeated .etcdserverpb.ResponseOp responses = 3;


    pub fn get_responses(&self) -> &[ResponseOp] {
        &self.responses
    }
    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<ResponseOp>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<ResponseOp> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<ResponseOp> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TxnResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.succeeded = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.succeeded != false {
            my_size += 2;
        }
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.succeeded != false {
            os.write_bool(2, self.succeeded)?;
        }
        for v in &self.responses {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnResponse {
        TxnResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &TxnResponse| { &m.header },
                    |m: &mut TxnResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "succeeded",
                    |m: &TxnResponse| { &m.succeeded },
                    |m: &mut TxnResponse| { &mut m.succeeded },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseOp>>(
                    "responses",
                    |m: &TxnResponse| { &m.responses },
                    |m: &mut TxnResponse| { &mut m.responses },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TxnResponse>(
                    "TxnResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxnResponse {
        static mut instance: ::protobuf::lazy::Lazy<TxnResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxnResponse,
        };
        unsafe {
            instance.get(TxnResponse::new)
        }
    }
}

impl ::protobuf::Clear for TxnResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.succeeded = false;
        self.responses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxnResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactionRequest {
    // message fields
    pub revision: i64,
    pub physical: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactionRequest {
    fn default() -> &'a CompactionRequest {
        <CompactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CompactionRequest {
    pub fn new() -> CompactionRequest {
        ::std::default::Default::default()
    }

    // int64 revision = 1;


    pub fn get_revision(&self) -> i64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = v;
    }

    // bool physical = 2;


    pub fn get_physical(&self) -> bool {
        self.physical
    }
    pub fn clear_physical(&mut self) {
        self.physical = false;
    }

    // Param is passed by value, moved
    pub fn set_physical(&mut self, v: bool) {
        self.physical = v;
    }
}

impl ::protobuf::Message for CompactionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revision = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.physical = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(1, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.physical != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.revision != 0 {
            os.write_int64(1, self.revision)?;
        }
        if self.physical != false {
            os.write_bool(2, self.physical)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactionRequest {
        CompactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "revision",
                    |m: &CompactionRequest| { &m.revision },
                    |m: &mut CompactionRequest| { &mut m.revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "physical",
                    |m: &CompactionRequest| { &m.physical },
                    |m: &mut CompactionRequest| { &mut m.physical },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompactionRequest>(
                    "CompactionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompactionRequest {
        static mut instance: ::protobuf::lazy::Lazy<CompactionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactionRequest,
        };
        unsafe {
            instance.get(CompactionRequest::new)
        }
    }
}

impl ::protobuf::Clear for CompactionRequest {
    fn clear(&mut self) {
        self.revision = 0;
        self.physical = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactionResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactionResponse {
    fn default() -> &'a CompactionResponse {
        <CompactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CompactionResponse {
    pub fn new() -> CompactionResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for CompactionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactionResponse {
        CompactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &CompactionResponse| { &m.header },
                    |m: &mut CompactionResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompactionResponse>(
                    "CompactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CompactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactionResponse,
        };
        unsafe {
            instance.get(CompactionResponse::new)
        }
    }
}

impl ::protobuf::Clear for CompactionResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HashRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashRequest {
    fn default() -> &'a HashRequest {
        <HashRequest as ::protobuf::Message>::default_instance()
    }
}

impl HashRequest {
    pub fn new() -> HashRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HashRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashRequest {
        HashRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<HashRequest>(
                    "HashRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HashRequest {
        static mut instance: ::protobuf::lazy::Lazy<HashRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HashRequest,
        };
        unsafe {
            instance.get(HashRequest::new)
        }
    }
}

impl ::protobuf::Clear for HashRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HashResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub hash: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashResponse {
    fn default() -> &'a HashResponse {
        <HashResponse as ::protobuf::Message>::default_instance()
    }
}

impl HashResponse {
    pub fn new() -> HashResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // uint32 hash = 2;


    pub fn get_hash(&self) -> u32 {
        self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash = 0;
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = v;
    }
}

impl ::protobuf::Message for HashResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hash = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.hash != 0 {
            my_size += ::protobuf::rt::value_size(2, self.hash, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.hash != 0 {
            os.write_uint32(2, self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashResponse {
        HashResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &HashResponse| { &m.header },
                    |m: &mut HashResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hash",
                    |m: &HashResponse| { &m.hash },
                    |m: &mut HashResponse| { &mut m.hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HashResponse>(
                    "HashResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HashResponse {
        static mut instance: ::protobuf::lazy::Lazy<HashResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HashResponse,
        };
        unsafe {
            instance.get(HashResponse::new)
        }
    }
}

impl ::protobuf::Clear for HashResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.hash = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HashKVRequest {
    // message fields
    pub revision: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashKVRequest {
    fn default() -> &'a HashKVRequest {
        <HashKVRequest as ::protobuf::Message>::default_instance()
    }
}

impl HashKVRequest {
    pub fn new() -> HashKVRequest {
        ::std::default::Default::default()
    }

    // int64 revision = 1;


    pub fn get_revision(&self) -> i64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = v;
    }
}

impl ::protobuf::Message for HashKVRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revision = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(1, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.revision != 0 {
            os.write_int64(1, self.revision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashKVRequest {
        HashKVRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "revision",
                    |m: &HashKVRequest| { &m.revision },
                    |m: &mut HashKVRequest| { &mut m.revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HashKVRequest>(
                    "HashKVRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HashKVRequest {
        static mut instance: ::protobuf::lazy::Lazy<HashKVRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HashKVRequest,
        };
        unsafe {
            instance.get(HashKVRequest::new)
        }
    }
}

impl ::protobuf::Clear for HashKVRequest {
    fn clear(&mut self) {
        self.revision = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashKVRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashKVRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HashKVResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub hash: u32,
    pub compact_revision: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashKVResponse {
    fn default() -> &'a HashKVResponse {
        <HashKVResponse as ::protobuf::Message>::default_instance()
    }
}

impl HashKVResponse {
    pub fn new() -> HashKVResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // uint32 hash = 2;


    pub fn get_hash(&self) -> u32 {
        self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash = 0;
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = v;
    }

    // int64 compact_revision = 3;


    pub fn get_compact_revision(&self) -> i64 {
        self.compact_revision
    }
    pub fn clear_compact_revision(&mut self) {
        self.compact_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_compact_revision(&mut self, v: i64) {
        self.compact_revision = v;
    }
}

impl ::protobuf::Message for HashKVResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hash = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compact_revision = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.hash != 0 {
            my_size += ::protobuf::rt::value_size(2, self.hash, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compact_revision != 0 {
            my_size += ::protobuf::rt::value_size(3, self.compact_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.hash != 0 {
            os.write_uint32(2, self.hash)?;
        }
        if self.compact_revision != 0 {
            os.write_int64(3, self.compact_revision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashKVResponse {
        HashKVResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &HashKVResponse| { &m.header },
                    |m: &mut HashKVResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hash",
                    |m: &HashKVResponse| { &m.hash },
                    |m: &mut HashKVResponse| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "compact_revision",
                    |m: &HashKVResponse| { &m.compact_revision },
                    |m: &mut HashKVResponse| { &mut m.compact_revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HashKVResponse>(
                    "HashKVResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HashKVResponse {
        static mut instance: ::protobuf::lazy::Lazy<HashKVResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HashKVResponse,
        };
        unsafe {
            instance.get(HashKVResponse::new)
        }
    }
}

impl ::protobuf::Clear for HashKVResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.hash = 0;
        self.compact_revision = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashKVResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashKVResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotRequest {
    fn default() -> &'a SnapshotRequest {
        <SnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotRequest {
    pub fn new() -> SnapshotRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SnapshotRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotRequest {
        SnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SnapshotRequest>(
                    "SnapshotRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SnapshotRequest {
        static mut instance: ::protobuf::lazy::Lazy<SnapshotRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SnapshotRequest,
        };
        unsafe {
            instance.get(SnapshotRequest::new)
        }
    }
}

impl ::protobuf::Clear for SnapshotRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub remaining_bytes: u64,
    pub blob: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotResponse {
    fn default() -> &'a SnapshotResponse {
        <SnapshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotResponse {
    pub fn new() -> SnapshotResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // uint64 remaining_bytes = 2;


    pub fn get_remaining_bytes(&self) -> u64 {
        self.remaining_bytes
    }
    pub fn clear_remaining_bytes(&mut self) {
        self.remaining_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_remaining_bytes(&mut self, v: u64) {
        self.remaining_bytes = v;
    }

    // bytes blob = 3;


    pub fn get_blob(&self) -> &[u8] {
        &self.blob
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blob
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blob, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SnapshotResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining_bytes = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.remaining_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.remaining_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.blob.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.blob);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.remaining_bytes != 0 {
            os.write_uint64(2, self.remaining_bytes)?;
        }
        if !self.blob.is_empty() {
            os.write_bytes(3, &self.blob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotResponse {
        SnapshotResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &SnapshotResponse| { &m.header },
                    |m: &mut SnapshotResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "remaining_bytes",
                    |m: &SnapshotResponse| { &m.remaining_bytes },
                    |m: &mut SnapshotResponse| { &mut m.remaining_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blob",
                    |m: &SnapshotResponse| { &m.blob },
                    |m: &mut SnapshotResponse| { &mut m.blob },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SnapshotResponse>(
                    "SnapshotResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SnapshotResponse {
        static mut instance: ::protobuf::lazy::Lazy<SnapshotResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SnapshotResponse,
        };
        unsafe {
            instance.get(SnapshotResponse::new)
        }
    }
}

impl ::protobuf::Clear for SnapshotResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.remaining_bytes = 0;
        self.blob.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchRequest {
    // message oneof groups
    pub request_union: ::std::option::Option<WatchRequest_oneof_request_union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchRequest {
    fn default() -> &'a WatchRequest {
        <WatchRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum WatchRequest_oneof_request_union {
    create_request(WatchCreateRequest),
    cancel_request(WatchCancelRequest),
}

impl WatchRequest {
    pub fn new() -> WatchRequest {
        ::std::default::Default::default()
    }

    // .etcdserverpb.WatchCreateRequest create_request = 1;


    pub fn get_create_request(&self) -> &WatchCreateRequest {
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(ref v)) => v,
            _ => WatchCreateRequest::default_instance(),
        }
    }
    pub fn clear_create_request(&mut self) {
        self.request_union = ::std::option::Option::None;
    }

    pub fn has_create_request(&self) -> bool {
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_request(&mut self, v: WatchCreateRequest) {
        self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_request(&mut self) -> &mut WatchCreateRequest {
        if let ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(_)) = self.request_union {
        } else {
            self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(WatchCreateRequest::new()));
        }
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_request(&mut self) -> WatchCreateRequest {
        if self.has_create_request() {
            match self.request_union.take() {
                ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WatchCreateRequest::new()
        }
    }

    // .etcdserverpb.WatchCancelRequest cancel_request = 2;


    pub fn get_cancel_request(&self) -> &WatchCancelRequest {
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(ref v)) => v,
            _ => WatchCancelRequest::default_instance(),
        }
    }
    pub fn clear_cancel_request(&mut self) {
        self.request_union = ::std::option::Option::None;
    }

    pub fn has_cancel_request(&self) -> bool {
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cancel_request(&mut self, v: WatchCancelRequest) {
        self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cancel_request(&mut self) -> &mut WatchCancelRequest {
        if let ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(_)) = self.request_union {
        } else {
            self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(WatchCancelRequest::new()));
        }
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cancel_request(&mut self) -> WatchCancelRequest {
        if self.has_cancel_request() {
            match self.request_union.take() {
                ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WatchCancelRequest::new()
        }
    }
}

impl ::protobuf::Message for WatchRequest {
    fn is_initialized(&self) -> bool {
        if let Some(WatchRequest_oneof_request_union::create_request(ref v)) = self.request_union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(WatchRequest_oneof_request_union::cancel_request(ref v)) = self.request_union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request_union {
            match v {
                &WatchRequest_oneof_request_union::create_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &WatchRequest_oneof_request_union::cancel_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request_union {
            match v {
                &WatchRequest_oneof_request_union::create_request(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &WatchRequest_oneof_request_union::cancel_request(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchRequest {
        WatchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WatchCreateRequest>(
                    "create_request",
                    WatchRequest::has_create_request,
                    WatchRequest::get_create_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WatchCancelRequest>(
                    "cancel_request",
                    WatchRequest::has_cancel_request,
                    WatchRequest::get_cancel_request,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WatchRequest>(
                    "WatchRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WatchRequest {
        static mut instance: ::protobuf::lazy::Lazy<WatchRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WatchRequest,
        };
        unsafe {
            instance.get(WatchRequest::new)
        }
    }
}

impl ::protobuf::Clear for WatchRequest {
    fn clear(&mut self) {
        self.request_union = ::std::option::Option::None;
        self.request_union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchCreateRequest {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub range_end: ::std::vec::Vec<u8>,
    pub start_revision: i64,
    pub progress_notify: bool,
    pub filters: ::std::vec::Vec<WatchCreateRequest_FilterType>,
    pub prev_kv: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchCreateRequest {
    fn default() -> &'a WatchCreateRequest {
        <WatchCreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl WatchCreateRequest {
    pub fn new() -> WatchCreateRequest {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes range_end = 2;


    pub fn get_range_end(&self) -> &[u8] {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_end, ::std::vec::Vec::new())
    }

    // int64 start_revision = 3;


    pub fn get_start_revision(&self) -> i64 {
        self.start_revision
    }
    pub fn clear_start_revision(&mut self) {
        self.start_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_revision(&mut self, v: i64) {
        self.start_revision = v;
    }

    // bool progress_notify = 4;


    pub fn get_progress_notify(&self) -> bool {
        self.progress_notify
    }
    pub fn clear_progress_notify(&mut self) {
        self.progress_notify = false;
    }

    // Param is passed by value, moved
    pub fn set_progress_notify(&mut self, v: bool) {
        self.progress_notify = v;
    }

    // repeated .etcdserverpb.WatchCreateRequest.FilterType filters = 5;


    pub fn get_filters(&self) -> &[WatchCreateRequest_FilterType] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::std::vec::Vec<WatchCreateRequest_FilterType>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::std::vec::Vec<WatchCreateRequest_FilterType> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::std::vec::Vec<WatchCreateRequest_FilterType> {
        ::std::mem::replace(&mut self.filters, ::std::vec::Vec::new())
    }

    // bool prev_kv = 6;


    pub fn get_prev_kv(&self) -> bool {
        self.prev_kv
    }
    pub fn clear_prev_kv(&mut self) {
        self.prev_kv = false;
    }

    // Param is passed by value, moved
    pub fn set_prev_kv(&mut self, v: bool) {
        self.prev_kv = v;
    }
}

impl ::protobuf::Message for WatchCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_end)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_revision = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.progress_notify = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.filters, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prev_kv = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.range_end);
        }
        if self.start_revision != 0 {
            my_size += ::protobuf::rt::value_size(3, self.start_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.progress_notify != false {
            my_size += 2;
        }
        for value in &self.filters {
            my_size += ::protobuf::rt::enum_size(5, *value);
        };
        if self.prev_kv != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_bytes(2, &self.range_end)?;
        }
        if self.start_revision != 0 {
            os.write_int64(3, self.start_revision)?;
        }
        if self.progress_notify != false {
            os.write_bool(4, self.progress_notify)?;
        }
        for v in &self.filters {
            os.write_enum(5, v.value())?;
        };
        if self.prev_kv != false {
            os.write_bool(6, self.prev_kv)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchCreateRequest {
        WatchCreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &WatchCreateRequest| { &m.key },
                    |m: &mut WatchCreateRequest| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "range_end",
                    |m: &WatchCreateRequest| { &m.range_end },
                    |m: &mut WatchCreateRequest| { &mut m.range_end },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "start_revision",
                    |m: &WatchCreateRequest| { &m.start_revision },
                    |m: &mut WatchCreateRequest| { &mut m.start_revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "progress_notify",
                    |m: &WatchCreateRequest| { &m.progress_notify },
                    |m: &mut WatchCreateRequest| { &mut m.progress_notify },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WatchCreateRequest_FilterType>>(
                    "filters",
                    |m: &WatchCreateRequest| { &m.filters },
                    |m: &mut WatchCreateRequest| { &mut m.filters },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prev_kv",
                    |m: &WatchCreateRequest| { &m.prev_kv },
                    |m: &mut WatchCreateRequest| { &mut m.prev_kv },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WatchCreateRequest>(
                    "WatchCreateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WatchCreateRequest {
        static mut instance: ::protobuf::lazy::Lazy<WatchCreateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WatchCreateRequest,
        };
        unsafe {
            instance.get(WatchCreateRequest::new)
        }
    }
}

impl ::protobuf::Clear for WatchCreateRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.range_end.clear();
        self.start_revision = 0;
        self.progress_notify = false;
        self.filters.clear();
        self.prev_kv = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WatchCreateRequest_FilterType {
    NOPUT = 0,
    NODELETE = 1,
}

impl ::protobuf::ProtobufEnum for WatchCreateRequest_FilterType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WatchCreateRequest_FilterType> {
        match value {
            0 => ::std::option::Option::Some(WatchCreateRequest_FilterType::NOPUT),
            1 => ::std::option::Option::Some(WatchCreateRequest_FilterType::NODELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WatchCreateRequest_FilterType] = &[
            WatchCreateRequest_FilterType::NOPUT,
            WatchCreateRequest_FilterType::NODELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("WatchCreateRequest_FilterType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WatchCreateRequest_FilterType {
}

impl ::std::default::Default for WatchCreateRequest_FilterType {
    fn default() -> Self {
        WatchCreateRequest_FilterType::NOPUT
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchCreateRequest_FilterType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchCancelRequest {
    // message fields
    pub watch_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchCancelRequest {
    fn default() -> &'a WatchCancelRequest {
        <WatchCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl WatchCancelRequest {
    pub fn new() -> WatchCancelRequest {
        ::std::default::Default::default()
    }

    // int64 watch_id = 1;


    pub fn get_watch_id(&self) -> i64 {
        self.watch_id
    }
    pub fn clear_watch_id(&mut self) {
        self.watch_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_watch_id(&mut self, v: i64) {
        self.watch_id = v;
    }
}

impl ::protobuf::Message for WatchCancelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.watch_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.watch_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.watch_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.watch_id != 0 {
            os.write_int64(1, self.watch_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchCancelRequest {
        WatchCancelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "watch_id",
                    |m: &WatchCancelRequest| { &m.watch_id },
                    |m: &mut WatchCancelRequest| { &mut m.watch_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WatchCancelRequest>(
                    "WatchCancelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WatchCancelRequest {
        static mut instance: ::protobuf::lazy::Lazy<WatchCancelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WatchCancelRequest,
        };
        unsafe {
            instance.get(WatchCancelRequest::new)
        }
    }
}

impl ::protobuf::Clear for WatchCancelRequest {
    fn clear(&mut self) {
        self.watch_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchCancelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub watch_id: i64,
    pub created: bool,
    pub canceled: bool,
    pub compact_revision: i64,
    pub cancel_reason: ::std::string::String,
    pub events: ::protobuf::RepeatedField<super::kv::Event>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchResponse {
    fn default() -> &'a WatchResponse {
        <WatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl WatchResponse {
    pub fn new() -> WatchResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 watch_id = 2;


    pub fn get_watch_id(&self) -> i64 {
        self.watch_id
    }
    pub fn clear_watch_id(&mut self) {
        self.watch_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_watch_id(&mut self, v: i64) {
        self.watch_id = v;
    }

    // bool created = 3;


    pub fn get_created(&self) -> bool {
        self.created
    }
    pub fn clear_created(&mut self) {
        self.created = false;
    }

    // Param is passed by value, moved
    pub fn set_created(&mut self, v: bool) {
        self.created = v;
    }

    // bool canceled = 4;


    pub fn get_canceled(&self) -> bool {
        self.canceled
    }
    pub fn clear_canceled(&mut self) {
        self.canceled = false;
    }

    // Param is passed by value, moved
    pub fn set_canceled(&mut self, v: bool) {
        self.canceled = v;
    }

    // int64 compact_revision = 5;


    pub fn get_compact_revision(&self) -> i64 {
        self.compact_revision
    }
    pub fn clear_compact_revision(&mut self) {
        self.compact_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_compact_revision(&mut self, v: i64) {
        self.compact_revision = v;
    }

    // string cancel_reason = 6;


    pub fn get_cancel_reason(&self) -> &str {
        &self.cancel_reason
    }
    pub fn clear_cancel_reason(&mut self) {
        self.cancel_reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_cancel_reason(&mut self, v: ::std::string::String) {
        self.cancel_reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_reason(&mut self) -> &mut ::std::string::String {
        &mut self.cancel_reason
    }

    // Take field
    pub fn take_cancel_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cancel_reason, ::std::string::String::new())
    }

    // repeated .mvccpb.Event events = 11;


    pub fn get_events(&self) -> &[super::kv::Event] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<super::kv::Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<super::kv::Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<super::kv::Event> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WatchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.watch_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.created = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.canceled = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compact_revision = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cancel_reason)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.watch_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.watch_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.created != false {
            my_size += 2;
        }
        if self.canceled != false {
            my_size += 2;
        }
        if self.compact_revision != 0 {
            my_size += ::protobuf::rt::value_size(5, self.compact_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cancel_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.cancel_reason);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.watch_id != 0 {
            os.write_int64(2, self.watch_id)?;
        }
        if self.created != false {
            os.write_bool(3, self.created)?;
        }
        if self.canceled != false {
            os.write_bool(4, self.canceled)?;
        }
        if self.compact_revision != 0 {
            os.write_int64(5, self.compact_revision)?;
        }
        if !self.cancel_reason.is_empty() {
            os.write_string(6, &self.cancel_reason)?;
        }
        for v in &self.events {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchResponse {
        WatchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &WatchResponse| { &m.header },
                    |m: &mut WatchResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "watch_id",
                    |m: &WatchResponse| { &m.watch_id },
                    |m: &mut WatchResponse| { &mut m.watch_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "created",
                    |m: &WatchResponse| { &m.created },
                    |m: &mut WatchResponse| { &mut m.created },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "canceled",
                    |m: &WatchResponse| { &m.canceled },
                    |m: &mut WatchResponse| { &mut m.canceled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "compact_revision",
                    |m: &WatchResponse| { &m.compact_revision },
                    |m: &mut WatchResponse| { &mut m.compact_revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cancel_reason",
                    |m: &WatchResponse| { &m.cancel_reason },
                    |m: &mut WatchResponse| { &mut m.cancel_reason },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::kv::Event>>(
                    "events",
                    |m: &WatchResponse| { &m.events },
                    |m: &mut WatchResponse| { &mut m.events },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WatchResponse>(
                    "WatchResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WatchResponse {
        static mut instance: ::protobuf::lazy::Lazy<WatchResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WatchResponse,
        };
        unsafe {
            instance.get(WatchResponse::new)
        }
    }
}

impl ::protobuf::Clear for WatchResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.watch_id = 0;
        self.created = false;
        self.canceled = false;
        self.compact_revision = 0;
        self.cancel_reason.clear();
        self.events.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseGrantRequest {
    // message fields
    pub TTL: i64,
    pub ID: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseGrantRequest {
    fn default() -> &'a LeaseGrantRequest {
        <LeaseGrantRequest as ::protobuf::Message>::default_instance()
    }
}

impl LeaseGrantRequest {
    pub fn new() -> LeaseGrantRequest {
        ::std::default::Default::default()
    }

    // int64 TTL = 1;


    pub fn get_TTL(&self) -> i64 {
        self.TTL
    }
    pub fn clear_TTL(&mut self) {
        self.TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_TTL(&mut self, v: i64) {
        self.TTL = v;
    }

    // int64 ID = 2;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }
}

impl ::protobuf::Message for LeaseGrantRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TTL = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.TTL != 0 {
            my_size += ::protobuf::rt::value_size(1, self.TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.TTL != 0 {
            os.write_int64(1, self.TTL)?;
        }
        if self.ID != 0 {
            os.write_int64(2, self.ID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseGrantRequest {
        LeaseGrantRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TTL",
                    |m: &LeaseGrantRequest| { &m.TTL },
                    |m: &mut LeaseGrantRequest| { &mut m.TTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ID",
                    |m: &LeaseGrantRequest| { &m.ID },
                    |m: &mut LeaseGrantRequest| { &mut m.ID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaseGrantRequest>(
                    "LeaseGrantRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaseGrantRequest {
        static mut instance: ::protobuf::lazy::Lazy<LeaseGrantRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaseGrantRequest,
        };
        unsafe {
            instance.get(LeaseGrantRequest::new)
        }
    }
}

impl ::protobuf::Clear for LeaseGrantRequest {
    fn clear(&mut self) {
        self.TTL = 0;
        self.ID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseGrantRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseGrantRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseGrantResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub ID: i64,
    pub TTL: i64,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseGrantResponse {
    fn default() -> &'a LeaseGrantResponse {
        <LeaseGrantResponse as ::protobuf::Message>::default_instance()
    }
}

impl LeaseGrantResponse {
    pub fn new() -> LeaseGrantResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 ID = 2;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }

    // int64 TTL = 3;


    pub fn get_TTL(&self) -> i64 {
        self.TTL
    }
    pub fn clear_TTL(&mut self) {
        self.TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_TTL(&mut self, v: i64) {
        self.TTL = v;
    }

    // string error = 4;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LeaseGrantResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TTL = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TTL != 0 {
            my_size += ::protobuf::rt::value_size(3, self.TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ID != 0 {
            os.write_int64(2, self.ID)?;
        }
        if self.TTL != 0 {
            os.write_int64(3, self.TTL)?;
        }
        if !self.error.is_empty() {
            os.write_string(4, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseGrantResponse {
        LeaseGrantResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &LeaseGrantResponse| { &m.header },
                    |m: &mut LeaseGrantResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ID",
                    |m: &LeaseGrantResponse| { &m.ID },
                    |m: &mut LeaseGrantResponse| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TTL",
                    |m: &LeaseGrantResponse| { &m.TTL },
                    |m: &mut LeaseGrantResponse| { &mut m.TTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &LeaseGrantResponse| { &m.error },
                    |m: &mut LeaseGrantResponse| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaseGrantResponse>(
                    "LeaseGrantResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaseGrantResponse {
        static mut instance: ::protobuf::lazy::Lazy<LeaseGrantResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaseGrantResponse,
        };
        unsafe {
            instance.get(LeaseGrantResponse::new)
        }
    }
}

impl ::protobuf::Clear for LeaseGrantResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.ID = 0;
        self.TTL = 0;
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseGrantResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseGrantResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseRevokeRequest {
    // message fields
    pub ID: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseRevokeRequest {
    fn default() -> &'a LeaseRevokeRequest {
        <LeaseRevokeRequest as ::protobuf::Message>::default_instance()
    }
}

impl LeaseRevokeRequest {
    pub fn new() -> LeaseRevokeRequest {
        ::std::default::Default::default()
    }

    // int64 ID = 1;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }
}

impl ::protobuf::Message for LeaseRevokeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_int64(1, self.ID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseRevokeRequest {
        LeaseRevokeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ID",
                    |m: &LeaseRevokeRequest| { &m.ID },
                    |m: &mut LeaseRevokeRequest| { &mut m.ID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaseRevokeRequest>(
                    "LeaseRevokeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaseRevokeRequest {
        static mut instance: ::protobuf::lazy::Lazy<LeaseRevokeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaseRevokeRequest,
        };
        unsafe {
            instance.get(LeaseRevokeRequest::new)
        }
    }
}

impl ::protobuf::Clear for LeaseRevokeRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseRevokeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseRevokeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseRevokeResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseRevokeResponse {
    fn default() -> &'a LeaseRevokeResponse {
        <LeaseRevokeResponse as ::protobuf::Message>::default_instance()
    }
}

impl LeaseRevokeResponse {
    pub fn new() -> LeaseRevokeResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for LeaseRevokeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseRevokeResponse {
        LeaseRevokeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &LeaseRevokeResponse| { &m.header },
                    |m: &mut LeaseRevokeResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaseRevokeResponse>(
                    "LeaseRevokeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaseRevokeResponse {
        static mut instance: ::protobuf::lazy::Lazy<LeaseRevokeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaseRevokeResponse,
        };
        unsafe {
            instance.get(LeaseRevokeResponse::new)
        }
    }
}

impl ::protobuf::Clear for LeaseRevokeResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseRevokeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseRevokeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseKeepAliveRequest {
    // message fields
    pub ID: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseKeepAliveRequest {
    fn default() -> &'a LeaseKeepAliveRequest {
        <LeaseKeepAliveRequest as ::protobuf::Message>::default_instance()
    }
}

impl LeaseKeepAliveRequest {
    pub fn new() -> LeaseKeepAliveRequest {
        ::std::default::Default::default()
    }

    // int64 ID = 1;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }
}

impl ::protobuf::Message for LeaseKeepAliveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_int64(1, self.ID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseKeepAliveRequest {
        LeaseKeepAliveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ID",
                    |m: &LeaseKeepAliveRequest| { &m.ID },
                    |m: &mut LeaseKeepAliveRequest| { &mut m.ID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaseKeepAliveRequest>(
                    "LeaseKeepAliveRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaseKeepAliveRequest {
        static mut instance: ::protobuf::lazy::Lazy<LeaseKeepAliveRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaseKeepAliveRequest,
        };
        unsafe {
            instance.get(LeaseKeepAliveRequest::new)
        }
    }
}

impl ::protobuf::Clear for LeaseKeepAliveRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseKeepAliveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseKeepAliveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseKeepAliveResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub ID: i64,
    pub TTL: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseKeepAliveResponse {
    fn default() -> &'a LeaseKeepAliveResponse {
        <LeaseKeepAliveResponse as ::protobuf::Message>::default_instance()
    }
}

impl LeaseKeepAliveResponse {
    pub fn new() -> LeaseKeepAliveResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 ID = 2;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }

    // int64 TTL = 3;


    pub fn get_TTL(&self) -> i64 {
        self.TTL
    }
    pub fn clear_TTL(&mut self) {
        self.TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_TTL(&mut self, v: i64) {
        self.TTL = v;
    }
}

impl ::protobuf::Message for LeaseKeepAliveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TTL = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TTL != 0 {
            my_size += ::protobuf::rt::value_size(3, self.TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ID != 0 {
            os.write_int64(2, self.ID)?;
        }
        if self.TTL != 0 {
            os.write_int64(3, self.TTL)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseKeepAliveResponse {
        LeaseKeepAliveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &LeaseKeepAliveResponse| { &m.header },
                    |m: &mut LeaseKeepAliveResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ID",
                    |m: &LeaseKeepAliveResponse| { &m.ID },
                    |m: &mut LeaseKeepAliveResponse| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TTL",
                    |m: &LeaseKeepAliveResponse| { &m.TTL },
                    |m: &mut LeaseKeepAliveResponse| { &mut m.TTL },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaseKeepAliveResponse>(
                    "LeaseKeepAliveResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaseKeepAliveResponse {
        static mut instance: ::protobuf::lazy::Lazy<LeaseKeepAliveResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaseKeepAliveResponse,
        };
        unsafe {
            instance.get(LeaseKeepAliveResponse::new)
        }
    }
}

impl ::protobuf::Clear for LeaseKeepAliveResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.ID = 0;
        self.TTL = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseKeepAliveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseKeepAliveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseTimeToLiveRequest {
    // message fields
    pub ID: i64,
    pub keys: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseTimeToLiveRequest {
    fn default() -> &'a LeaseTimeToLiveRequest {
        <LeaseTimeToLiveRequest as ::protobuf::Message>::default_instance()
    }
}

impl LeaseTimeToLiveRequest {
    pub fn new() -> LeaseTimeToLiveRequest {
        ::std::default::Default::default()
    }

    // int64 ID = 1;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }

    // bool keys = 2;


    pub fn get_keys(&self) -> bool {
        self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys = false;
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: bool) {
        self.keys = v;
    }
}

impl ::protobuf::Message for LeaseTimeToLiveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.keys = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.keys != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_int64(1, self.ID)?;
        }
        if self.keys != false {
            os.write_bool(2, self.keys)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseTimeToLiveRequest {
        LeaseTimeToLiveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ID",
                    |m: &LeaseTimeToLiveRequest| { &m.ID },
                    |m: &mut LeaseTimeToLiveRequest| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "keys",
                    |m: &LeaseTimeToLiveRequest| { &m.keys },
                    |m: &mut LeaseTimeToLiveRequest| { &mut m.keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaseTimeToLiveRequest>(
                    "LeaseTimeToLiveRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaseTimeToLiveRequest {
        static mut instance: ::protobuf::lazy::Lazy<LeaseTimeToLiveRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaseTimeToLiveRequest,
        };
        unsafe {
            instance.get(LeaseTimeToLiveRequest::new)
        }
    }
}

impl ::protobuf::Clear for LeaseTimeToLiveRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.keys = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseTimeToLiveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseTimeToLiveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseTimeToLiveResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub ID: i64,
    pub TTL: i64,
    pub grantedTTL: i64,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseTimeToLiveResponse {
    fn default() -> &'a LeaseTimeToLiveResponse {
        <LeaseTimeToLiveResponse as ::protobuf::Message>::default_instance()
    }
}

impl LeaseTimeToLiveResponse {
    pub fn new() -> LeaseTimeToLiveResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 ID = 2;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }

    // int64 TTL = 3;


    pub fn get_TTL(&self) -> i64 {
        self.TTL
    }
    pub fn clear_TTL(&mut self) {
        self.TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_TTL(&mut self, v: i64) {
        self.TTL = v;
    }

    // int64 grantedTTL = 4;


    pub fn get_grantedTTL(&self) -> i64 {
        self.grantedTTL
    }
    pub fn clear_grantedTTL(&mut self) {
        self.grantedTTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_grantedTTL(&mut self, v: i64) {
        self.grantedTTL = v;
    }

    // repeated bytes keys = 5;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LeaseTimeToLiveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TTL = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.grantedTTL = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TTL != 0 {
            my_size += ::protobuf::rt::value_size(3, self.TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.grantedTTL != 0 {
            my_size += ::protobuf::rt::value_size(4, self.grantedTTL, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ID != 0 {
            os.write_int64(2, self.ID)?;
        }
        if self.TTL != 0 {
            os.write_int64(3, self.TTL)?;
        }
        if self.grantedTTL != 0 {
            os.write_int64(4, self.grantedTTL)?;
        }
        for v in &self.keys {
            os.write_bytes(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseTimeToLiveResponse {
        LeaseTimeToLiveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &LeaseTimeToLiveResponse| { &m.header },
                    |m: &mut LeaseTimeToLiveResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ID",
                    |m: &LeaseTimeToLiveResponse| { &m.ID },
                    |m: &mut LeaseTimeToLiveResponse| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "TTL",
                    |m: &LeaseTimeToLiveResponse| { &m.TTL },
                    |m: &mut LeaseTimeToLiveResponse| { &mut m.TTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "grantedTTL",
                    |m: &LeaseTimeToLiveResponse| { &m.grantedTTL },
                    |m: &mut LeaseTimeToLiveResponse| { &mut m.grantedTTL },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "keys",
                    |m: &LeaseTimeToLiveResponse| { &m.keys },
                    |m: &mut LeaseTimeToLiveResponse| { &mut m.keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaseTimeToLiveResponse>(
                    "LeaseTimeToLiveResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaseTimeToLiveResponse {
        static mut instance: ::protobuf::lazy::Lazy<LeaseTimeToLiveResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaseTimeToLiveResponse,
        };
        unsafe {
            instance.get(LeaseTimeToLiveResponse::new)
        }
    }
}

impl ::protobuf::Clear for LeaseTimeToLiveResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.ID = 0;
        self.TTL = 0;
        self.grantedTTL = 0;
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseTimeToLiveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseTimeToLiveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Member {
    // message fields
    pub ID: u64,
    pub name: ::std::string::String,
    pub peerURLs: ::protobuf::RepeatedField<::std::string::String>,
    pub clientURLs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Member {
    fn default() -> &'a Member {
        <Member as ::protobuf::Message>::default_instance()
    }
}

impl Member {
    pub fn new() -> Member {
        ::std::default::Default::default()
    }

    // uint64 ID = 1;


    pub fn get_ID(&self) -> u64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: u64) {
        self.ID = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string peerURLs = 3;


    pub fn get_peerURLs(&self) -> &[::std::string::String] {
        &self.peerURLs
    }
    pub fn clear_peerURLs(&mut self) {
        self.peerURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerURLs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerURLs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerURLs
    }

    // Take field
    pub fn take_peerURLs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerURLs, ::protobuf::RepeatedField::new())
    }

    // repeated string clientURLs = 4;


    pub fn get_clientURLs(&self) -> &[::std::string::String] {
        &self.clientURLs
    }
    pub fn clear_clientURLs(&mut self) {
        self.clientURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_clientURLs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.clientURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clientURLs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.clientURLs
    }

    // Take field
    pub fn take_clientURLs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.clientURLs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerURLs)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.clientURLs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.peerURLs {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.clientURLs {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_uint64(1, self.ID)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.peerURLs {
            os.write_string(3, &v)?;
        };
        for v in &self.clientURLs {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Member {
        Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ID",
                    |m: &Member| { &m.ID },
                    |m: &mut Member| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Member| { &m.name },
                    |m: &mut Member| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerURLs",
                    |m: &Member| { &m.peerURLs },
                    |m: &mut Member| { &mut m.peerURLs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientURLs",
                    |m: &Member| { &m.clientURLs },
                    |m: &mut Member| { &mut m.clientURLs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Member>(
                    "Member",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Member {
        static mut instance: ::protobuf::lazy::Lazy<Member> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Member,
        };
        unsafe {
            instance.get(Member::new)
        }
    }
}

impl ::protobuf::Clear for Member {
    fn clear(&mut self) {
        self.ID = 0;
        self.name.clear();
        self.peerURLs.clear();
        self.clientURLs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Member {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberAddRequest {
    // message fields
    pub peerURLs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberAddRequest {
    fn default() -> &'a MemberAddRequest {
        <MemberAddRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemberAddRequest {
    pub fn new() -> MemberAddRequest {
        ::std::default::Default::default()
    }

    // repeated string peerURLs = 1;


    pub fn get_peerURLs(&self) -> &[::std::string::String] {
        &self.peerURLs
    }
    pub fn clear_peerURLs(&mut self) {
        self.peerURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerURLs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerURLs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerURLs
    }

    // Take field
    pub fn take_peerURLs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerURLs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberAddRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerURLs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peerURLs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peerURLs {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberAddRequest {
        MemberAddRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerURLs",
                    |m: &MemberAddRequest| { &m.peerURLs },
                    |m: &mut MemberAddRequest| { &mut m.peerURLs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemberAddRequest>(
                    "MemberAddRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemberAddRequest {
        static mut instance: ::protobuf::lazy::Lazy<MemberAddRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemberAddRequest,
        };
        unsafe {
            instance.get(MemberAddRequest::new)
        }
    }
}

impl ::protobuf::Clear for MemberAddRequest {
    fn clear(&mut self) {
        self.peerURLs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberAddRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberAddRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberAddResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub member: ::protobuf::SingularPtrField<Member>,
    pub members: ::protobuf::RepeatedField<Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberAddResponse {
    fn default() -> &'a MemberAddResponse {
        <MemberAddResponse as ::protobuf::Message>::default_instance()
    }
}

impl MemberAddResponse {
    pub fn new() -> MemberAddResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // .etcdserverpb.Member member = 2;


    pub fn get_member(&self) -> &Member {
        self.member.as_ref().unwrap_or_else(|| Member::default_instance())
    }
    pub fn clear_member(&mut self) {
        self.member.clear();
    }

    pub fn has_member(&self) -> bool {
        self.member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: Member) {
        self.member = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_member(&mut self) -> &mut Member {
        if self.member.is_none() {
            self.member.set_default();
        }
        self.member.as_mut().unwrap()
    }

    // Take field
    pub fn take_member(&mut self) -> Member {
        self.member.take().unwrap_or_else(|| Member::new())
    }

    // repeated .etcdserverpb.Member members = 3;


    pub fn get_members(&self) -> &[Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberAddResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.member {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.member)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.member.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.member.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberAddResponse {
        MemberAddResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &MemberAddResponse| { &m.header },
                    |m: &mut MemberAddResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                    "member",
                    |m: &MemberAddResponse| { &m.member },
                    |m: &mut MemberAddResponse| { &mut m.member },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                    "members",
                    |m: &MemberAddResponse| { &m.members },
                    |m: &mut MemberAddResponse| { &mut m.members },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemberAddResponse>(
                    "MemberAddResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemberAddResponse {
        static mut instance: ::protobuf::lazy::Lazy<MemberAddResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemberAddResponse,
        };
        unsafe {
            instance.get(MemberAddResponse::new)
        }
    }
}

impl ::protobuf::Clear for MemberAddResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.member.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberAddResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberAddResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberRemoveRequest {
    // message fields
    pub ID: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberRemoveRequest {
    fn default() -> &'a MemberRemoveRequest {
        <MemberRemoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemberRemoveRequest {
    pub fn new() -> MemberRemoveRequest {
        ::std::default::Default::default()
    }

    // uint64 ID = 1;


    pub fn get_ID(&self) -> u64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: u64) {
        self.ID = v;
    }
}

impl ::protobuf::Message for MemberRemoveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_uint64(1, self.ID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberRemoveRequest {
        MemberRemoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ID",
                    |m: &MemberRemoveRequest| { &m.ID },
                    |m: &mut MemberRemoveRequest| { &mut m.ID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemberRemoveRequest>(
                    "MemberRemoveRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemberRemoveRequest {
        static mut instance: ::protobuf::lazy::Lazy<MemberRemoveRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemberRemoveRequest,
        };
        unsafe {
            instance.get(MemberRemoveRequest::new)
        }
    }
}

impl ::protobuf::Clear for MemberRemoveRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberRemoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberRemoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberRemoveResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub members: ::protobuf::RepeatedField<Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberRemoveResponse {
    fn default() -> &'a MemberRemoveResponse {
        <MemberRemoveResponse as ::protobuf::Message>::default_instance()
    }
}

impl MemberRemoveResponse {
    pub fn new() -> MemberRemoveResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .etcdserverpb.Member members = 2;


    pub fn get_members(&self) -> &[Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberRemoveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberRemoveResponse {
        MemberRemoveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &MemberRemoveResponse| { &m.header },
                    |m: &mut MemberRemoveResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                    "members",
                    |m: &MemberRemoveResponse| { &m.members },
                    |m: &mut MemberRemoveResponse| { &mut m.members },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemberRemoveResponse>(
                    "MemberRemoveResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemberRemoveResponse {
        static mut instance: ::protobuf::lazy::Lazy<MemberRemoveResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemberRemoveResponse,
        };
        unsafe {
            instance.get(MemberRemoveResponse::new)
        }
    }
}

impl ::protobuf::Clear for MemberRemoveResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberRemoveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberRemoveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberUpdateRequest {
    // message fields
    pub ID: u64,
    pub peerURLs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberUpdateRequest {
    fn default() -> &'a MemberUpdateRequest {
        <MemberUpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemberUpdateRequest {
    pub fn new() -> MemberUpdateRequest {
        ::std::default::Default::default()
    }

    // uint64 ID = 1;


    pub fn get_ID(&self) -> u64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: u64) {
        self.ID = v;
    }

    // repeated string peerURLs = 2;


    pub fn get_peerURLs(&self) -> &[::std::string::String] {
        &self.peerURLs
    }
    pub fn clear_peerURLs(&mut self) {
        self.peerURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerURLs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerURLs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerURLs
    }

    // Take field
    pub fn take_peerURLs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerURLs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberUpdateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerURLs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.peerURLs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_uint64(1, self.ID)?;
        }
        for v in &self.peerURLs {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberUpdateRequest {
        MemberUpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ID",
                    |m: &MemberUpdateRequest| { &m.ID },
                    |m: &mut MemberUpdateRequest| { &mut m.ID },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerURLs",
                    |m: &MemberUpdateRequest| { &m.peerURLs },
                    |m: &mut MemberUpdateRequest| { &mut m.peerURLs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemberUpdateRequest>(
                    "MemberUpdateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemberUpdateRequest {
        static mut instance: ::protobuf::lazy::Lazy<MemberUpdateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemberUpdateRequest,
        };
        unsafe {
            instance.get(MemberUpdateRequest::new)
        }
    }
}

impl ::protobuf::Clear for MemberUpdateRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.peerURLs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberUpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberUpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberUpdateResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub members: ::protobuf::RepeatedField<Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberUpdateResponse {
    fn default() -> &'a MemberUpdateResponse {
        <MemberUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MemberUpdateResponse {
    pub fn new() -> MemberUpdateResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .etcdserverpb.Member members = 2;


    pub fn get_members(&self) -> &[Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberUpdateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberUpdateResponse {
        MemberUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &MemberUpdateResponse| { &m.header },
                    |m: &mut MemberUpdateResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                    "members",
                    |m: &MemberUpdateResponse| { &m.members },
                    |m: &mut MemberUpdateResponse| { &mut m.members },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemberUpdateResponse>(
                    "MemberUpdateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemberUpdateResponse {
        static mut instance: ::protobuf::lazy::Lazy<MemberUpdateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemberUpdateResponse,
        };
        unsafe {
            instance.get(MemberUpdateResponse::new)
        }
    }
}

impl ::protobuf::Clear for MemberUpdateResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberListRequest {
    fn default() -> &'a MemberListRequest {
        <MemberListRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemberListRequest {
    pub fn new() -> MemberListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MemberListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberListRequest {
        MemberListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MemberListRequest>(
                    "MemberListRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemberListRequest {
        static mut instance: ::protobuf::lazy::Lazy<MemberListRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemberListRequest,
        };
        unsafe {
            instance.get(MemberListRequest::new)
        }
    }
}

impl ::protobuf::Clear for MemberListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberListResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub members: ::protobuf::RepeatedField<Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberListResponse {
    fn default() -> &'a MemberListResponse {
        <MemberListResponse as ::protobuf::Message>::default_instance()
    }
}

impl MemberListResponse {
    pub fn new() -> MemberListResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .etcdserverpb.Member members = 2;


    pub fn get_members(&self) -> &[Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberListResponse {
        MemberListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &MemberListResponse| { &m.header },
                    |m: &mut MemberListResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                    "members",
                    |m: &MemberListResponse| { &m.members },
                    |m: &mut MemberListResponse| { &mut m.members },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MemberListResponse>(
                    "MemberListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MemberListResponse {
        static mut instance: ::protobuf::lazy::Lazy<MemberListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MemberListResponse,
        };
        unsafe {
            instance.get(MemberListResponse::new)
        }
    }
}

impl ::protobuf::Clear for MemberListResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefragmentRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefragmentRequest {
    fn default() -> &'a DefragmentRequest {
        <DefragmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl DefragmentRequest {
    pub fn new() -> DefragmentRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DefragmentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefragmentRequest {
        DefragmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DefragmentRequest>(
                    "DefragmentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefragmentRequest {
        static mut instance: ::protobuf::lazy::Lazy<DefragmentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefragmentRequest,
        };
        unsafe {
            instance.get(DefragmentRequest::new)
        }
    }
}

impl ::protobuf::Clear for DefragmentRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefragmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefragmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefragmentResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefragmentResponse {
    fn default() -> &'a DefragmentResponse {
        <DefragmentResponse as ::protobuf::Message>::default_instance()
    }
}

impl DefragmentResponse {
    pub fn new() -> DefragmentResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for DefragmentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefragmentResponse {
        DefragmentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &DefragmentResponse| { &m.header },
                    |m: &mut DefragmentResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DefragmentResponse>(
                    "DefragmentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefragmentResponse {
        static mut instance: ::protobuf::lazy::Lazy<DefragmentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefragmentResponse,
        };
        unsafe {
            instance.get(DefragmentResponse::new)
        }
    }
}

impl ::protobuf::Clear for DefragmentResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefragmentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefragmentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveLeaderRequest {
    // message fields
    pub targetID: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveLeaderRequest {
    fn default() -> &'a MoveLeaderRequest {
        <MoveLeaderRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoveLeaderRequest {
    pub fn new() -> MoveLeaderRequest {
        ::std::default::Default::default()
    }

    // uint64 targetID = 1;


    pub fn get_targetID(&self) -> u64 {
        self.targetID
    }
    pub fn clear_targetID(&mut self) {
        self.targetID = 0;
    }

    // Param is passed by value, moved
    pub fn set_targetID(&mut self, v: u64) {
        self.targetID = v;
    }
}

impl ::protobuf::Message for MoveLeaderRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.targetID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.targetID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.targetID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.targetID != 0 {
            os.write_uint64(1, self.targetID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveLeaderRequest {
        MoveLeaderRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "targetID",
                    |m: &MoveLeaderRequest| { &m.targetID },
                    |m: &mut MoveLeaderRequest| { &mut m.targetID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoveLeaderRequest>(
                    "MoveLeaderRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoveLeaderRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoveLeaderRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoveLeaderRequest,
        };
        unsafe {
            instance.get(MoveLeaderRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoveLeaderRequest {
    fn clear(&mut self) {
        self.targetID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveLeaderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveLeaderRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveLeaderResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveLeaderResponse {
    fn default() -> &'a MoveLeaderResponse {
        <MoveLeaderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MoveLeaderResponse {
    pub fn new() -> MoveLeaderResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for MoveLeaderResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveLeaderResponse {
        MoveLeaderResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &MoveLeaderResponse| { &m.header },
                    |m: &mut MoveLeaderResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoveLeaderResponse>(
                    "MoveLeaderResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoveLeaderResponse {
        static mut instance: ::protobuf::lazy::Lazy<MoveLeaderResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoveLeaderResponse,
        };
        unsafe {
            instance.get(MoveLeaderResponse::new)
        }
    }
}

impl ::protobuf::Clear for MoveLeaderResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveLeaderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveLeaderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlarmRequest {
    // message fields
    pub action: AlarmRequest_AlarmAction,
    pub memberID: u64,
    pub alarm: AlarmType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlarmRequest {
    fn default() -> &'a AlarmRequest {
        <AlarmRequest as ::protobuf::Message>::default_instance()
    }
}

impl AlarmRequest {
    pub fn new() -> AlarmRequest {
        ::std::default::Default::default()
    }

    // .etcdserverpb.AlarmRequest.AlarmAction action = 1;


    pub fn get_action(&self) -> AlarmRequest_AlarmAction {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = AlarmRequest_AlarmAction::GET;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: AlarmRequest_AlarmAction) {
        self.action = v;
    }

    // uint64 memberID = 2;


    pub fn get_memberID(&self) -> u64 {
        self.memberID
    }
    pub fn clear_memberID(&mut self) {
        self.memberID = 0;
    }

    // Param is passed by value, moved
    pub fn set_memberID(&mut self, v: u64) {
        self.memberID = v;
    }

    // .etcdserverpb.AlarmType alarm = 3;


    pub fn get_alarm(&self) -> AlarmType {
        self.alarm
    }
    pub fn clear_alarm(&mut self) {
        self.alarm = AlarmType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_alarm(&mut self, v: AlarmType) {
        self.alarm = v;
    }
}

impl ::protobuf::Message for AlarmRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.memberID = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.alarm, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action != AlarmRequest_AlarmAction::GET {
            my_size += ::protobuf::rt::enum_size(1, self.action);
        }
        if self.memberID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.memberID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.alarm != AlarmType::NONE {
            my_size += ::protobuf::rt::enum_size(3, self.alarm);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action != AlarmRequest_AlarmAction::GET {
            os.write_enum(1, self.action.value())?;
        }
        if self.memberID != 0 {
            os.write_uint64(2, self.memberID)?;
        }
        if self.alarm != AlarmType::NONE {
            os.write_enum(3, self.alarm.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlarmRequest {
        AlarmRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AlarmRequest_AlarmAction>>(
                    "action",
                    |m: &AlarmRequest| { &m.action },
                    |m: &mut AlarmRequest| { &mut m.action },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "memberID",
                    |m: &AlarmRequest| { &m.memberID },
                    |m: &mut AlarmRequest| { &mut m.memberID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AlarmType>>(
                    "alarm",
                    |m: &AlarmRequest| { &m.alarm },
                    |m: &mut AlarmRequest| { &mut m.alarm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AlarmRequest>(
                    "AlarmRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AlarmRequest {
        static mut instance: ::protobuf::lazy::Lazy<AlarmRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AlarmRequest,
        };
        unsafe {
            instance.get(AlarmRequest::new)
        }
    }
}

impl ::protobuf::Clear for AlarmRequest {
    fn clear(&mut self) {
        self.action = AlarmRequest_AlarmAction::GET;
        self.memberID = 0;
        self.alarm = AlarmType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlarmRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AlarmRequest_AlarmAction {
    GET = 0,
    ACTIVATE = 1,
    DEACTIVATE = 2,
}

impl ::protobuf::ProtobufEnum for AlarmRequest_AlarmAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlarmRequest_AlarmAction> {
        match value {
            0 => ::std::option::Option::Some(AlarmRequest_AlarmAction::GET),
            1 => ::std::option::Option::Some(AlarmRequest_AlarmAction::ACTIVATE),
            2 => ::std::option::Option::Some(AlarmRequest_AlarmAction::DEACTIVATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AlarmRequest_AlarmAction] = &[
            AlarmRequest_AlarmAction::GET,
            AlarmRequest_AlarmAction::ACTIVATE,
            AlarmRequest_AlarmAction::DEACTIVATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AlarmRequest_AlarmAction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AlarmRequest_AlarmAction {
}

impl ::std::default::Default for AlarmRequest_AlarmAction {
    fn default() -> Self {
        AlarmRequest_AlarmAction::GET
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmRequest_AlarmAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlarmMember {
    // message fields
    pub memberID: u64,
    pub alarm: AlarmType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlarmMember {
    fn default() -> &'a AlarmMember {
        <AlarmMember as ::protobuf::Message>::default_instance()
    }
}

impl AlarmMember {
    pub fn new() -> AlarmMember {
        ::std::default::Default::default()
    }

    // uint64 memberID = 1;


    pub fn get_memberID(&self) -> u64 {
        self.memberID
    }
    pub fn clear_memberID(&mut self) {
        self.memberID = 0;
    }

    // Param is passed by value, moved
    pub fn set_memberID(&mut self, v: u64) {
        self.memberID = v;
    }

    // .etcdserverpb.AlarmType alarm = 2;


    pub fn get_alarm(&self) -> AlarmType {
        self.alarm
    }
    pub fn clear_alarm(&mut self) {
        self.alarm = AlarmType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_alarm(&mut self, v: AlarmType) {
        self.alarm = v;
    }
}

impl ::protobuf::Message for AlarmMember {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.memberID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.alarm, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.memberID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.memberID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.alarm != AlarmType::NONE {
            my_size += ::protobuf::rt::enum_size(2, self.alarm);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.memberID != 0 {
            os.write_uint64(1, self.memberID)?;
        }
        if self.alarm != AlarmType::NONE {
            os.write_enum(2, self.alarm.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlarmMember {
        AlarmMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "memberID",
                    |m: &AlarmMember| { &m.memberID },
                    |m: &mut AlarmMember| { &mut m.memberID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AlarmType>>(
                    "alarm",
                    |m: &AlarmMember| { &m.alarm },
                    |m: &mut AlarmMember| { &mut m.alarm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AlarmMember>(
                    "AlarmMember",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AlarmMember {
        static mut instance: ::protobuf::lazy::Lazy<AlarmMember> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AlarmMember,
        };
        unsafe {
            instance.get(AlarmMember::new)
        }
    }
}

impl ::protobuf::Clear for AlarmMember {
    fn clear(&mut self) {
        self.memberID = 0;
        self.alarm = AlarmType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlarmMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmMember {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlarmResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub alarms: ::protobuf::RepeatedField<AlarmMember>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlarmResponse {
    fn default() -> &'a AlarmResponse {
        <AlarmResponse as ::protobuf::Message>::default_instance()
    }
}

impl AlarmResponse {
    pub fn new() -> AlarmResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .etcdserverpb.AlarmMember alarms = 2;


    pub fn get_alarms(&self) -> &[AlarmMember] {
        &self.alarms
    }
    pub fn clear_alarms(&mut self) {
        self.alarms.clear();
    }

    // Param is passed by value, moved
    pub fn set_alarms(&mut self, v: ::protobuf::RepeatedField<AlarmMember>) {
        self.alarms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alarms(&mut self) -> &mut ::protobuf::RepeatedField<AlarmMember> {
        &mut self.alarms
    }

    // Take field
    pub fn take_alarms(&mut self) -> ::protobuf::RepeatedField<AlarmMember> {
        ::std::mem::replace(&mut self.alarms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AlarmResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alarms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.alarms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.alarms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.alarms {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlarmResponse {
        AlarmResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AlarmResponse| { &m.header },
                    |m: &mut AlarmResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlarmMember>>(
                    "alarms",
                    |m: &AlarmResponse| { &m.alarms },
                    |m: &mut AlarmResponse| { &mut m.alarms },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AlarmResponse>(
                    "AlarmResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AlarmResponse {
        static mut instance: ::protobuf::lazy::Lazy<AlarmResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AlarmResponse,
        };
        unsafe {
            instance.get(AlarmResponse::new)
        }
    }
}

impl ::protobuf::Clear for AlarmResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.alarms.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlarmResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusRequest {
    fn default() -> &'a StatusRequest {
        <StatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatusRequest {
    pub fn new() -> StatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusRequest {
        StatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StatusRequest>(
                    "StatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<StatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusRequest,
        };
        unsafe {
            instance.get(StatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for StatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub version: ::std::string::String,
    pub dbSize: i64,
    pub leader: u64,
    pub raftIndex: u64,
    pub raftTerm: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusResponse {
    fn default() -> &'a StatusResponse {
        <StatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatusResponse {
    pub fn new() -> StatusResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // int64 dbSize = 3;


    pub fn get_dbSize(&self) -> i64 {
        self.dbSize
    }
    pub fn clear_dbSize(&mut self) {
        self.dbSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_dbSize(&mut self, v: i64) {
        self.dbSize = v;
    }

    // uint64 leader = 4;


    pub fn get_leader(&self) -> u64 {
        self.leader
    }
    pub fn clear_leader(&mut self) {
        self.leader = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader(&mut self, v: u64) {
        self.leader = v;
    }

    // uint64 raftIndex = 5;


    pub fn get_raftIndex(&self) -> u64 {
        self.raftIndex
    }
    pub fn clear_raftIndex(&mut self) {
        self.raftIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_raftIndex(&mut self, v: u64) {
        self.raftIndex = v;
    }

    // uint64 raftTerm = 6;


    pub fn get_raftTerm(&self) -> u64 {
        self.raftTerm
    }
    pub fn clear_raftTerm(&mut self) {
        self.raftTerm = 0;
    }

    // Param is passed by value, moved
    pub fn set_raftTerm(&mut self, v: u64) {
        self.raftTerm = v;
    }
}

impl ::protobuf::Message for StatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dbSize = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.leader = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.raftIndex = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.raftTerm = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if self.dbSize != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dbSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.leader != 0 {
            my_size += ::protobuf::rt::value_size(4, self.leader, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.raftIndex != 0 {
            my_size += ::protobuf::rt::value_size(5, self.raftIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.raftTerm != 0 {
            my_size += ::protobuf::rt::value_size(6, self.raftTerm, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if self.dbSize != 0 {
            os.write_int64(3, self.dbSize)?;
        }
        if self.leader != 0 {
            os.write_uint64(4, self.leader)?;
        }
        if self.raftIndex != 0 {
            os.write_uint64(5, self.raftIndex)?;
        }
        if self.raftTerm != 0 {
            os.write_uint64(6, self.raftTerm)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusResponse {
        StatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &StatusResponse| { &m.header },
                    |m: &mut StatusResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &StatusResponse| { &m.version },
                    |m: &mut StatusResponse| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dbSize",
                    |m: &StatusResponse| { &m.dbSize },
                    |m: &mut StatusResponse| { &mut m.dbSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "leader",
                    |m: &StatusResponse| { &m.leader },
                    |m: &mut StatusResponse| { &mut m.leader },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "raftIndex",
                    |m: &StatusResponse| { &m.raftIndex },
                    |m: &mut StatusResponse| { &mut m.raftIndex },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "raftTerm",
                    |m: &StatusResponse| { &m.raftTerm },
                    |m: &mut StatusResponse| { &mut m.raftTerm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusResponse>(
                    "StatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<StatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusResponse,
        };
        unsafe {
            instance.get(StatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for StatusResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.version.clear();
        self.dbSize = 0;
        self.leader = 0;
        self.raftIndex = 0;
        self.raftTerm = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthEnableRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthEnableRequest {
    fn default() -> &'a AuthEnableRequest {
        <AuthEnableRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthEnableRequest {
    pub fn new() -> AuthEnableRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthEnableRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthEnableRequest {
        AuthEnableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AuthEnableRequest>(
                    "AuthEnableRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthEnableRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthEnableRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthEnableRequest,
        };
        unsafe {
            instance.get(AuthEnableRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthEnableRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthEnableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthEnableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthDisableRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthDisableRequest {
    fn default() -> &'a AuthDisableRequest {
        <AuthDisableRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthDisableRequest {
    pub fn new() -> AuthDisableRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthDisableRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthDisableRequest {
        AuthDisableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AuthDisableRequest>(
                    "AuthDisableRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthDisableRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthDisableRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthDisableRequest,
        };
        unsafe {
            instance.get(AuthDisableRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthDisableRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthDisableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthDisableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateRequest {
    // message fields
    pub name: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticateRequest {
    fn default() -> &'a AuthenticateRequest {
        <AuthenticateRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateRequest {
    pub fn new() -> AuthenticateRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthenticateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateRequest {
        AuthenticateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AuthenticateRequest| { &m.name },
                    |m: &mut AuthenticateRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &AuthenticateRequest| { &m.password },
                    |m: &mut AuthenticateRequest| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthenticateRequest>(
                    "AuthenticateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthenticateRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthenticateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthenticateRequest,
        };
        unsafe {
            instance.get(AuthenticateRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthenticateRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserAddRequest {
    // message fields
    pub name: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserAddRequest {
    fn default() -> &'a AuthUserAddRequest {
        <AuthUserAddRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserAddRequest {
    pub fn new() -> AuthUserAddRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserAddRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserAddRequest {
        AuthUserAddRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AuthUserAddRequest| { &m.name },
                    |m: &mut AuthUserAddRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &AuthUserAddRequest| { &m.password },
                    |m: &mut AuthUserAddRequest| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserAddRequest>(
                    "AuthUserAddRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserAddRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserAddRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserAddRequest,
        };
        unsafe {
            instance.get(AuthUserAddRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserAddRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserAddRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserAddRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserGetRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserGetRequest {
    fn default() -> &'a AuthUserGetRequest {
        <AuthUserGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserGetRequest {
    pub fn new() -> AuthUserGetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserGetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserGetRequest {
        AuthUserGetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AuthUserGetRequest| { &m.name },
                    |m: &mut AuthUserGetRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserGetRequest>(
                    "AuthUserGetRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserGetRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserGetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserGetRequest,
        };
        unsafe {
            instance.get(AuthUserGetRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserGetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserGetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserGetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserDeleteRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserDeleteRequest {
    fn default() -> &'a AuthUserDeleteRequest {
        <AuthUserDeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserDeleteRequest {
    pub fn new() -> AuthUserDeleteRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserDeleteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserDeleteRequest {
        AuthUserDeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AuthUserDeleteRequest| { &m.name },
                    |m: &mut AuthUserDeleteRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserDeleteRequest>(
                    "AuthUserDeleteRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserDeleteRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserDeleteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserDeleteRequest,
        };
        unsafe {
            instance.get(AuthUserDeleteRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserDeleteRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserDeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserDeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserChangePasswordRequest {
    // message fields
    pub name: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserChangePasswordRequest {
    fn default() -> &'a AuthUserChangePasswordRequest {
        <AuthUserChangePasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserChangePasswordRequest {
    pub fn new() -> AuthUserChangePasswordRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserChangePasswordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserChangePasswordRequest {
        AuthUserChangePasswordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AuthUserChangePasswordRequest| { &m.name },
                    |m: &mut AuthUserChangePasswordRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &AuthUserChangePasswordRequest| { &m.password },
                    |m: &mut AuthUserChangePasswordRequest| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserChangePasswordRequest>(
                    "AuthUserChangePasswordRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserChangePasswordRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserChangePasswordRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserChangePasswordRequest,
        };
        unsafe {
            instance.get(AuthUserChangePasswordRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserChangePasswordRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserChangePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserChangePasswordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserGrantRoleRequest {
    // message fields
    pub user: ::std::string::String,
    pub role: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserGrantRoleRequest {
    fn default() -> &'a AuthUserGrantRoleRequest {
        <AuthUserGrantRoleRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserGrantRoleRequest {
    pub fn new() -> AuthUserGrantRoleRequest {
        ::std::default::Default::default()
    }

    // string user = 1;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }

    // string role = 2;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserGrantRoleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user);
        }
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.user.is_empty() {
            os.write_string(1, &self.user)?;
        }
        if !self.role.is_empty() {
            os.write_string(2, &self.role)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserGrantRoleRequest {
        AuthUserGrantRoleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    |m: &AuthUserGrantRoleRequest| { &m.user },
                    |m: &mut AuthUserGrantRoleRequest| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    |m: &AuthUserGrantRoleRequest| { &m.role },
                    |m: &mut AuthUserGrantRoleRequest| { &mut m.role },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserGrantRoleRequest>(
                    "AuthUserGrantRoleRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserGrantRoleRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserGrantRoleRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserGrantRoleRequest,
        };
        unsafe {
            instance.get(AuthUserGrantRoleRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserGrantRoleRequest {
    fn clear(&mut self) {
        self.user.clear();
        self.role.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserGrantRoleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserGrantRoleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserRevokeRoleRequest {
    // message fields
    pub name: ::std::string::String,
    pub role: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserRevokeRoleRequest {
    fn default() -> &'a AuthUserRevokeRoleRequest {
        <AuthUserRevokeRoleRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserRevokeRoleRequest {
    pub fn new() -> AuthUserRevokeRoleRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string role = 2;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserRevokeRoleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.role.is_empty() {
            os.write_string(2, &self.role)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserRevokeRoleRequest {
        AuthUserRevokeRoleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AuthUserRevokeRoleRequest| { &m.name },
                    |m: &mut AuthUserRevokeRoleRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    |m: &AuthUserRevokeRoleRequest| { &m.role },
                    |m: &mut AuthUserRevokeRoleRequest| { &mut m.role },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserRevokeRoleRequest>(
                    "AuthUserRevokeRoleRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserRevokeRoleRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserRevokeRoleRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserRevokeRoleRequest,
        };
        unsafe {
            instance.get(AuthUserRevokeRoleRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserRevokeRoleRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.role.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserRevokeRoleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserRevokeRoleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleAddRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleAddRequest {
    fn default() -> &'a AuthRoleAddRequest {
        <AuthRoleAddRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleAddRequest {
    pub fn new() -> AuthRoleAddRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRoleAddRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleAddRequest {
        AuthRoleAddRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AuthRoleAddRequest| { &m.name },
                    |m: &mut AuthRoleAddRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleAddRequest>(
                    "AuthRoleAddRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleAddRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleAddRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleAddRequest,
        };
        unsafe {
            instance.get(AuthRoleAddRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleAddRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleAddRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleAddRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleGetRequest {
    // message fields
    pub role: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleGetRequest {
    fn default() -> &'a AuthRoleGetRequest {
        <AuthRoleGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleGetRequest {
    pub fn new() -> AuthRoleGetRequest {
        ::std::default::Default::default()
    }

    // string role = 1;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRoleGetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.role.is_empty() {
            os.write_string(1, &self.role)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleGetRequest {
        AuthRoleGetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    |m: &AuthRoleGetRequest| { &m.role },
                    |m: &mut AuthRoleGetRequest| { &mut m.role },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleGetRequest>(
                    "AuthRoleGetRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleGetRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleGetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleGetRequest,
        };
        unsafe {
            instance.get(AuthRoleGetRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleGetRequest {
    fn clear(&mut self) {
        self.role.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleGetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleGetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserListRequest {
    fn default() -> &'a AuthUserListRequest {
        <AuthUserListRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserListRequest {
    pub fn new() -> AuthUserListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthUserListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserListRequest {
        AuthUserListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserListRequest>(
                    "AuthUserListRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserListRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserListRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserListRequest,
        };
        unsafe {
            instance.get(AuthUserListRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleListRequest {
    fn default() -> &'a AuthRoleListRequest {
        <AuthRoleListRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleListRequest {
    pub fn new() -> AuthRoleListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthRoleListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleListRequest {
        AuthRoleListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleListRequest>(
                    "AuthRoleListRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleListRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleListRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleListRequest,
        };
        unsafe {
            instance.get(AuthRoleListRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleDeleteRequest {
    // message fields
    pub role: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleDeleteRequest {
    fn default() -> &'a AuthRoleDeleteRequest {
        <AuthRoleDeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleDeleteRequest {
    pub fn new() -> AuthRoleDeleteRequest {
        ::std::default::Default::default()
    }

    // string role = 1;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRoleDeleteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.role.is_empty() {
            os.write_string(1, &self.role)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleDeleteRequest {
        AuthRoleDeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    |m: &AuthRoleDeleteRequest| { &m.role },
                    |m: &mut AuthRoleDeleteRequest| { &mut m.role },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleDeleteRequest>(
                    "AuthRoleDeleteRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleDeleteRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleDeleteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleDeleteRequest,
        };
        unsafe {
            instance.get(AuthRoleDeleteRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleDeleteRequest {
    fn clear(&mut self) {
        self.role.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleDeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleDeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleGrantPermissionRequest {
    // message fields
    pub name: ::std::string::String,
    pub perm: ::protobuf::SingularPtrField<super::auth::Permission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleGrantPermissionRequest {
    fn default() -> &'a AuthRoleGrantPermissionRequest {
        <AuthRoleGrantPermissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleGrantPermissionRequest {
    pub fn new() -> AuthRoleGrantPermissionRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .authpb.Permission perm = 2;


    pub fn get_perm(&self) -> &super::auth::Permission {
        self.perm.as_ref().unwrap_or_else(|| super::auth::Permission::default_instance())
    }
    pub fn clear_perm(&mut self) {
        self.perm.clear();
    }

    pub fn has_perm(&self) -> bool {
        self.perm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: super::auth::Permission) {
        self.perm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_perm(&mut self) -> &mut super::auth::Permission {
        if self.perm.is_none() {
            self.perm.set_default();
        }
        self.perm.as_mut().unwrap()
    }

    // Take field
    pub fn take_perm(&mut self) -> super::auth::Permission {
        self.perm.take().unwrap_or_else(|| super::auth::Permission::new())
    }
}

impl ::protobuf::Message for AuthRoleGrantPermissionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.perm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.perm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.perm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.perm.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleGrantPermissionRequest {
        AuthRoleGrantPermissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &AuthRoleGrantPermissionRequest| { &m.name },
                    |m: &mut AuthRoleGrantPermissionRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::auth::Permission>>(
                    "perm",
                    |m: &AuthRoleGrantPermissionRequest| { &m.perm },
                    |m: &mut AuthRoleGrantPermissionRequest| { &mut m.perm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleGrantPermissionRequest>(
                    "AuthRoleGrantPermissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleGrantPermissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleGrantPermissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleGrantPermissionRequest,
        };
        unsafe {
            instance.get(AuthRoleGrantPermissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleGrantPermissionRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.perm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleGrantPermissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleGrantPermissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleRevokePermissionRequest {
    // message fields
    pub role: ::std::string::String,
    pub key: ::std::string::String,
    pub range_end: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleRevokePermissionRequest {
    fn default() -> &'a AuthRoleRevokePermissionRequest {
        <AuthRoleRevokePermissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleRevokePermissionRequest {
    pub fn new() -> AuthRoleRevokePermissionRequest {
        ::std::default::Default::default()
    }

    // string role = 1;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }

    // string key = 2;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string range_end = 3;


    pub fn get_range_end(&self) -> &str {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::string::String) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::string::String {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.range_end, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRoleRevokePermissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.range_end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.role);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.range_end);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.role.is_empty() {
            os.write_string(1, &self.role)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_string(3, &self.range_end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleRevokePermissionRequest {
        AuthRoleRevokePermissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    |m: &AuthRoleRevokePermissionRequest| { &m.role },
                    |m: &mut AuthRoleRevokePermissionRequest| { &mut m.role },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &AuthRoleRevokePermissionRequest| { &m.key },
                    |m: &mut AuthRoleRevokePermissionRequest| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "range_end",
                    |m: &AuthRoleRevokePermissionRequest| { &m.range_end },
                    |m: &mut AuthRoleRevokePermissionRequest| { &mut m.range_end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleRevokePermissionRequest>(
                    "AuthRoleRevokePermissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleRevokePermissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleRevokePermissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleRevokePermissionRequest,
        };
        unsafe {
            instance.get(AuthRoleRevokePermissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleRevokePermissionRequest {
    fn clear(&mut self) {
        self.role.clear();
        self.key.clear();
        self.range_end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleRevokePermissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleRevokePermissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthEnableResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthEnableResponse {
    fn default() -> &'a AuthEnableResponse {
        <AuthEnableResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthEnableResponse {
    pub fn new() -> AuthEnableResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthEnableResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthEnableResponse {
        AuthEnableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthEnableResponse| { &m.header },
                    |m: &mut AuthEnableResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthEnableResponse>(
                    "AuthEnableResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthEnableResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthEnableResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthEnableResponse,
        };
        unsafe {
            instance.get(AuthEnableResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthEnableResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthEnableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthEnableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthDisableResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthDisableResponse {
    fn default() -> &'a AuthDisableResponse {
        <AuthDisableResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthDisableResponse {
    pub fn new() -> AuthDisableResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthDisableResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthDisableResponse {
        AuthDisableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthDisableResponse| { &m.header },
                    |m: &mut AuthDisableResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthDisableResponse>(
                    "AuthDisableResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthDisableResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthDisableResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthDisableResponse,
        };
        unsafe {
            instance.get(AuthDisableResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthDisableResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthDisableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthDisableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticateResponse {
    fn default() -> &'a AuthenticateResponse {
        <AuthenticateResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateResponse {
    pub fn new() -> AuthenticateResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // string token = 2;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthenticateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.token.is_empty() {
            os.write_string(2, &self.token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateResponse {
        AuthenticateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthenticateResponse| { &m.header },
                    |m: &mut AuthenticateResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "token",
                    |m: &AuthenticateResponse| { &m.token },
                    |m: &mut AuthenticateResponse| { &mut m.token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthenticateResponse>(
                    "AuthenticateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthenticateResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthenticateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthenticateResponse,
        };
        unsafe {
            instance.get(AuthenticateResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthenticateResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserAddResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserAddResponse {
    fn default() -> &'a AuthUserAddResponse {
        <AuthUserAddResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserAddResponse {
    pub fn new() -> AuthUserAddResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserAddResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserAddResponse {
        AuthUserAddResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthUserAddResponse| { &m.header },
                    |m: &mut AuthUserAddResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserAddResponse>(
                    "AuthUserAddResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserAddResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserAddResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserAddResponse,
        };
        unsafe {
            instance.get(AuthUserAddResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserAddResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserAddResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserAddResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserGetResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub roles: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserGetResponse {
    fn default() -> &'a AuthUserGetResponse {
        <AuthUserGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserGetResponse {
    pub fn new() -> AuthUserGetResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated string roles = 2;


    pub fn get_roles(&self) -> &[::std::string::String] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthUserGetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.roles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.roles {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.roles {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserGetResponse {
        AuthUserGetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthUserGetResponse| { &m.header },
                    |m: &mut AuthUserGetResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "roles",
                    |m: &AuthUserGetResponse| { &m.roles },
                    |m: &mut AuthUserGetResponse| { &mut m.roles },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserGetResponse>(
                    "AuthUserGetResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserGetResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserGetResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserGetResponse,
        };
        unsafe {
            instance.get(AuthUserGetResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserGetResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.roles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserGetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserGetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserDeleteResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserDeleteResponse {
    fn default() -> &'a AuthUserDeleteResponse {
        <AuthUserDeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserDeleteResponse {
    pub fn new() -> AuthUserDeleteResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserDeleteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserDeleteResponse {
        AuthUserDeleteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthUserDeleteResponse| { &m.header },
                    |m: &mut AuthUserDeleteResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserDeleteResponse>(
                    "AuthUserDeleteResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserDeleteResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserDeleteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserDeleteResponse,
        };
        unsafe {
            instance.get(AuthUserDeleteResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserDeleteResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserDeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserDeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserChangePasswordResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserChangePasswordResponse {
    fn default() -> &'a AuthUserChangePasswordResponse {
        <AuthUserChangePasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserChangePasswordResponse {
    pub fn new() -> AuthUserChangePasswordResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserChangePasswordResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserChangePasswordResponse {
        AuthUserChangePasswordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthUserChangePasswordResponse| { &m.header },
                    |m: &mut AuthUserChangePasswordResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserChangePasswordResponse>(
                    "AuthUserChangePasswordResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserChangePasswordResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserChangePasswordResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserChangePasswordResponse,
        };
        unsafe {
            instance.get(AuthUserChangePasswordResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserChangePasswordResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserChangePasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserChangePasswordResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserGrantRoleResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserGrantRoleResponse {
    fn default() -> &'a AuthUserGrantRoleResponse {
        <AuthUserGrantRoleResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserGrantRoleResponse {
    pub fn new() -> AuthUserGrantRoleResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserGrantRoleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserGrantRoleResponse {
        AuthUserGrantRoleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthUserGrantRoleResponse| { &m.header },
                    |m: &mut AuthUserGrantRoleResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserGrantRoleResponse>(
                    "AuthUserGrantRoleResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserGrantRoleResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserGrantRoleResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserGrantRoleResponse,
        };
        unsafe {
            instance.get(AuthUserGrantRoleResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserGrantRoleResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserGrantRoleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserGrantRoleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserRevokeRoleResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserRevokeRoleResponse {
    fn default() -> &'a AuthUserRevokeRoleResponse {
        <AuthUserRevokeRoleResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserRevokeRoleResponse {
    pub fn new() -> AuthUserRevokeRoleResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserRevokeRoleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserRevokeRoleResponse {
        AuthUserRevokeRoleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthUserRevokeRoleResponse| { &m.header },
                    |m: &mut AuthUserRevokeRoleResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserRevokeRoleResponse>(
                    "AuthUserRevokeRoleResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserRevokeRoleResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserRevokeRoleResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserRevokeRoleResponse,
        };
        unsafe {
            instance.get(AuthUserRevokeRoleResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserRevokeRoleResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserRevokeRoleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserRevokeRoleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleAddResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleAddResponse {
    fn default() -> &'a AuthRoleAddResponse {
        <AuthRoleAddResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleAddResponse {
    pub fn new() -> AuthRoleAddResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthRoleAddResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleAddResponse {
        AuthRoleAddResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthRoleAddResponse| { &m.header },
                    |m: &mut AuthRoleAddResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleAddResponse>(
                    "AuthRoleAddResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleAddResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleAddResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleAddResponse,
        };
        unsafe {
            instance.get(AuthRoleAddResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleAddResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleAddResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleAddResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleGetResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub perm: ::protobuf::RepeatedField<super::auth::Permission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleGetResponse {
    fn default() -> &'a AuthRoleGetResponse {
        <AuthRoleGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleGetResponse {
    pub fn new() -> AuthRoleGetResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .authpb.Permission perm = 2;


    pub fn get_perm(&self) -> &[super::auth::Permission] {
        &self.perm
    }
    pub fn clear_perm(&mut self) {
        self.perm.clear();
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: ::protobuf::RepeatedField<super::auth::Permission>) {
        self.perm = v;
    }

    // Mutable pointer to the field.
    pub fn mut_perm(&mut self) -> &mut ::protobuf::RepeatedField<super::auth::Permission> {
        &mut self.perm
    }

    // Take field
    pub fn take_perm(&mut self) -> ::protobuf::RepeatedField<super::auth::Permission> {
        ::std::mem::replace(&mut self.perm, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthRoleGetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.perm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.perm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.perm {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.perm {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleGetResponse {
        AuthRoleGetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthRoleGetResponse| { &m.header },
                    |m: &mut AuthRoleGetResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::auth::Permission>>(
                    "perm",
                    |m: &AuthRoleGetResponse| { &m.perm },
                    |m: &mut AuthRoleGetResponse| { &mut m.perm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleGetResponse>(
                    "AuthRoleGetResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleGetResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleGetResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleGetResponse,
        };
        unsafe {
            instance.get(AuthRoleGetResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleGetResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.perm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleGetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleGetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleListResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub roles: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleListResponse {
    fn default() -> &'a AuthRoleListResponse {
        <AuthRoleListResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleListResponse {
    pub fn new() -> AuthRoleListResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated string roles = 2;


    pub fn get_roles(&self) -> &[::std::string::String] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthRoleListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.roles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.roles {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.roles {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleListResponse {
        AuthRoleListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthRoleListResponse| { &m.header },
                    |m: &mut AuthRoleListResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "roles",
                    |m: &AuthRoleListResponse| { &m.roles },
                    |m: &mut AuthRoleListResponse| { &mut m.roles },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleListResponse>(
                    "AuthRoleListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleListResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleListResponse,
        };
        unsafe {
            instance.get(AuthRoleListResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleListResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.roles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserListResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub users: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserListResponse {
    fn default() -> &'a AuthUserListResponse {
        <AuthUserListResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserListResponse {
    pub fn new() -> AuthUserListResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated string users = 2;


    pub fn get_users(&self) -> &[::std::string::String] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthUserListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.users {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.users {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserListResponse {
        AuthUserListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthUserListResponse| { &m.header },
                    |m: &mut AuthUserListResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "users",
                    |m: &AuthUserListResponse| { &m.users },
                    |m: &mut AuthUserListResponse| { &mut m.users },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthUserListResponse>(
                    "AuthUserListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthUserListResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthUserListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthUserListResponse,
        };
        unsafe {
            instance.get(AuthUserListResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthUserListResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleDeleteResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleDeleteResponse {
    fn default() -> &'a AuthRoleDeleteResponse {
        <AuthRoleDeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleDeleteResponse {
    pub fn new() -> AuthRoleDeleteResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthRoleDeleteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleDeleteResponse {
        AuthRoleDeleteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthRoleDeleteResponse| { &m.header },
                    |m: &mut AuthRoleDeleteResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleDeleteResponse>(
                    "AuthRoleDeleteResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleDeleteResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleDeleteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleDeleteResponse,
        };
        unsafe {
            instance.get(AuthRoleDeleteResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleDeleteResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleDeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleDeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleGrantPermissionResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleGrantPermissionResponse {
    fn default() -> &'a AuthRoleGrantPermissionResponse {
        <AuthRoleGrantPermissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleGrantPermissionResponse {
    pub fn new() -> AuthRoleGrantPermissionResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthRoleGrantPermissionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleGrantPermissionResponse {
        AuthRoleGrantPermissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthRoleGrantPermissionResponse| { &m.header },
                    |m: &mut AuthRoleGrantPermissionResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleGrantPermissionResponse>(
                    "AuthRoleGrantPermissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleGrantPermissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleGrantPermissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleGrantPermissionResponse,
        };
        unsafe {
            instance.get(AuthRoleGrantPermissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleGrantPermissionResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleGrantPermissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleGrantPermissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleRevokePermissionResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleRevokePermissionResponse {
    fn default() -> &'a AuthRoleRevokePermissionResponse {
        <AuthRoleRevokePermissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleRevokePermissionResponse {
    pub fn new() -> AuthRoleRevokePermissionResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| ResponseHeader::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthRoleRevokePermissionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleRevokePermissionResponse {
        AuthRoleRevokePermissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                    "header",
                    |m: &AuthRoleRevokePermissionResponse| { &m.header },
                    |m: &mut AuthRoleRevokePermissionResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthRoleRevokePermissionResponse>(
                    "AuthRoleRevokePermissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthRoleRevokePermissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<AuthRoleRevokePermissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthRoleRevokePermissionResponse,
        };
        unsafe {
            instance.get(AuthRoleRevokePermissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for AuthRoleRevokePermissionResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleRevokePermissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleRevokePermissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AlarmType {
    NONE = 0,
    NOSPACE = 1,
}

impl ::protobuf::ProtobufEnum for AlarmType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlarmType> {
        match value {
            0 => ::std::option::Option::Some(AlarmType::NONE),
            1 => ::std::option::Option::Some(AlarmType::NOSPACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AlarmType] = &[
            AlarmType::NONE,
            AlarmType::NOSPACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AlarmType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AlarmType {
}

impl ::std::default::Default for AlarmType {
    fn default() -> Self {
        AlarmType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\trpc.proto\x12\x0cetcdserverpb\x1a\x08kv.proto\x1a\nauth.proto\"\x85\
    \x01\n\x0eResponseHeader\x12\x1d\n\ncluster_id\x18\x01\x20\x01(\x04R\tcl\
    usterId\x12\x1b\n\tmember_id\x18\x02\x20\x01(\x04R\x08memberId\x12\x1a\n\
    \x08revision\x18\x03\x20\x01(\x03R\x08revision\x12\x1b\n\traft_term\x18\
    \x04\x20\x01(\x04R\x08raftTerm\"\x84\x05\n\x0cRangeRequest\x12\x10\n\x03\
    key\x18\x01\x20\x01(\x0cR\x03key\x12\x1b\n\trange_end\x18\x02\x20\x01(\
    \x0cR\x08rangeEnd\x12\x14\n\x05limit\x18\x03\x20\x01(\x03R\x05limit\x12\
    \x1a\n\x08revision\x18\x04\x20\x01(\x03R\x08revision\x12C\n\nsort_order\
    \x18\x05\x20\x01(\x0e2$.etcdserverpb.RangeRequest.SortOrderR\tsortOrder\
    \x12F\n\x0bsort_target\x18\x06\x20\x01(\x0e2%.etcdserverpb.RangeRequest.\
    SortTargetR\nsortTarget\x12\"\n\x0cserializable\x18\x07\x20\x01(\x08R\
    \x0cserializable\x12\x1b\n\tkeys_only\x18\x08\x20\x01(\x08R\x08keysOnly\
    \x12\x1d\n\ncount_only\x18\t\x20\x01(\x08R\tcountOnly\x12(\n\x10min_mod_\
    revision\x18\n\x20\x01(\x03R\x0eminModRevision\x12(\n\x10max_mod_revisio\
    n\x18\x0b\x20\x01(\x03R\x0emaxModRevision\x12.\n\x13min_create_revision\
    \x18\x0c\x20\x01(\x03R\x11minCreateRevision\x12.\n\x13max_create_revisio\
    n\x18\r\x20\x01(\x03R\x11maxCreateRevision\".\n\tSortOrder\x12\x08\n\x04\
    NONE\x10\0\x12\n\n\x06ASCEND\x10\x01\x12\x0b\n\x07DESCEND\x10\x02\"B\n\n\
    SortTarget\x12\x07\n\x03KEY\x10\0\x12\x0b\n\x07VERSION\x10\x01\x12\n\n\
    \x06CREATE\x10\x02\x12\x07\n\x03MOD\x10\x03\x12\t\n\x05VALUE\x10\x04\"\
    \x93\x01\n\rRangeResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etc\
    dserverpb.ResponseHeaderR\x06header\x12\"\n\x03kvs\x18\x02\x20\x03(\x0b2\
    \x10.mvccpb.KeyValueR\x03kvs\x12\x12\n\x04more\x18\x03\x20\x01(\x08R\x04\
    more\x12\x14\n\x05count\x18\x04\x20\x01(\x03R\x05count\"\xa9\x01\n\nPutR\
    equest\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x0cR\x05value\x12\x14\n\x05lease\x18\x03\x20\x01(\x03R\
    \x05lease\x12\x17\n\x07prev_kv\x18\x04\x20\x01(\x08R\x06prevKv\x12!\n\
    \x0cignore_value\x18\x05\x20\x01(\x08R\x0bignoreValue\x12!\n\x0cignore_l\
    ease\x18\x06\x20\x01(\x08R\x0bignoreLease\"n\n\x0bPutResponse\x124\n\x06\
    header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\
    \x12)\n\x07prev_kv\x18\x02\x20\x01(\x0b2\x10.mvccpb.KeyValueR\x06prevKv\
    \"\\\n\x12DeleteRangeRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03k\
    ey\x12\x1b\n\trange_end\x18\x02\x20\x01(\x0cR\x08rangeEnd\x12\x17\n\x07p\
    rev_kv\x18\x03\x20\x01(\x08R\x06prevKv\"\x92\x01\n\x13DeleteRangeRespons\
    e\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeader\
    R\x06header\x12\x18\n\x07deleted\x18\x02\x20\x01(\x03R\x07deleted\x12+\n\
    \x08prev_kvs\x18\x03\x20\x03(\x0b2\x10.mvccpb.KeyValueR\x07prevKvs\"\xa9\
    \x02\n\tRequestOp\x12A\n\rrequest_range\x18\x01\x20\x01(\x0b2\x1a.etcdse\
    rverpb.RangeRequestH\0R\x0crequestRange\x12;\n\x0brequest_put\x18\x02\
    \x20\x01(\x0b2\x18.etcdserverpb.PutRequestH\0R\nrequestPut\x12T\n\x14req\
    uest_delete_range\x18\x03\x20\x01(\x0b2\x20.etcdserverpb.DeleteRangeRequ\
    estH\0R\x12requestDeleteRange\x12;\n\x0brequest_txn\x18\x04\x20\x01(\x0b\
    2\x18.etcdserverpb.TxnRequestH\0R\nrequestTxnB\t\n\x07request\"\xb7\x02\
    \n\nResponseOp\x12D\n\x0eresponse_range\x18\x01\x20\x01(\x0b2\x1b.etcdse\
    rverpb.RangeResponseH\0R\rresponseRange\x12>\n\x0cresponse_put\x18\x02\
    \x20\x01(\x0b2\x19.etcdserverpb.PutResponseH\0R\x0bresponsePut\x12W\n\
    \x15response_delete_range\x18\x03\x20\x01(\x0b2!.etcdserverpb.DeleteRang\
    eResponseH\0R\x13responseDeleteRange\x12>\n\x0cresponse_txn\x18\x04\x20\
    \x01(\x0b2\x19.etcdserverpb.TxnResponseH\0R\x0bresponseTxnB\n\n\x08respo\
    nse\"\xc6\x03\n\x07Compare\x12;\n\x06result\x18\x01\x20\x01(\x0e2#.etcds\
    erverpb.Compare.CompareResultR\x06result\x12;\n\x06target\x18\x02\x20\
    \x01(\x0e2#.etcdserverpb.Compare.CompareTargetR\x06target\x12\x10\n\x03k\
    ey\x18\x03\x20\x01(\x0cR\x03key\x12\x1a\n\x07version\x18\x04\x20\x01(\
    \x03H\0R\x07version\x12)\n\x0fcreate_revision\x18\x05\x20\x01(\x03H\0R\
    \x0ecreateRevision\x12#\n\x0cmod_revision\x18\x06\x20\x01(\x03H\0R\x0bmo\
    dRevision\x12\x16\n\x05value\x18\x07\x20\x01(\x0cH\0R\x05value\x12\x1b\n\
    \trange_end\x18\x08\x20\x01(\x0cR\x08rangeEnd\"@\n\rCompareResult\x12\t\
    \n\x05EQUAL\x10\0\x12\x0b\n\x07GREATER\x10\x01\x12\x08\n\x04LESS\x10\x02\
    \x12\r\n\tNOT_EQUAL\x10\x03\"<\n\rCompareTarget\x12\x0b\n\x07VERSION\x10\
    \0\x12\n\n\x06CREATE\x10\x01\x12\x07\n\x03MOD\x10\x02\x12\t\n\x05VALUE\
    \x10\x03B\x0e\n\x0ctarget_union\"\xa3\x01\n\nTxnRequest\x12/\n\x07compar\
    e\x18\x01\x20\x03(\x0b2\x15.etcdserverpb.CompareR\x07compare\x121\n\x07s\
    uccess\x18\x02\x20\x03(\x0b2\x17.etcdserverpb.RequestOpR\x07success\x121\
    \n\x07failure\x18\x03\x20\x03(\x0b2\x17.etcdserverpb.RequestOpR\x07failu\
    re\"\x99\x01\n\x0bTxnResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c\
    .etcdserverpb.ResponseHeaderR\x06header\x12\x1c\n\tsucceeded\x18\x02\x20\
    \x01(\x08R\tsucceeded\x126\n\tresponses\x18\x03\x20\x03(\x0b2\x18.etcdse\
    rverpb.ResponseOpR\tresponses\"K\n\x11CompactionRequest\x12\x1a\n\x08rev\
    ision\x18\x01\x20\x01(\x03R\x08revision\x12\x1a\n\x08physical\x18\x02\
    \x20\x01(\x08R\x08physical\"J\n\x12CompactionResponse\x124\n\x06header\
    \x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"\r\n\
    \x0bHashRequest\"X\n\x0cHashResponse\x124\n\x06header\x18\x01\x20\x01(\
    \x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\x12\n\x04hash\x18\
    \x02\x20\x01(\rR\x04hash\"+\n\rHashKVRequest\x12\x1a\n\x08revision\x18\
    \x01\x20\x01(\x03R\x08revision\"\x85\x01\n\x0eHashKVResponse\x124\n\x06h\
    eader\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\
    \x12\x12\n\x04hash\x18\x02\x20\x01(\rR\x04hash\x12)\n\x10compact_revisio\
    n\x18\x03\x20\x01(\x03R\x0fcompactRevision\"\x11\n\x0fSnapshotRequest\"\
    \x85\x01\n\x10SnapshotResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\
    \x1c.etcdserverpb.ResponseHeaderR\x06header\x12'\n\x0fremaining_bytes\
    \x18\x02\x20\x01(\x04R\x0eremainingBytes\x12\x12\n\x04blob\x18\x03\x20\
    \x01(\x0cR\x04blob\"\xb5\x01\n\x0cWatchRequest\x12I\n\x0ecreate_request\
    \x18\x01\x20\x01(\x0b2\x20.etcdserverpb.WatchCreateRequestH\0R\rcreateRe\
    quest\x12I\n\x0ecancel_request\x18\x02\x20\x01(\x0b2\x20.etcdserverpb.Wa\
    tchCancelRequestH\0R\rcancelRequestB\x0f\n\rrequest_union\"\x9a\x02\n\
    \x12WatchCreateRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\
    \x1b\n\trange_end\x18\x02\x20\x01(\x0cR\x08rangeEnd\x12%\n\x0estart_revi\
    sion\x18\x03\x20\x01(\x03R\rstartRevision\x12'\n\x0fprogress_notify\x18\
    \x04\x20\x01(\x08R\x0eprogressNotify\x12E\n\x07filters\x18\x05\x20\x03(\
    \x0e2+.etcdserverpb.WatchCreateRequest.FilterTypeR\x07filters\x12\x17\n\
    \x07prev_kv\x18\x06\x20\x01(\x08R\x06prevKv\"%\n\nFilterType\x12\t\n\x05\
    NOPUT\x10\0\x12\x0c\n\x08NODELETE\x10\x01\"/\n\x12WatchCancelRequest\x12\
    \x19\n\x08watch_id\x18\x01\x20\x01(\x03R\x07watchId\"\x8d\x02\n\rWatchRe\
    sponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseH\
    eaderR\x06header\x12\x19\n\x08watch_id\x18\x02\x20\x01(\x03R\x07watchId\
    \x12\x18\n\x07created\x18\x03\x20\x01(\x08R\x07created\x12\x1a\n\x08canc\
    eled\x18\x04\x20\x01(\x08R\x08canceled\x12)\n\x10compact_revision\x18\
    \x05\x20\x01(\x03R\x0fcompactRevision\x12#\n\rcancel_reason\x18\x06\x20\
    \x01(\tR\x0ccancelReason\x12%\n\x06events\x18\x0b\x20\x03(\x0b2\r.mvccpb\
    .EventR\x06events\"5\n\x11LeaseGrantRequest\x12\x10\n\x03TTL\x18\x01\x20\
    \x01(\x03R\x03TTL\x12\x0e\n\x02ID\x18\x02\x20\x01(\x03R\x02ID\"\x82\x01\
    \n\x12LeaseGrantResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcd\
    serverpb.ResponseHeaderR\x06header\x12\x0e\n\x02ID\x18\x02\x20\x01(\x03R\
    \x02ID\x12\x10\n\x03TTL\x18\x03\x20\x01(\x03R\x03TTL\x12\x14\n\x05error\
    \x18\x04\x20\x01(\tR\x05error\"$\n\x12LeaseRevokeRequest\x12\x0e\n\x02ID\
    \x18\x01\x20\x01(\x03R\x02ID\"K\n\x13LeaseRevokeResponse\x124\n\x06heade\
    r\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"'\n\
    \x15LeaseKeepAliveRequest\x12\x0e\n\x02ID\x18\x01\x20\x01(\x03R\x02ID\"p\
    \n\x16LeaseKeepAliveResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.\
    etcdserverpb.ResponseHeaderR\x06header\x12\x0e\n\x02ID\x18\x02\x20\x01(\
    \x03R\x02ID\x12\x10\n\x03TTL\x18\x03\x20\x01(\x03R\x03TTL\"<\n\x16LeaseT\
    imeToLiveRequest\x12\x0e\n\x02ID\x18\x01\x20\x01(\x03R\x02ID\x12\x12\n\
    \x04keys\x18\x02\x20\x01(\x08R\x04keys\"\xa5\x01\n\x17LeaseTimeToLiveRes\
    ponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHe\
    aderR\x06header\x12\x0e\n\x02ID\x18\x02\x20\x01(\x03R\x02ID\x12\x10\n\
    \x03TTL\x18\x03\x20\x01(\x03R\x03TTL\x12\x1e\n\ngrantedTTL\x18\x04\x20\
    \x01(\x03R\ngrantedTTL\x12\x12\n\x04keys\x18\x05\x20\x03(\x0cR\x04keys\"\
    h\n\x06Member\x12\x0e\n\x02ID\x18\x01\x20\x01(\x04R\x02ID\x12\x12\n\x04n\
    ame\x18\x02\x20\x01(\tR\x04name\x12\x1a\n\x08peerURLs\x18\x03\x20\x03(\t\
    R\x08peerURLs\x12\x1e\n\nclientURLs\x18\x04\x20\x03(\tR\nclientURLs\".\n\
    \x10MemberAddRequest\x12\x1a\n\x08peerURLs\x18\x01\x20\x03(\tR\x08peerUR\
    Ls\"\xa7\x01\n\x11MemberAddResponse\x124\n\x06header\x18\x01\x20\x01(\
    \x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12,\n\x06member\x18\
    \x02\x20\x01(\x0b2\x14.etcdserverpb.MemberR\x06member\x12.\n\x07members\
    \x18\x03\x20\x03(\x0b2\x14.etcdserverpb.MemberR\x07members\"%\n\x13Membe\
    rRemoveRequest\x12\x0e\n\x02ID\x18\x01\x20\x01(\x04R\x02ID\"|\n\x14Membe\
    rRemoveResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.\
    ResponseHeaderR\x06header\x12.\n\x07members\x18\x02\x20\x03(\x0b2\x14.et\
    cdserverpb.MemberR\x07members\"A\n\x13MemberUpdateRequest\x12\x0e\n\x02I\
    D\x18\x01\x20\x01(\x04R\x02ID\x12\x1a\n\x08peerURLs\x18\x02\x20\x03(\tR\
    \x08peerURLs\"|\n\x14MemberUpdateResponse\x124\n\x06header\x18\x01\x20\
    \x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12.\n\x07members\
    \x18\x02\x20\x03(\x0b2\x14.etcdserverpb.MemberR\x07members\"\x13\n\x11Me\
    mberListRequest\"z\n\x12MemberListResponse\x124\n\x06header\x18\x01\x20\
    \x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12.\n\x07members\
    \x18\x02\x20\x03(\x0b2\x14.etcdserverpb.MemberR\x07members\"\x13\n\x11De\
    fragmentRequest\"J\n\x12DefragmentResponse\x124\n\x06header\x18\x01\x20\
    \x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"/\n\x11MoveLeader\
    Request\x12\x1a\n\x08targetID\x18\x01\x20\x01(\x04R\x08targetID\"J\n\x12\
    MoveLeaderResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserver\
    pb.ResponseHeaderR\x06header\"\xcf\x01\n\x0cAlarmRequest\x12>\n\x06actio\
    n\x18\x01\x20\x01(\x0e2&.etcdserverpb.AlarmRequest.AlarmActionR\x06actio\
    n\x12\x1a\n\x08memberID\x18\x02\x20\x01(\x04R\x08memberID\x12-\n\x05alar\
    m\x18\x03\x20\x01(\x0e2\x17.etcdserverpb.AlarmTypeR\x05alarm\"4\n\x0bAla\
    rmAction\x12\x07\n\x03GET\x10\0\x12\x0c\n\x08ACTIVATE\x10\x01\x12\x0e\n\
    \nDEACTIVATE\x10\x02\"X\n\x0bAlarmMember\x12\x1a\n\x08memberID\x18\x01\
    \x20\x01(\x04R\x08memberID\x12-\n\x05alarm\x18\x02\x20\x01(\x0e2\x17.etc\
    dserverpb.AlarmTypeR\x05alarm\"x\n\rAlarmResponse\x124\n\x06header\x18\
    \x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x121\n\x06\
    alarms\x18\x02\x20\x03(\x0b2\x19.etcdserverpb.AlarmMemberR\x06alarms\"\
    \x0f\n\rStatusRequest\"\xca\x01\n\x0eStatusResponse\x124\n\x06header\x18\
    \x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\x18\n\
    \x07version\x18\x02\x20\x01(\tR\x07version\x12\x16\n\x06dbSize\x18\x03\
    \x20\x01(\x03R\x06dbSize\x12\x16\n\x06leader\x18\x04\x20\x01(\x04R\x06le\
    ader\x12\x1c\n\traftIndex\x18\x05\x20\x01(\x04R\traftIndex\x12\x1a\n\x08\
    raftTerm\x18\x06\x20\x01(\x04R\x08raftTerm\"\x13\n\x11AuthEnableRequest\
    \"\x14\n\x12AuthDisableRequest\"E\n\x13AuthenticateRequest\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08password\x18\x02\x20\x01(\
    \tR\x08password\"D\n\x12AuthUserAddRequest\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08password\"\
    (\n\x12AuthUserGetRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \"+\n\x15AuthUserDeleteRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\"O\n\x1dAuthUserChangePasswordRequest\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08password\"\
    B\n\x18AuthUserGrantRoleRequest\x12\x12\n\x04user\x18\x01\x20\x01(\tR\
    \x04user\x12\x12\n\x04role\x18\x02\x20\x01(\tR\x04role\"C\n\x19AuthUserR\
    evokeRoleRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\
    \x04role\x18\x02\x20\x01(\tR\x04role\"(\n\x12AuthRoleAddRequest\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\"(\n\x12AuthRoleGetRequest\x12\
    \x12\n\x04role\x18\x01\x20\x01(\tR\x04role\"\x15\n\x13AuthUserListReques\
    t\"\x15\n\x13AuthRoleListRequest\"+\n\x15AuthRoleDeleteRequest\x12\x12\n\
    \x04role\x18\x01\x20\x01(\tR\x04role\"\\\n\x1eAuthRoleGrantPermissionReq\
    uest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12&\n\x04perm\x18\
    \x02\x20\x01(\x0b2\x12.authpb.PermissionR\x04perm\"d\n\x1fAuthRoleRevoke\
    PermissionRequest\x12\x12\n\x04role\x18\x01\x20\x01(\tR\x04role\x12\x10\
    \n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x1b\n\trange_end\x18\x03\x20\
    \x01(\tR\x08rangeEnd\"J\n\x12AuthEnableResponse\x124\n\x06header\x18\x01\
    \x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"K\n\x13AuthDi\
    sableResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.Re\
    sponseHeaderR\x06header\"b\n\x14AuthenticateResponse\x124\n\x06header\
    \x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\
    \x14\n\x05token\x18\x02\x20\x01(\tR\x05token\"K\n\x13AuthUserAddResponse\
    \x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\
    \x06header\"a\n\x13AuthUserGetResponse\x124\n\x06header\x18\x01\x20\x01(\
    \x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\x14\n\x05roles\x18\
    \x02\x20\x03(\tR\x05roles\"N\n\x16AuthUserDeleteResponse\x124\n\x06heade\
    r\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"V\n\
    \x1eAuthUserChangePasswordResponse\x124\n\x06header\x18\x01\x20\x01(\x0b\
    2\x1c.etcdserverpb.ResponseHeaderR\x06header\"Q\n\x19AuthUserGrantRoleRe\
    sponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseH\
    eaderR\x06header\"R\n\x1aAuthUserRevokeRoleResponse\x124\n\x06header\x18\
    \x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"K\n\x13Au\
    thRoleAddResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverp\
    b.ResponseHeaderR\x06header\"s\n\x13AuthRoleGetResponse\x124\n\x06header\
    \x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12&\n\
    \x04perm\x18\x02\x20\x03(\x0b2\x12.authpb.PermissionR\x04perm\"b\n\x14Au\
    thRoleListResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserver\
    pb.ResponseHeaderR\x06header\x12\x14\n\x05roles\x18\x02\x20\x03(\tR\x05r\
    oles\"b\n\x14AuthUserListResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\
    \x1c.etcdserverpb.ResponseHeaderR\x06header\x12\x14\n\x05users\x18\x02\
    \x20\x03(\tR\x05users\"N\n\x16AuthRoleDeleteResponse\x124\n\x06header\
    \x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"W\n\
    \x1fAuthRoleGrantPermissionResponse\x124\n\x06header\x18\x01\x20\x01(\
    \x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"X\n\x20AuthRoleRevokeP\
    ermissionResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverp\
    b.ResponseHeaderR\x06header*\"\n\tAlarmType\x12\x08\n\x04NONE\x10\0\x12\
    \x0b\n\x07NOSPACE\x10\x012\xea\x02\n\x02KV\x12B\n\x05Range\x12\x1a.etcds\
    erverpb.RangeRequest\x1a\x1b.etcdserverpb.RangeResponse\"\0\x12<\n\x03Pu\
    t\x12\x18.etcdserverpb.PutRequest\x1a\x19.etcdserverpb.PutResponse\"\0\
    \x12T\n\x0bDeleteRange\x12\x20.etcdserverpb.DeleteRangeRequest\x1a!.etcd\
    serverpb.DeleteRangeResponse\"\0\x12<\n\x03Txn\x12\x18.etcdserverpb.TxnR\
    equest\x1a\x19.etcdserverpb.TxnResponse\"\0\x12N\n\x07Compact\x12\x1f.et\
    cdserverpb.CompactionRequest\x1a\x20.etcdserverpb.CompactionResponse\"\0\
    2O\n\x05Watch\x12F\n\x05Watch\x12\x1a.etcdserverpb.WatchRequest\x1a\x1b.\
    etcdserverpb.WatchResponse\"\0(\x010\x012\xf5\x02\n\x05Lease\x12Q\n\nLea\
    seGrant\x12\x1f.etcdserverpb.LeaseGrantRequest\x1a\x20.etcdserverpb.Leas\
    eGrantResponse\"\0\x12T\n\x0bLeaseRevoke\x12\x20.etcdserverpb.LeaseRevok\
    eRequest\x1a!.etcdserverpb.LeaseRevokeResponse\"\0\x12a\n\x0eLeaseKeepAl\
    ive\x12#.etcdserverpb.LeaseKeepAliveRequest\x1a$.etcdserverpb.LeaseKeepA\
    liveResponse\"\0(\x010\x01\x12`\n\x0fLeaseTimeToLive\x12$.etcdserverpb.L\
    easeTimeToLiveRequest\x1a%.etcdserverpb.LeaseTimeToLiveResponse\"\02\xde\
    \x02\n\x07Cluster\x12N\n\tMemberAdd\x12\x1e.etcdserverpb.MemberAddReques\
    t\x1a\x1f.etcdserverpb.MemberAddResponse\"\0\x12W\n\x0cMemberRemove\x12!\
    .etcdserverpb.MemberRemoveRequest\x1a\".etcdserverpb.MemberRemoveRespons\
    e\"\0\x12W\n\x0cMemberUpdate\x12!.etcdserverpb.MemberUpdateRequest\x1a\"\
    .etcdserverpb.MemberUpdateResponse\"\0\x12Q\n\nMemberList\x12\x1f.etcdse\
    rverpb.MemberListRequest\x1a\x20.etcdserverpb.MemberListResponse\"\02\
    \x95\x04\n\x0bMaintenance\x12B\n\x05Alarm\x12\x1a.etcdserverpb.AlarmRequ\
    est\x1a\x1b.etcdserverpb.AlarmResponse\"\0\x12E\n\x06Status\x12\x1b.etcd\
    serverpb.StatusRequest\x1a\x1c.etcdserverpb.StatusResponse\"\0\x12Q\n\nD\
    efragment\x12\x1f.etcdserverpb.DefragmentRequest\x1a\x20.etcdserverpb.De\
    fragmentResponse\"\0\x12?\n\x04Hash\x12\x19.etcdserverpb.HashRequest\x1a\
    \x1a.etcdserverpb.HashResponse\"\0\x12E\n\x06HashKV\x12\x1b.etcdserverpb\
    .HashKVRequest\x1a\x1c.etcdserverpb.HashKVResponse\"\0\x12M\n\x08Snapsho\
    t\x12\x1d.etcdserverpb.SnapshotRequest\x1a\x1e.etcdserverpb.SnapshotResp\
    onse\"\00\x01\x12Q\n\nMoveLeader\x12\x1f.etcdserverpb.MoveLeaderRequest\
    \x1a\x20.etcdserverpb.MoveLeaderResponse\"\02\xdd\x0b\n\x04Auth\x12Q\n\n\
    AuthEnable\x12\x1f.etcdserverpb.AuthEnableRequest\x1a\x20.etcdserverpb.A\
    uthEnableResponse\"\0\x12T\n\x0bAuthDisable\x12\x20.etcdserverpb.AuthDis\
    ableRequest\x1a!.etcdserverpb.AuthDisableResponse\"\0\x12W\n\x0cAuthenti\
    cate\x12!.etcdserverpb.AuthenticateRequest\x1a\".etcdserverpb.Authentica\
    teResponse\"\0\x12P\n\x07UserAdd\x12\x20.etcdserverpb.AuthUserAddRequest\
    \x1a!.etcdserverpb.AuthUserAddResponse\"\0\x12P\n\x07UserGet\x12\x20.etc\
    dserverpb.AuthUserGetRequest\x1a!.etcdserverpb.AuthUserGetResponse\"\0\
    \x12S\n\x08UserList\x12!.etcdserverpb.AuthUserListRequest\x1a\".etcdserv\
    erpb.AuthUserListResponse\"\0\x12Y\n\nUserDelete\x12#.etcdserverpb.AuthU\
    serDeleteRequest\x1a$.etcdserverpb.AuthUserDeleteResponse\"\0\x12q\n\x12\
    UserChangePassword\x12+.etcdserverpb.AuthUserChangePasswordRequest\x1a,.\
    etcdserverpb.AuthUserChangePasswordResponse\"\0\x12b\n\rUserGrantRole\
    \x12&.etcdserverpb.AuthUserGrantRoleRequest\x1a'.etcdserverpb.AuthUserGr\
    antRoleResponse\"\0\x12e\n\x0eUserRevokeRole\x12'.etcdserverpb.AuthUserR\
    evokeRoleRequest\x1a(.etcdserverpb.AuthUserRevokeRoleResponse\"\0\x12P\n\
    \x07RoleAdd\x12\x20.etcdserverpb.AuthRoleAddRequest\x1a!.etcdserverpb.Au\
    thRoleAddResponse\"\0\x12P\n\x07RoleGet\x12\x20.etcdserverpb.AuthRoleGet\
    Request\x1a!.etcdserverpb.AuthRoleGetResponse\"\0\x12S\n\x08RoleList\x12\
    !.etcdserverpb.AuthRoleListRequest\x1a\".etcdserverpb.AuthRoleListRespon\
    se\"\0\x12Y\n\nRoleDelete\x12#.etcdserverpb.AuthRoleDeleteRequest\x1a$.e\
    tcdserverpb.AuthRoleDeleteResponse\"\0\x12t\n\x13RoleGrantPermission\x12\
    ,.etcdserverpb.AuthRoleGrantPermissionRequest\x1a-.etcdserverpb.AuthRole\
    GrantPermissionResponse\"\0\x12w\n\x14RoleRevokePermission\x12-.etcdserv\
    erpb.AuthRoleRevokePermissionRequest\x1a..etcdserverpb.AuthRoleRevokePer\
    missionResponse\"\0B)\n\x11io.etcd.jetcd.apiB\nJetcdProtoP\x01\xa2\x02\
    \x05JetcdJ\x9b\x9f\x02\n\x07\x12\x05\x10\0\xd9\x06\x01\n\xc5\x04\n\x01\
    \x0c\x12\x03\x10\0\x122\xba\x04\n\x20Copyright\x202017\x20The\x20jetcd\
    \x20authors\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Ver\
    sion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20th\
    is\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\n\t\n\x02\x03\0\x12\x03\x12\0\x12\n\t\n\x02\x03\
    \x01\x12\x03\x13\0\x14\n\x08\n\x01\x02\x12\x03\x15\0\x15\n\x08\n\x01\x08\
    \x12\x03\x17\0\"\n\t\n\x02\x08\n\x12\x03\x17\0\"\n\x08\n\x01\x08\x12\x03\
    \x18\0*\n\t\n\x02\x08\x01\x12\x03\x18\0*\n\x08\n\x01\x08\x12\x03\x19\0+\
    \n\t\n\x02\x08\x08\x12\x03\x19\0+\n\x08\n\x01\x08\x12\x03\x1a\0#\n\t\n\
    \x02\x08$\x12\x03\x1a\0#\n\n\n\x02\x06\0\x12\x04\x1c\04\x01\n\n\n\x03\
    \x06\0\x01\x12\x03\x1c\x08\n\nI\n\x04\x06\0\x02\0\x12\x03\x1e\x024\x1a<\
    \x20Range\x20gets\x20the\x20keys\x20in\x20the\x20range\x20from\x20the\
    \x20key-value\x20store.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x1e\x06\
    \x0b\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x1e\x0c\x18\n\x0c\n\x05\x06\0\
    \x02\0\x03\x12\x03\x1e#0\n\xad\x01\n\x04\x06\0\x02\x01\x12\x03#\x02.\x1a\
    \x9f\x01\x20Put\x20puts\x20the\x20given\x20key\x20into\x20the\x20key-val\
    ue\x20store.\n\x20A\x20put\x20request\x20increments\x20the\x20revision\
    \x20of\x20the\x20key-value\x20store\n\x20and\x20generates\x20one\x20even\
    t\x20in\x20the\x20event\x20history.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\
    \x03#\x06\t\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03#\n\x14\n\x0c\n\x05\x06\
    \0\x02\x01\x03\x12\x03#\x1f*\n\xd8\x01\n\x04\x06\0\x02\x02\x12\x03(\x02F\
    \x1a\xca\x01\x20DeleteRange\x20deletes\x20the\x20given\x20range\x20from\
    \x20the\x20key-value\x20store.\n\x20A\x20delete\x20request\x20increments\
    \x20the\x20revision\x20of\x20the\x20key-value\x20store\n\x20and\x20gener\
    ates\x20a\x20delete\x20event\x20in\x20the\x20event\x20history\x20for\x20\
    every\x20deleted\x20key.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03(\x06\
    \x11\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03(\x12$\n\x0c\n\x05\x06\0\x02\
    \x02\x03\x12\x03(/B\n\x98\x02\n\x04\x06\0\x02\x03\x12\x03.\x02.\x1a\x8a\
    \x02\x20Txn\x20processes\x20multiple\x20requests\x20in\x20a\x20single\
    \x20transaction.\n\x20A\x20txn\x20request\x20increments\x20the\x20revisi\
    on\x20of\x20the\x20key-value\x20store\n\x20and\x20generates\x20events\
    \x20with\x20the\x20same\x20revision\x20for\x20every\x20completed\x20requ\
    est.\n\x20It\x20is\x20not\x20allowed\x20to\x20modify\x20the\x20same\x20k\
    ey\x20several\x20times\x20within\x20one\x20txn.\n\n\x0c\n\x05\x06\0\x02\
    \x03\x01\x12\x03.\x06\t\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03.\n\x14\n\
    \x0c\n\x05\x06\0\x02\x03\x03\x12\x03.\x1f*\n\xbf\x01\n\x04\x06\0\x02\x04\
    \x12\x033\x02@\x1a\xb1\x01\x20Compact\x20compacts\x20the\x20event\x20his\
    tory\x20in\x20the\x20etcd\x20key-value\x20store.\x20The\x20key-value\n\
    \x20store\x20should\x20be\x20periodically\x20compacted\x20or\x20the\x20e\
    vent\x20history\x20will\x20continue\x20to\x20grow\n\x20indefinitely.\n\n\
    \x0c\n\x05\x06\0\x02\x04\x01\x12\x033\x06\r\n\x0c\n\x05\x06\0\x02\x04\
    \x02\x12\x033\x0e\x1f\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x033*<\n\n\n\x02\
    \x06\x01\x12\x046\0=\x01\n\n\n\x03\x06\x01\x01\x12\x036\x08\r\n\xfe\x02\
    \n\x04\x06\x01\x02\0\x12\x03<\x02B\x1a\xf0\x02\x20Watch\x20watches\x20fo\
    r\x20events\x20happening\x20or\x20that\x20have\x20happened.\x20Both\x20i\
    nput\x20and\x20output\n\x20are\x20streams;\x20the\x20input\x20stream\x20\
    is\x20for\x20creating\x20and\x20canceling\x20watchers\x20and\x20the\x20o\
    utput\n\x20stream\x20sends\x20events.\x20One\x20watch\x20RPC\x20can\x20w\
    atch\x20on\x20multiple\x20key\x20ranges,\x20streaming\x20events\n\x20for\
    \x20several\x20watches\x20at\x20once.\x20The\x20entire\x20event\x20histo\
    ry\x20can\x20be\x20watched\x20starting\x20from\x20the\n\x20last\x20compa\
    ction\x20revision.\n\n\x0c\n\x05\x06\x01\x02\0\x01\x12\x03<\x06\x0b\n\
    \x0c\n\x05\x06\x01\x02\0\x05\x12\x03<\x0c\x12\n\x0c\n\x05\x06\x01\x02\0\
    \x02\x12\x03<\x13\x1f\n\x0c\n\x05\x06\x01\x02\0\x06\x12\x03<*0\n\x0c\n\
    \x05\x06\x01\x02\0\x03\x12\x03<1>\n\n\n\x02\x06\x02\x12\x04?\0P\x01\n\n\
    \n\x03\x06\x02\x01\x12\x03?\x08\r\n\x9a\x02\n\x04\x06\x02\x02\0\x12\x03C\
    \x02C\x1a\x8c\x02\x20LeaseGrant\x20creates\x20a\x20lease\x20which\x20exp\
    ires\x20if\x20the\x20server\x20does\x20not\x20receive\x20a\x20keepAlive\
    \n\x20within\x20a\x20given\x20time\x20to\x20live\x20period.\x20All\x20ke\
    ys\x20attached\x20to\x20the\x20lease\x20will\x20be\x20expired\x20and\n\
    \x20deleted\x20if\x20the\x20lease\x20expires.\x20Each\x20expired\x20key\
    \x20generates\x20a\x20delete\x20event\x20in\x20the\x20event\x20history.\
    \n\n\x0c\n\x05\x06\x02\x02\0\x01\x12\x03C\x06\x10\n\x0c\n\x05\x06\x02\
    \x02\0\x02\x12\x03C\x11\"\n\x0c\n\x05\x06\x02\x02\0\x03\x12\x03C-?\nf\n\
    \x04\x06\x02\x02\x01\x12\x03F\x02F\x1aY\x20LeaseRevoke\x20revokes\x20a\
    \x20lease.\x20All\x20keys\x20attached\x20to\x20the\x20lease\x20will\x20e\
    xpire\x20and\x20be\x20deleted.\n\n\x0c\n\x05\x06\x02\x02\x01\x01\x12\x03\
    F\x06\x11\n\x0c\n\x05\x06\x02\x02\x01\x02\x12\x03F\x12$\n\x0c\n\x05\x06\
    \x02\x02\x01\x03\x12\x03F/B\n\xb6\x01\n\x04\x06\x02\x02\x02\x12\x03J\x02\
    ]\x1a\xa8\x01\x20LeaseKeepAlive\x20keeps\x20the\x20lease\x20alive\x20by\
    \x20streaming\x20keep\x20alive\x20requests\x20from\x20the\x20client\n\
    \x20to\x20the\x20server\x20and\x20streaming\x20keep\x20alive\x20response\
    s\x20from\x20the\x20server\x20to\x20the\x20client.\n\n\x0c\n\x05\x06\x02\
    \x02\x02\x01\x12\x03J\x06\x14\n\x0c\n\x05\x06\x02\x02\x02\x05\x12\x03J\
    \x15\x1b\n\x0c\n\x05\x06\x02\x02\x02\x02\x12\x03J\x1c1\n\x0c\n\x05\x06\
    \x02\x02\x02\x06\x12\x03J<B\n\x0c\n\x05\x06\x02\x02\x02\x03\x12\x03JCY\n\
    ;\n\x04\x06\x02\x02\x03\x12\x03M\x02R\x1a.\x20LeaseTimeToLive\x20retriev\
    es\x20lease\x20information.\n\n\x0c\n\x05\x06\x02\x02\x03\x01\x12\x03M\
    \x06\x15\n\x0c\n\x05\x06\x02\x02\x03\x02\x12\x03M\x16,\n\x0c\n\x05\x06\
    \x02\x02\x03\x03\x12\x03M7N\n\n\n\x02\x06\x03\x12\x04R\0^\x01\n\n\n\x03\
    \x06\x03\x01\x12\x03R\x08\x0f\n8\n\x04\x06\x03\x02\0\x12\x03T\x02@\x1a+\
    \x20MemberAdd\x20adds\x20a\x20member\x20into\x20the\x20cluster.\n\n\x0c\
    \n\x05\x06\x03\x02\0\x01\x12\x03T\x06\x0f\n\x0c\n\x05\x06\x03\x02\0\x02\
    \x12\x03T\x10\x20\n\x0c\n\x05\x06\x03\x02\0\x03\x12\x03T+<\nH\n\x04\x06\
    \x03\x02\x01\x12\x03W\x02I\x1a;\x20MemberRemove\x20removes\x20an\x20exis\
    ting\x20member\x20from\x20the\x20cluster.\n\n\x0c\n\x05\x06\x03\x02\x01\
    \x01\x12\x03W\x06\x12\n\x0c\n\x05\x06\x03\x02\x01\x02\x12\x03W\x13&\n\
    \x0c\n\x05\x06\x03\x02\x01\x03\x12\x03W1E\n=\n\x04\x06\x03\x02\x02\x12\
    \x03Z\x02I\x1a0\x20MemberUpdate\x20updates\x20the\x20member\x20configura\
    tion.\n\n\x0c\n\x05\x06\x03\x02\x02\x01\x12\x03Z\x06\x12\n\x0c\n\x05\x06\
    \x03\x02\x02\x02\x12\x03Z\x13&\n\x0c\n\x05\x06\x03\x02\x02\x03\x12\x03Z1\
    E\n?\n\x04\x06\x03\x02\x03\x12\x03]\x02C\x1a2\x20MemberList\x20lists\x20\
    all\x20the\x20members\x20in\x20the\x20cluster.\n\n\x0c\n\x05\x06\x03\x02\
    \x03\x01\x12\x03]\x06\x10\n\x0c\n\x05\x06\x03\x02\x03\x02\x12\x03]\x11\"\
    \n\x0c\n\x05\x06\x03\x02\x03\x03\x12\x03]-?\n\n\n\x02\x06\x04\x12\x04`\0\
    w\x01\n\n\n\x03\x06\x04\x01\x12\x03`\x08\x13\nY\n\x04\x06\x04\x02\0\x12\
    \x03b\x024\x1aL\x20Alarm\x20activates,\x20deactivates,\x20and\x20queries\
    \x20alarms\x20regarding\x20cluster\x20health.\n\n\x0c\n\x05\x06\x04\x02\
    \0\x01\x12\x03b\x06\x0b\n\x0c\n\x05\x06\x04\x02\0\x02\x12\x03b\x0c\x18\n\
    \x0c\n\x05\x06\x04\x02\0\x03\x12\x03b#0\n4\n\x04\x06\x04\x02\x01\x12\x03\
    e\x027\x1a'\x20Status\x20gets\x20the\x20status\x20of\x20the\x20member.\n\
    \n\x0c\n\x05\x06\x04\x02\x01\x01\x12\x03e\x06\x0c\n\x0c\n\x05\x06\x04\
    \x02\x01\x02\x12\x03e\r\x1a\n\x0c\n\x05\x06\x04\x02\x01\x03\x12\x03e%3\n\
    [\n\x04\x06\x04\x02\x02\x12\x03h\x02C\x1aN\x20Defragment\x20defragments\
    \x20a\x20member's\x20backend\x20database\x20to\x20recover\x20storage\x20\
    space.\n\n\x0c\n\x05\x06\x04\x02\x02\x01\x12\x03h\x06\x10\n\x0c\n\x05\
    \x06\x04\x02\x02\x02\x12\x03h\x11\"\n\x0c\n\x05\x06\x04\x02\x02\x03\x12\
    \x03h-?\n\xc0\x01\n\x04\x06\x04\x02\x03\x12\x03m\x021\x1a\xb2\x01\x20Has\
    h\x20returns\x20the\x20hash\x20of\x20the\x20local\x20KV\x20state\x20for\
    \x20consistency\x20checking\x20purpose.\n\x20This\x20is\x20designed\x20f\
    or\x20testing;\x20do\x20not\x20use\x20this\x20in\x20production\x20when\
    \x20there\n\x20are\x20ongoing\x20transactions.\n\n\x0c\n\x05\x06\x04\x02\
    \x03\x01\x12\x03m\x06\n\n\x0c\n\x05\x06\x04\x02\x03\x02\x12\x03m\x0b\x16\
    \n\x0c\n\x05\x06\x04\x02\x03\x03\x12\x03m!-\nP\n\x04\x06\x04\x02\x04\x12\
    \x03p\x027\x1aC\x20HashKV\x20computes\x20the\x20hash\x20of\x20all\x20MVC\
    C\x20keys\x20up\x20to\x20a\x20given\x20revision.\n\n\x0c\n\x05\x06\x04\
    \x02\x04\x01\x12\x03p\x06\x0c\n\x0c\n\x05\x06\x04\x02\x04\x02\x12\x03p\r\
    \x1a\n\x0c\n\x05\x06\x04\x02\x04\x03\x12\x03p%3\ng\n\x04\x06\x04\x02\x05\
    \x12\x03s\x02D\x1aZ\x20Snapshot\x20sends\x20a\x20snapshot\x20of\x20the\
    \x20entire\x20backend\x20from\x20a\x20member\x20over\x20a\x20stream\x20t\
    o\x20a\x20client.\n\n\x0c\n\x05\x06\x04\x02\x05\x01\x12\x03s\x06\x0e\n\
    \x0c\n\x05\x06\x04\x02\x05\x02\x12\x03s\x0f\x1e\n\x0c\n\x05\x06\x04\x02\
    \x05\x06\x12\x03s)/\n\x0c\n\x05\x06\x04\x02\x05\x03\x12\x03s0@\n`\n\x04\
    \x06\x04\x02\x06\x12\x03v\x02C\x1aS\x20MoveLeader\x20requests\x20current\
    \x20leader\x20node\x20to\x20transfer\x20its\x20leadership\x20to\x20trans\
    feree.\n\n\x0c\n\x05\x06\x04\x02\x06\x01\x12\x03v\x06\x10\n\x0c\n\x05\
    \x06\x04\x02\x06\x02\x12\x03v\x11\"\n\x0c\n\x05\x06\x04\x02\x06\x03\x12\
    \x03v-?\n\x0b\n\x02\x06\x05\x12\x05y\0\xa9\x01\x01\n\n\n\x03\x06\x05\x01\
    \x12\x03y\x08\x0c\n1\n\x04\x06\x05\x02\0\x12\x03{\x02C\x1a$\x20AuthEnabl\
    e\x20enables\x20authentication.\n\n\x0c\n\x05\x06\x05\x02\0\x01\x12\x03{\
    \x06\x10\n\x0c\n\x05\x06\x05\x02\0\x02\x12\x03{\x11\"\n\x0c\n\x05\x06\
    \x05\x02\0\x03\x12\x03{-?\n3\n\x04\x06\x05\x02\x01\x12\x03~\x02F\x1a&\
    \x20AuthDisable\x20disables\x20authentication.\n\n\x0c\n\x05\x06\x05\x02\
    \x01\x01\x12\x03~\x06\x11\n\x0c\n\x05\x06\x05\x02\x01\x02\x12\x03~\x12$\
    \n\x0c\n\x05\x06\x05\x02\x01\x03\x12\x03~/B\n?\n\x04\x06\x05\x02\x02\x12\
    \x04\x81\x01\x02I\x1a1\x20Authenticate\x20processes\x20an\x20authenticat\
    e\x20request.\n\n\r\n\x05\x06\x05\x02\x02\x01\x12\x04\x81\x01\x06\x12\n\
    \r\n\x05\x06\x05\x02\x02\x02\x12\x04\x81\x01\x13&\n\r\n\x05\x06\x05\x02\
    \x02\x03\x12\x04\x81\x011E\n(\n\x04\x06\x05\x02\x03\x12\x04\x84\x01\x02B\
    \x1a\x1a\x20UserAdd\x20adds\x20a\x20new\x20user.\n\n\r\n\x05\x06\x05\x02\
    \x03\x01\x12\x04\x84\x01\x06\r\n\r\n\x05\x06\x05\x02\x03\x02\x12\x04\x84\
    \x01\x0e\x20\n\r\n\x05\x06\x05\x02\x03\x03\x12\x04\x84\x01+>\n7\n\x04\
    \x06\x05\x02\x04\x12\x04\x87\x01\x02B\x1a)\x20UserGet\x20gets\x20detaile\
    d\x20user\x20information.\n\n\r\n\x05\x06\x05\x02\x04\x01\x12\x04\x87\
    \x01\x06\r\n\r\n\x05\x06\x05\x02\x04\x02\x12\x04\x87\x01\x0e\x20\n\r\n\
    \x05\x06\x05\x02\x04\x03\x12\x04\x87\x01+>\n2\n\x04\x06\x05\x02\x05\x12\
    \x04\x8a\x01\x02E\x1a$\x20UserList\x20gets\x20a\x20list\x20of\x20all\x20\
    users.\n\n\r\n\x05\x06\x05\x02\x05\x01\x12\x04\x8a\x01\x06\x0e\n\r\n\x05\
    \x06\x05\x02\x05\x02\x12\x04\x8a\x01\x0f\"\n\r\n\x05\x06\x05\x02\x05\x03\
    \x12\x04\x8a\x01-A\n4\n\x04\x06\x05\x02\x06\x12\x04\x8d\x01\x02K\x1a&\
    \x20UserDelete\x20deletes\x20a\x20specified\x20user.\n\n\r\n\x05\x06\x05\
    \x02\x06\x01\x12\x04\x8d\x01\x06\x10\n\r\n\x05\x06\x05\x02\x06\x02\x12\
    \x04\x8d\x01\x11&\n\r\n\x05\x06\x05\x02\x06\x03\x12\x04\x8d\x011G\nL\n\
    \x04\x06\x05\x02\x07\x12\x04\x90\x01\x02c\x1a>\x20UserChangePassword\x20\
    changes\x20the\x20password\x20of\x20a\x20specified\x20user.\n\n\r\n\x05\
    \x06\x05\x02\x07\x01\x12\x04\x90\x01\x06\x18\n\r\n\x05\x06\x05\x02\x07\
    \x02\x12\x04\x90\x01\x196\n\r\n\x05\x06\x05\x02\x07\x03\x12\x04\x90\x01A\
    _\n<\n\x04\x06\x05\x02\x08\x12\x04\x93\x01\x02T\x1a.\x20UserGrant\x20gra\
    nts\x20a\x20role\x20to\x20a\x20specified\x20user.\n\n\r\n\x05\x06\x05\
    \x02\x08\x01\x12\x04\x93\x01\x06\x13\n\r\n\x05\x06\x05\x02\x08\x02\x12\
    \x04\x93\x01\x14,\n\r\n\x05\x06\x05\x02\x08\x03\x12\x04\x93\x017P\n@\n\
    \x04\x06\x05\x02\t\x12\x04\x96\x01\x02W\x1a2\x20UserRevokeRole\x20revoke\
    s\x20a\x20role\x20of\x20specified\x20user.\n\n\r\n\x05\x06\x05\x02\t\x01\
    \x12\x04\x96\x01\x06\x14\n\r\n\x05\x06\x05\x02\t\x02\x12\x04\x96\x01\x15\
    .\n\r\n\x05\x06\x05\x02\t\x03\x12\x04\x96\x019S\n(\n\x04\x06\x05\x02\n\
    \x12\x04\x99\x01\x02B\x1a\x1a\x20RoleAdd\x20adds\x20a\x20new\x20role.\n\
    \n\r\n\x05\x06\x05\x02\n\x01\x12\x04\x99\x01\x06\r\n\r\n\x05\x06\x05\x02\
    \n\x02\x12\x04\x99\x01\x0e\x20\n\r\n\x05\x06\x05\x02\n\x03\x12\x04\x99\
    \x01+>\n7\n\x04\x06\x05\x02\x0b\x12\x04\x9c\x01\x02B\x1a)\x20RoleGet\x20\
    gets\x20detailed\x20role\x20information.\n\n\r\n\x05\x06\x05\x02\x0b\x01\
    \x12\x04\x9c\x01\x06\r\n\r\n\x05\x06\x05\x02\x0b\x02\x12\x04\x9c\x01\x0e\
    \x20\n\r\n\x05\x06\x05\x02\x0b\x03\x12\x04\x9c\x01+>\n1\n\x04\x06\x05\
    \x02\x0c\x12\x04\x9f\x01\x02E\x1a#\x20RoleList\x20gets\x20lists\x20of\
    \x20all\x20roles.\n\n\r\n\x05\x06\x05\x02\x0c\x01\x12\x04\x9f\x01\x06\
    \x0e\n\r\n\x05\x06\x05\x02\x0c\x02\x12\x04\x9f\x01\x0f\"\n\r\n\x05\x06\
    \x05\x02\x0c\x03\x12\x04\x9f\x01-A\n4\n\x04\x06\x05\x02\r\x12\x04\xa2\
    \x01\x02K\x1a&\x20RoleDelete\x20deletes\x20a\x20specified\x20role.\n\n\r\
    \n\x05\x06\x05\x02\r\x01\x12\x04\xa2\x01\x06\x10\n\r\n\x05\x06\x05\x02\r\
    \x02\x12\x04\xa2\x01\x11&\n\r\n\x05\x06\x05\x02\r\x03\x12\x04\xa2\x011G\
    \nh\n\x04\x06\x05\x02\x0e\x12\x04\xa5\x01\x02f\x1aZ\x20RoleGrantPermissi\
    on\x20grants\x20a\x20permission\x20of\x20a\x20specified\x20key\x20or\x20\
    range\x20to\x20a\x20specified\x20role.\n\n\r\n\x05\x06\x05\x02\x0e\x01\
    \x12\x04\xa5\x01\x06\x19\n\r\n\x05\x06\x05\x02\x0e\x02\x12\x04\xa5\x01\
    \x1a8\n\r\n\x05\x06\x05\x02\x0e\x03\x12\x04\xa5\x01Cb\n[\n\x04\x06\x05\
    \x02\x0f\x12\x04\xa8\x01\x02i\x1aM\x20RoleRevokePermission\x20revokes\
    \x20a\x20key\x20or\x20range\x20permission\x20of\x20a\x20specified\x20rol\
    e.\n\n\r\n\x05\x06\x05\x02\x0f\x01\x12\x04\xa8\x01\x06\x1a\n\r\n\x05\x06\
    \x05\x02\x0f\x02\x12\x04\xa8\x01\x1b:\n\r\n\x05\x06\x05\x02\x0f\x03\x12\
    \x04\xa8\x01Ee\n\x0c\n\x02\x04\0\x12\x06\xab\x01\0\xb4\x01\x01\n\x0b\n\
    \x03\x04\0\x01\x12\x04\xab\x01\x08\x16\nL\n\x04\x04\0\x02\0\x12\x04\xad\
    \x01\x02\x18\x1a>\x20cluster_id\x20is\x20the\x20ID\x20of\x20the\x20clust\
    er\x20which\x20sent\x20the\x20response.\n\n\x0f\n\x05\x04\0\x02\0\x04\
    \x12\x06\xad\x01\x02\xab\x01\x18\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xad\
    \x01\x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xad\x01\t\x13\n\r\n\x05\
    \x04\0\x02\0\x03\x12\x04\xad\x01\x16\x17\nJ\n\x04\x04\0\x02\x01\x12\x04\
    \xaf\x01\x02\x17\x1a<\x20member_id\x20is\x20the\x20ID\x20of\x20the\x20me\
    mber\x20which\x20sent\x20the\x20response.\n\n\x0f\n\x05\x04\0\x02\x01\
    \x04\x12\x06\xaf\x01\x02\xad\x01\x18\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\
    \xaf\x01\x02\x08\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xaf\x01\t\x12\n\r\n\
    \x05\x04\0\x02\x01\x03\x12\x04\xaf\x01\x15\x16\nV\n\x04\x04\0\x02\x02\
    \x12\x04\xb1\x01\x02\x15\x1aH\x20revision\x20is\x20the\x20key-value\x20s\
    tore\x20revision\x20when\x20the\x20request\x20was\x20applied.\n\n\x0f\n\
    \x05\x04\0\x02\x02\x04\x12\x06\xb1\x01\x02\xaf\x01\x17\n\r\n\x05\x04\0\
    \x02\x02\x05\x12\x04\xb1\x01\x02\x07\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\
    \xb1\x01\x08\x10\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xb1\x01\x13\x14\nH\
    \n\x04\x04\0\x02\x03\x12\x04\xb3\x01\x02\x17\x1a:\x20raft_term\x20is\x20\
    the\x20raft\x20term\x20when\x20the\x20request\x20was\x20applied.\n\n\x0f\
    \n\x05\x04\0\x02\x03\x04\x12\x06\xb3\x01\x02\xb1\x01\x15\n\r\n\x05\x04\0\
    \x02\x03\x05\x12\x04\xb3\x01\x02\x08\n\r\n\x05\x04\0\x02\x03\x01\x12\x04\
    \xb3\x01\t\x12\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\xb3\x01\x15\x16\n\x0c\
    \n\x02\x04\x01\x12\x06\xb6\x01\0\xf7\x01\x01\n\x0b\n\x03\x04\x01\x01\x12\
    \x04\xb6\x01\x08\x14\n\x0e\n\x04\x04\x01\x04\0\x12\x06\xb7\x01\x02\xbb\
    \x01\x03\n\r\n\x05\x04\x01\x04\0\x01\x12\x04\xb7\x01\x07\x10\n%\n\x06\
    \x04\x01\x04\0\x02\0\x12\x04\xb8\x01\x04\r\"\x15\x20default,\x20no\x20so\
    rting\n\n\x0f\n\x07\x04\x01\x04\0\x02\0\x01\x12\x04\xb8\x01\x04\x08\n\
    \x0f\n\x07\x04\x01\x04\0\x02\0\x02\x12\x04\xb8\x01\x0b\x0c\n+\n\x06\x04\
    \x01\x04\0\x02\x01\x12\x04\xb9\x01\x04\x0f\"\x1b\x20lowest\x20target\x20\
    value\x20first\n\n\x0f\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x04\xb9\x01\
    \x04\n\n\x0f\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x04\xb9\x01\r\x0e\n,\n\
    \x06\x04\x01\x04\0\x02\x02\x12\x04\xba\x01\x04\x10\"\x1c\x20highest\x20t\
    arget\x20value\x20first\n\n\x0f\n\x07\x04\x01\x04\0\x02\x02\x01\x12\x04\
    \xba\x01\x04\x0b\n\x0f\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x04\xba\x01\
    \x0e\x0f\n\x0e\n\x04\x04\x01\x04\x01\x12\x06\xbc\x01\x02\xc2\x01\x03\n\r\
    \n\x05\x04\x01\x04\x01\x01\x12\x04\xbc\x01\x07\x11\n\x0e\n\x06\x04\x01\
    \x04\x01\x02\0\x12\x04\xbd\x01\x04\x0c\n\x0f\n\x07\x04\x01\x04\x01\x02\0\
    \x01\x12\x04\xbd\x01\x04\x07\n\x0f\n\x07\x04\x01\x04\x01\x02\0\x02\x12\
    \x04\xbd\x01\n\x0b\n\x0e\n\x06\x04\x01\x04\x01\x02\x01\x12\x04\xbe\x01\
    \x04\x10\n\x0f\n\x07\x04\x01\x04\x01\x02\x01\x01\x12\x04\xbe\x01\x04\x0b\
    \n\x0f\n\x07\x04\x01\x04\x01\x02\x01\x02\x12\x04\xbe\x01\x0e\x0f\n\x0e\n\
    \x06\x04\x01\x04\x01\x02\x02\x12\x04\xbf\x01\x04\x0f\n\x0f\n\x07\x04\x01\
    \x04\x01\x02\x02\x01\x12\x04\xbf\x01\x04\n\n\x0f\n\x07\x04\x01\x04\x01\
    \x02\x02\x02\x12\x04\xbf\x01\r\x0e\n\x0e\n\x06\x04\x01\x04\x01\x02\x03\
    \x12\x04\xc0\x01\x04\x0c\n\x0f\n\x07\x04\x01\x04\x01\x02\x03\x01\x12\x04\
    \xc0\x01\x04\x07\n\x0f\n\x07\x04\x01\x04\x01\x02\x03\x02\x12\x04\xc0\x01\
    \n\x0b\n\x0e\n\x06\x04\x01\x04\x01\x02\x04\x12\x04\xc1\x01\x04\x0e\n\x0f\
    \n\x07\x04\x01\x04\x01\x02\x04\x01\x12\x04\xc1\x01\x04\t\n\x0f\n\x07\x04\
    \x01\x04\x01\x02\x04\x02\x12\x04\xc1\x01\x0c\r\nm\n\x04\x04\x01\x02\0\
    \x12\x04\xc5\x01\x02\x10\x1a_\x20key\x20is\x20the\x20first\x20key\x20for\
    \x20the\x20range.\x20If\x20range_end\x20is\x20not\x20given,\x20the\x20re\
    quest\x20only\x20looks\x20up\x20key.\n\n\x0f\n\x05\x04\x01\x02\0\x04\x12\
    \x06\xc5\x01\x02\xc2\x01\x03\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xc5\x01\
    \x02\x07\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xc5\x01\x08\x0b\n\r\n\x05\
    \x04\x01\x02\0\x03\x12\x04\xc5\x01\x0e\x0f\n\xda\x02\n\x04\x04\x01\x02\
    \x01\x12\x04\xcb\x01\x02\x16\x1a\xcb\x02\x20range_end\x20is\x20the\x20up\
    per\x20bound\x20on\x20the\x20requested\x20range\x20[key,\x20range_end).\
    \n\x20If\x20range_end\x20is\x20'\\0',\x20the\x20range\x20is\x20all\x20ke\
    ys\x20>=\x20key.\n\x20If\x20range_end\x20is\x20key\x20plus\x20one\x20(e.\
    g.,\x20\"aa\"+1\x20==\x20\"ab\",\x20\"a\\xff\"+1\x20==\x20\"b\"),\n\x20t\
    hen\x20the\x20range\x20request\x20gets\x20all\x20keys\x20prefixed\x20wit\
    h\x20key.\n\x20If\x20both\x20key\x20and\x20range_end\x20are\x20'\\0',\
    \x20then\x20the\x20range\x20request\x20returns\x20all\x20keys.\n\n\x0f\n\
    \x05\x04\x01\x02\x01\x04\x12\x06\xcb\x01\x02\xc5\x01\x10\n\r\n\x05\x04\
    \x01\x02\x01\x05\x12\x04\xcb\x01\x02\x07\n\r\n\x05\x04\x01\x02\x01\x01\
    \x12\x04\xcb\x01\x08\x11\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xcb\x01\
    \x14\x15\n\x84\x01\n\x04\x04\x01\x02\x02\x12\x04\xce\x01\x02\x12\x1av\
    \x20limit\x20is\x20a\x20limit\x20on\x20the\x20number\x20of\x20keys\x20re\
    turned\x20for\x20the\x20request.\x20When\x20limit\x20is\x20set\x20to\x20\
    0,\n\x20it\x20is\x20treated\x20as\x20no\x20limit.\n\n\x0f\n\x05\x04\x01\
    \x02\x02\x04\x12\x06\xce\x01\x02\xcb\x01\x16\n\r\n\x05\x04\x01\x02\x02\
    \x05\x12\x04\xce\x01\x02\x07\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xce\
    \x01\x08\r\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\xce\x01\x10\x11\n\xfd\
    \x01\n\x04\x04\x01\x02\x03\x12\x04\xd2\x01\x02\x15\x1a\xee\x01\x20revisi\
    on\x20is\x20the\x20point-in-time\x20of\x20the\x20key-value\x20store\x20t\
    o\x20use\x20for\x20the\x20range.\n\x20If\x20revision\x20is\x20less\x20or\
    \x20equal\x20to\x20zero,\x20the\x20range\x20is\x20over\x20the\x20newest\
    \x20key-value\x20store.\n\x20If\x20the\x20revision\x20has\x20been\x20com\
    pacted,\x20ErrCompacted\x20is\x20returned\x20as\x20a\x20response.\n\n\
    \x0f\n\x05\x04\x01\x02\x03\x04\x12\x06\xd2\x01\x02\xce\x01\x12\n\r\n\x05\
    \x04\x01\x02\x03\x05\x12\x04\xd2\x01\x02\x07\n\r\n\x05\x04\x01\x02\x03\
    \x01\x12\x04\xd2\x01\x08\x10\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\xd2\
    \x01\x13\x14\nD\n\x04\x04\x01\x02\x04\x12\x04\xd5\x01\x02\x1b\x1a6\x20so\
    rt_order\x20is\x20the\x20order\x20for\x20returned\x20sorted\x20results.\
    \n\n\x0f\n\x05\x04\x01\x02\x04\x04\x12\x06\xd5\x01\x02\xd2\x01\x15\n\r\n\
    \x05\x04\x01\x02\x04\x06\x12\x04\xd5\x01\x02\x0b\n\r\n\x05\x04\x01\x02\
    \x04\x01\x12\x04\xd5\x01\x0c\x16\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\
    \xd5\x01\x19\x1a\nF\n\x04\x04\x01\x02\x05\x12\x04\xd8\x01\x02\x1d\x1a8\
    \x20sort_target\x20is\x20the\x20key-value\x20field\x20to\x20use\x20for\
    \x20sorting.\n\n\x0f\n\x05\x04\x01\x02\x05\x04\x12\x06\xd8\x01\x02\xd5\
    \x01\x1b\n\r\n\x05\x04\x01\x02\x05\x06\x12\x04\xd8\x01\x02\x0c\n\r\n\x05\
    \x04\x01\x02\x05\x01\x12\x04\xd8\x01\r\x18\n\r\n\x05\x04\x01\x02\x05\x03\
    \x12\x04\xd8\x01\x1b\x1c\n\xca\x03\n\x04\x04\x01\x02\x06\x12\x04\xe0\x01\
    \x02\x18\x1a\xbb\x03\x20serializable\x20sets\x20the\x20range\x20request\
    \x20to\x20use\x20serializable\x20member-local\x20reads.\n\x20Range\x20re\
    quests\x20are\x20linearizable\x20by\x20default;\x20linearizable\x20reque\
    sts\x20have\x20higher\n\x20latency\x20and\x20lower\x20throughput\x20than\
    \x20serializable\x20requests\x20but\x20reflect\x20the\x20current\n\x20co\
    nsensus\x20of\x20the\x20cluster.\x20For\x20better\x20performance,\x20in\
    \x20exchange\x20for\x20possible\x20stale\x20reads,\n\x20a\x20serializabl\
    e\x20range\x20request\x20is\x20served\x20locally\x20without\x20needing\
    \x20to\x20reach\x20consensus\n\x20with\x20other\x20nodes\x20in\x20the\
    \x20cluster.\n\n\x0f\n\x05\x04\x01\x02\x06\x04\x12\x06\xe0\x01\x02\xd8\
    \x01\x1d\n\r\n\x05\x04\x01\x02\x06\x05\x12\x04\xe0\x01\x02\x06\n\r\n\x05\
    \x04\x01\x02\x06\x01\x12\x04\xe0\x01\x07\x13\n\r\n\x05\x04\x01\x02\x06\
    \x03\x12\x04\xe0\x01\x16\x17\nL\n\x04\x04\x01\x02\x07\x12\x04\xe3\x01\
    \x02\x15\x1a>\x20keys_only\x20when\x20set\x20returns\x20only\x20the\x20k\
    eys\x20and\x20not\x20the\x20values.\n\n\x0f\n\x05\x04\x01\x02\x07\x04\
    \x12\x06\xe3\x01\x02\xe0\x01\x18\n\r\n\x05\x04\x01\x02\x07\x05\x12\x04\
    \xe3\x01\x02\x06\n\r\n\x05\x04\x01\x02\x07\x01\x12\x04\xe3\x01\x07\x10\n\
    \r\n\x05\x04\x01\x02\x07\x03\x12\x04\xe3\x01\x13\x14\nT\n\x04\x04\x01\
    \x02\x08\x12\x04\xe6\x01\x02\x16\x1aF\x20count_only\x20when\x20set\x20re\
    turns\x20only\x20the\x20count\x20of\x20the\x20keys\x20in\x20the\x20range\
    .\n\n\x0f\n\x05\x04\x01\x02\x08\x04\x12\x06\xe6\x01\x02\xe3\x01\x15\n\r\
    \n\x05\x04\x01\x02\x08\x05\x12\x04\xe6\x01\x02\x06\n\r\n\x05\x04\x01\x02\
    \x08\x01\x12\x04\xe6\x01\x07\x11\n\r\n\x05\x04\x01\x02\x08\x03\x12\x04\
    \xe6\x01\x14\x15\n\x8f\x01\n\x04\x04\x01\x02\t\x12\x04\xea\x01\x02\x1e\
    \x1a\x80\x01\x20min_mod_revision\x20is\x20the\x20lower\x20bound\x20for\
    \x20returned\x20key\x20mod\x20revisions;\x20all\x20keys\x20with\n\x20les\
    ser\x20mod\x20revisions\x20will\x20be\x20filtered\x20away.\n\n\x0f\n\x05\
    \x04\x01\x02\t\x04\x12\x06\xea\x01\x02\xe6\x01\x16\n\r\n\x05\x04\x01\x02\
    \t\x05\x12\x04\xea\x01\x02\x07\n\r\n\x05\x04\x01\x02\t\x01\x12\x04\xea\
    \x01\x08\x18\n\r\n\x05\x04\x01\x02\t\x03\x12\x04\xea\x01\x1b\x1d\n\x90\
    \x01\n\x04\x04\x01\x02\n\x12\x04\xee\x01\x02\x1e\x1a\x81\x01\x20max_mod_\
    revision\x20is\x20the\x20upper\x20bound\x20for\x20returned\x20key\x20mod\
    \x20revisions;\x20all\x20keys\x20with\n\x20greater\x20mod\x20revisions\
    \x20will\x20be\x20filtered\x20away.\n\n\x0f\n\x05\x04\x01\x02\n\x04\x12\
    \x06\xee\x01\x02\xea\x01\x1e\n\r\n\x05\x04\x01\x02\n\x05\x12\x04\xee\x01\
    \x02\x07\n\r\n\x05\x04\x01\x02\n\x01\x12\x04\xee\x01\x08\x18\n\r\n\x05\
    \x04\x01\x02\n\x03\x12\x04\xee\x01\x1b\x1d\n\x99\x01\n\x04\x04\x01\x02\
    \x0b\x12\x04\xf2\x01\x02!\x1a\x8a\x01\x20min_create_revision\x20is\x20th\
    e\x20lower\x20bound\x20for\x20returned\x20key\x20create\x20revisions;\
    \x20all\x20keys\x20with\n\x20lesser\x20create\x20trevisions\x20will\x20b\
    e\x20filtered\x20away.\n\n\x0f\n\x05\x04\x01\x02\x0b\x04\x12\x06\xf2\x01\
    \x02\xee\x01\x1e\n\r\n\x05\x04\x01\x02\x0b\x05\x12\x04\xf2\x01\x02\x07\n\
    \r\n\x05\x04\x01\x02\x0b\x01\x12\x04\xf2\x01\x08\x1b\n\r\n\x05\x04\x01\
    \x02\x0b\x03\x12\x04\xf2\x01\x1e\x20\n\x99\x01\n\x04\x04\x01\x02\x0c\x12\
    \x04\xf6\x01\x02!\x1a\x8a\x01\x20max_create_revision\x20is\x20the\x20upp\
    er\x20bound\x20for\x20returned\x20key\x20create\x20revisions;\x20all\x20\
    keys\x20with\n\x20greater\x20create\x20revisions\x20will\x20be\x20filter\
    ed\x20away.\n\n\x0f\n\x05\x04\x01\x02\x0c\x04\x12\x06\xf6\x01\x02\xf2\
    \x01!\n\r\n\x05\x04\x01\x02\x0c\x05\x12\x04\xf6\x01\x02\x07\n\r\n\x05\
    \x04\x01\x02\x0c\x01\x12\x04\xf6\x01\x08\x1b\n\r\n\x05\x04\x01\x02\x0c\
    \x03\x12\x04\xf6\x01\x1e\x20\n\x0c\n\x02\x04\x02\x12\x06\xf9\x01\0\x82\
    \x02\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\xf9\x01\x08\x15\n\x0c\n\x04\x04\
    \x02\x02\0\x12\x04\xfa\x01\x02\x1c\n\x0f\n\x05\x04\x02\x02\0\x04\x12\x06\
    \xfa\x01\x02\xf9\x01\x17\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xfa\x01\x02\
    \x10\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xfa\x01\x11\x17\n\r\n\x05\x04\
    \x02\x02\0\x03\x12\x04\xfa\x01\x1a\x1b\nw\n\x04\x04\x02\x02\x01\x12\x04\
    \xfd\x01\x02#\x1ai\x20kvs\x20is\x20the\x20list\x20of\x20key-value\x20pai\
    rs\x20matched\x20by\x20the\x20range\x20request.\n\x20kvs\x20is\x20empty\
    \x20when\x20count\x20is\x20requested.\n\n\r\n\x05\x04\x02\x02\x01\x04\
    \x12\x04\xfd\x01\x02\n\n\r\n\x05\x04\x02\x02\x01\x06\x12\x04\xfd\x01\x0b\
    \x1a\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xfd\x01\x1b\x1e\n\r\n\x05\x04\
    \x02\x02\x01\x03\x12\x04\xfd\x01!\"\nW\n\x04\x04\x02\x02\x02\x12\x04\xff\
    \x01\x02\x10\x1aI\x20more\x20indicates\x20if\x20there\x20are\x20more\x20\
    keys\x20to\x20return\x20in\x20the\x20requested\x20range.\n\n\x0f\n\x05\
    \x04\x02\x02\x02\x04\x12\x06\xff\x01\x02\xfd\x01#\n\r\n\x05\x04\x02\x02\
    \x02\x05\x12\x04\xff\x01\x02\x06\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\
    \xff\x01\x07\x0b\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xff\x01\x0e\x0f\n\
    S\n\x04\x04\x02\x02\x03\x12\x04\x81\x02\x02\x12\x1aE\x20count\x20is\x20s\
    et\x20to\x20the\x20number\x20of\x20keys\x20within\x20the\x20range\x20whe\
    n\x20requested.\n\n\x0f\n\x05\x04\x02\x02\x03\x04\x12\x06\x81\x02\x02\
    \xff\x01\x10\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\x81\x02\x02\x07\n\r\n\
    \x05\x04\x02\x02\x03\x01\x12\x04\x81\x02\x08\r\n\r\n\x05\x04\x02\x02\x03\
    \x03\x12\x04\x81\x02\x10\x11\n\x0c\n\x02\x04\x03\x12\x06\x84\x02\0\x98\
    \x02\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\x84\x02\x08\x12\nJ\n\x04\x04\
    \x03\x02\0\x12\x04\x86\x02\x02\x10\x1a<\x20key\x20is\x20the\x20key,\x20i\
    n\x20bytes,\x20to\x20put\x20into\x20the\x20key-value\x20store.\n\n\x0f\n\
    \x05\x04\x03\x02\0\x04\x12\x06\x86\x02\x02\x84\x02\x14\n\r\n\x05\x04\x03\
    \x02\0\x05\x12\x04\x86\x02\x02\x07\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\
    \x86\x02\x08\x0b\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x86\x02\x0e\x0f\n_\
    \n\x04\x04\x03\x02\x01\x12\x04\x88\x02\x02\x12\x1aQ\x20value\x20is\x20th\
    e\x20value,\x20in\x20bytes,\x20to\x20associate\x20with\x20the\x20key\x20\
    in\x20the\x20key-value\x20store.\n\n\x0f\n\x05\x04\x03\x02\x01\x04\x12\
    \x06\x88\x02\x02\x86\x02\x10\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\x88\
    \x02\x02\x07\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x88\x02\x08\r\n\r\n\
    \x05\x04\x03\x02\x01\x03\x12\x04\x88\x02\x10\x11\n\x7f\n\x04\x04\x03\x02\
    \x02\x12\x04\x8b\x02\x02\x12\x1aq\x20lease\x20is\x20the\x20lease\x20ID\
    \x20to\x20associate\x20with\x20the\x20key\x20in\x20the\x20key-value\x20s\
    tore.\x20A\x20lease\n\x20value\x20of\x200\x20indicates\x20no\x20lease.\n\
    \n\x0f\n\x05\x04\x03\x02\x02\x04\x12\x06\x8b\x02\x02\x88\x02\x12\n\r\n\
    \x05\x04\x03\x02\x02\x05\x12\x04\x8b\x02\x02\x07\n\r\n\x05\x04\x03\x02\
    \x02\x01\x12\x04\x8b\x02\x08\r\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\x8b\
    \x02\x10\x11\n\xa0\x01\n\x04\x04\x03\x02\x03\x12\x04\x8f\x02\x02\x13\x1a\
    \x91\x01\x20If\x20prev_kv\x20is\x20set,\x20etcd\x20gets\x20the\x20previo\
    us\x20key-value\x20pair\x20before\x20changing\x20it.\n\x20The\x20previou\
    s\x20key-value\x20pair\x20will\x20be\x20returned\x20in\x20the\x20put\x20\
    response.\n\n\x0f\n\x05\x04\x03\x02\x03\x04\x12\x06\x8f\x02\x02\x8b\x02\
    \x12\n\r\n\x05\x04\x03\x02\x03\x05\x12\x04\x8f\x02\x02\x06\n\r\n\x05\x04\
    \x03\x02\x03\x01\x12\x04\x8f\x02\x07\x0e\n\r\n\x05\x04\x03\x02\x03\x03\
    \x12\x04\x8f\x02\x11\x12\n\x82\x01\n\x04\x04\x03\x02\x04\x12\x04\x93\x02\
    \x02\x18\x1at\x20If\x20ignore_value\x20is\x20set,\x20etcd\x20updates\x20\
    the\x20key\x20using\x20its\x20current\x20value.\n\x20Returns\x20an\x20er\
    ror\x20if\x20the\x20key\x20does\x20not\x20exist.\n\n\x0f\n\x05\x04\x03\
    \x02\x04\x04\x12\x06\x93\x02\x02\x8f\x02\x13\n\r\n\x05\x04\x03\x02\x04\
    \x05\x12\x04\x93\x02\x02\x06\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\x93\
    \x02\x07\x13\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\x93\x02\x16\x17\n\x82\
    \x01\n\x04\x04\x03\x02\x05\x12\x04\x97\x02\x02\x18\x1at\x20If\x20ignore_\
    lease\x20is\x20set,\x20etcd\x20updates\x20the\x20key\x20using\x20its\x20\
    current\x20lease.\n\x20Returns\x20an\x20error\x20if\x20the\x20key\x20doe\
    s\x20not\x20exist.\n\n\x0f\n\x05\x04\x03\x02\x05\x04\x12\x06\x97\x02\x02\
    \x93\x02\x18\n\r\n\x05\x04\x03\x02\x05\x05\x12\x04\x97\x02\x02\x06\n\r\n\
    \x05\x04\x03\x02\x05\x01\x12\x04\x97\x02\x07\x13\n\r\n\x05\x04\x03\x02\
    \x05\x03\x12\x04\x97\x02\x16\x17\n\x0c\n\x02\x04\x04\x12\x06\x9a\x02\0\
    \x9e\x02\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\x9a\x02\x08\x13\n\x0c\n\x04\
    \x04\x04\x02\0\x12\x04\x9b\x02\x02\x1c\n\x0f\n\x05\x04\x04\x02\0\x04\x12\
    \x06\x9b\x02\x02\x9a\x02\x15\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\x9b\x02\
    \x02\x10\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\x9b\x02\x11\x17\n\r\n\x05\
    \x04\x04\x02\0\x03\x12\x04\x9b\x02\x1a\x1b\n_\n\x04\x04\x04\x02\x01\x12\
    \x04\x9d\x02\x02\x1e\x1aQ\x20if\x20prev_kv\x20is\x20set\x20in\x20the\x20\
    request,\x20the\x20previous\x20key-value\x20pair\x20will\x20be\x20return\
    ed.\n\n\x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\x9d\x02\x02\x9b\x02\x1c\n\
    \r\n\x05\x04\x04\x02\x01\x06\x12\x04\x9d\x02\x02\x11\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\x9d\x02\x12\x19\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\x9d\x02\x1c\x1d\n\x0c\n\x02\x04\x05\x12\x06\xa0\x02\0\xad\x02\x01\n\
    \x0b\n\x03\x04\x05\x01\x12\x04\xa0\x02\x08\x1a\n<\n\x04\x04\x05\x02\0\
    \x12\x04\xa2\x02\x02\x10\x1a.\x20key\x20is\x20the\x20first\x20key\x20to\
    \x20delete\x20in\x20the\x20range.\n\n\x0f\n\x05\x04\x05\x02\0\x04\x12\
    \x06\xa2\x02\x02\xa0\x02\x1c\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xa2\x02\
    \x02\x07\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xa2\x02\x08\x0b\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\xa2\x02\x0e\x0f\n\x86\x03\n\x04\x04\x05\x02\
    \x01\x12\x04\xa8\x02\x02\x16\x1a\xf7\x02\x20range_end\x20is\x20the\x20ke\
    y\x20following\x20the\x20last\x20key\x20to\x20delete\x20for\x20the\x20ra\
    nge\x20[key,\x20range_end).\n\x20If\x20range_end\x20is\x20not\x20given,\
    \x20the\x20range\x20is\x20defined\x20to\x20contain\x20only\x20the\x20key\
    \x20argument.\n\x20If\x20range_end\x20is\x20one\x20bit\x20larger\x20than\
    \x20the\x20given\x20key,\x20then\x20the\x20range\x20is\x20all\x20the\x20\
    keys\n\x20with\x20the\x20prefix\x20(the\x20given\x20key).\n\x20If\x20ran\
    ge_end\x20is\x20'\\0',\x20the\x20range\x20is\x20all\x20keys\x20greater\
    \x20than\x20or\x20equal\x20to\x20the\x20key\x20argument.\n\n\x0f\n\x05\
    \x04\x05\x02\x01\x04\x12\x06\xa8\x02\x02\xa2\x02\x10\n\r\n\x05\x04\x05\
    \x02\x01\x05\x12\x04\xa8\x02\x02\x07\n\r\n\x05\x04\x05\x02\x01\x01\x12\
    \x04\xa8\x02\x08\x11\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xa8\x02\x14\
    \x15\n\xa5\x01\n\x04\x04\x05\x02\x02\x12\x04\xac\x02\x02\x13\x1a\x96\x01\
    \x20If\x20prev_kv\x20is\x20set,\x20etcd\x20gets\x20the\x20previous\x20ke\
    y-value\x20pairs\x20before\x20deleting\x20it.\n\x20The\x20previous\x20ke\
    y-value\x20pairs\x20will\x20be\x20returned\x20in\x20the\x20delete\x20res\
    ponse.\n\n\x0f\n\x05\x04\x05\x02\x02\x04\x12\x06\xac\x02\x02\xa8\x02\x16\
    \n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xac\x02\x02\x06\n\r\n\x05\x04\x05\
    \x02\x02\x01\x12\x04\xac\x02\x07\x0e\n\r\n\x05\x04\x05\x02\x02\x03\x12\
    \x04\xac\x02\x11\x12\n\x0c\n\x02\x04\x06\x12\x06\xaf\x02\0\xb5\x02\x01\n\
    \x0b\n\x03\x04\x06\x01\x12\x04\xaf\x02\x08\x1b\n\x0c\n\x04\x04\x06\x02\0\
    \x12\x04\xb0\x02\x02\x1c\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\xb0\x02\
    \x02\xaf\x02\x1d\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xb0\x02\x02\x10\n\r\
    \n\x05\x04\x06\x02\0\x01\x12\x04\xb0\x02\x11\x17\n\r\n\x05\x04\x06\x02\0\
    \x03\x12\x04\xb0\x02\x1a\x1b\nR\n\x04\x04\x06\x02\x01\x12\x04\xb2\x02\
    \x02\x14\x1aD\x20deleted\x20is\x20the\x20number\x20of\x20keys\x20deleted\
    \x20by\x20the\x20delete\x20range\x20request.\n\n\x0f\n\x05\x04\x06\x02\
    \x01\x04\x12\x06\xb2\x02\x02\xb0\x02\x1c\n\r\n\x05\x04\x06\x02\x01\x05\
    \x12\x04\xb2\x02\x02\x07\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xb2\x02\
    \x08\x0f\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xb2\x02\x12\x13\n`\n\x04\
    \x04\x06\x02\x02\x12\x04\xb4\x02\x02(\x1aR\x20if\x20prev_kv\x20is\x20set\
    \x20in\x20the\x20request,\x20the\x20previous\x20key-value\x20pairs\x20wi\
    ll\x20be\x20returned.\n\n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\xb4\x02\
    \x02\n\n\r\n\x05\x04\x06\x02\x02\x06\x12\x04\xb4\x02\x0b\x1a\n\r\n\x05\
    \x04\x06\x02\x02\x01\x12\x04\xb4\x02\x1b#\n\r\n\x05\x04\x06\x02\x02\x03\
    \x12\x04\xb4\x02&'\n\x0c\n\x02\x04\x07\x12\x06\xb7\x02\0\xbf\x02\x01\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\xb7\x02\x08\x11\nP\n\x04\x04\x07\x08\0\
    \x12\x06\xb9\x02\x02\xbe\x02\x03\x1a@\x20request\x20is\x20a\x20union\x20\
    of\x20request\x20types\x20accepted\x20by\x20a\x20transaction.\n\n\r\n\
    \x05\x04\x07\x08\0\x01\x12\x04\xb9\x02\x08\x0f\n\x0c\n\x04\x04\x07\x02\0\
    \x12\x04\xba\x02\x04#\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xba\x02\x04\
    \x10\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xba\x02\x11\x1e\n\r\n\x05\x04\
    \x07\x02\0\x03\x12\x04\xba\x02!\"\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\
    \xbb\x02\x04\x1f\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\xbb\x02\x04\x0e\n\
    \r\n\x05\x04\x07\x02\x01\x01\x12\x04\xbb\x02\x0f\x1a\n\r\n\x05\x04\x07\
    \x02\x01\x03\x12\x04\xbb\x02\x1d\x1e\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\
    \xbc\x02\x040\n\r\n\x05\x04\x07\x02\x02\x06\x12\x04\xbc\x02\x04\x16\n\r\
    \n\x05\x04\x07\x02\x02\x01\x12\x04\xbc\x02\x17+\n\r\n\x05\x04\x07\x02\
    \x02\x03\x12\x04\xbc\x02./\n\x0c\n\x04\x04\x07\x02\x03\x12\x04\xbd\x02\
    \x04\x1f\n\r\n\x05\x04\x07\x02\x03\x06\x12\x04\xbd\x02\x04\x0e\n\r\n\x05\
    \x04\x07\x02\x03\x01\x12\x04\xbd\x02\x0f\x1a\n\r\n\x05\x04\x07\x02\x03\
    \x03\x12\x04\xbd\x02\x1d\x1e\n\x0c\n\x02\x04\x08\x12\x06\xc1\x02\0\xc9\
    \x02\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\xc1\x02\x08\x12\nR\n\x04\x04\
    \x08\x08\0\x12\x06\xc3\x02\x02\xc8\x02\x03\x1aB\x20response\x20is\x20a\
    \x20union\x20of\x20response\x20types\x20returned\x20by\x20a\x20transacti\
    on.\n\n\r\n\x05\x04\x08\x08\0\x01\x12\x04\xc3\x02\x08\x10\n\x0c\n\x04\
    \x04\x08\x02\0\x12\x04\xc4\x02\x04%\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\
    \xc4\x02\x04\x11\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xc4\x02\x12\x20\n\r\
    \n\x05\x04\x08\x02\0\x03\x12\x04\xc4\x02#$\n\x0c\n\x04\x04\x08\x02\x01\
    \x12\x04\xc5\x02\x04!\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xc5\x02\x04\
    \x0f\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xc5\x02\x10\x1c\n\r\n\x05\x04\
    \x08\x02\x01\x03\x12\x04\xc5\x02\x1f\x20\n\x0c\n\x04\x04\x08\x02\x02\x12\
    \x04\xc6\x02\x042\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\xc6\x02\x04\x17\
    \n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xc6\x02\x18-\n\r\n\x05\x04\x08\
    \x02\x02\x03\x12\x04\xc6\x0201\n\x0c\n\x04\x04\x08\x02\x03\x12\x04\xc7\
    \x02\x04!\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\xc7\x02\x04\x0f\n\r\n\
    \x05\x04\x08\x02\x03\x01\x12\x04\xc7\x02\x10\x1c\n\r\n\x05\x04\x08\x02\
    \x03\x03\x12\x04\xc7\x02\x1f\x20\n\x0c\n\x02\x04\t\x12\x06\xcb\x02\0\xec\
    \x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xcb\x02\x08\x0f\n\x0e\n\x04\x04\t\
    \x04\0\x12\x06\xcc\x02\x02\xd1\x02\x03\n\r\n\x05\x04\t\x04\0\x01\x12\x04\
    \xcc\x02\x07\x14\n\x0e\n\x06\x04\t\x04\0\x02\0\x12\x04\xcd\x02\x04\x0e\n\
    \x0f\n\x07\x04\t\x04\0\x02\0\x01\x12\x04\xcd\x02\x04\t\n\x0f\n\x07\x04\t\
    \x04\0\x02\0\x02\x12\x04\xcd\x02\x0c\r\n\x0e\n\x06\x04\t\x04\0\x02\x01\
    \x12\x04\xce\x02\x04\x10\n\x0f\n\x07\x04\t\x04\0\x02\x01\x01\x12\x04\xce\
    \x02\x04\x0b\n\x0f\n\x07\x04\t\x04\0\x02\x01\x02\x12\x04\xce\x02\x0e\x0f\
    \n\x0e\n\x06\x04\t\x04\0\x02\x02\x12\x04\xcf\x02\x04\r\n\x0f\n\x07\x04\t\
    \x04\0\x02\x02\x01\x12\x04\xcf\x02\x04\x08\n\x0f\n\x07\x04\t\x04\0\x02\
    \x02\x02\x12\x04\xcf\x02\x0b\x0c\n\x0e\n\x06\x04\t\x04\0\x02\x03\x12\x04\
    \xd0\x02\x04\x12\n\x0f\n\x07\x04\t\x04\0\x02\x03\x01\x12\x04\xd0\x02\x04\
    \r\n\x0f\n\x07\x04\t\x04\0\x02\x03\x02\x12\x04\xd0\x02\x10\x11\n\x0e\n\
    \x04\x04\t\x04\x01\x12\x06\xd2\x02\x02\xd7\x02\x03\n\r\n\x05\x04\t\x04\
    \x01\x01\x12\x04\xd2\x02\x07\x14\n\x0e\n\x06\x04\t\x04\x01\x02\0\x12\x04\
    \xd3\x02\x04\x10\n\x0f\n\x07\x04\t\x04\x01\x02\0\x01\x12\x04\xd3\x02\x04\
    \x0b\n\x0f\n\x07\x04\t\x04\x01\x02\0\x02\x12\x04\xd3\x02\x0e\x0f\n\x0e\n\
    \x06\x04\t\x04\x01\x02\x01\x12\x04\xd4\x02\x04\x0f\n\x0f\n\x07\x04\t\x04\
    \x01\x02\x01\x01\x12\x04\xd4\x02\x04\n\n\x0f\n\x07\x04\t\x04\x01\x02\x01\
    \x02\x12\x04\xd4\x02\r\x0e\n\x0e\n\x06\x04\t\x04\x01\x02\x02\x12\x04\xd5\
    \x02\x04\x0c\n\x0f\n\x07\x04\t\x04\x01\x02\x02\x01\x12\x04\xd5\x02\x04\
    \x07\n\x0f\n\x07\x04\t\x04\x01\x02\x02\x02\x12\x04\xd5\x02\n\x0b\n\x0e\n\
    \x06\x04\t\x04\x01\x02\x03\x12\x04\xd6\x02\x04\r\n\x0f\n\x07\x04\t\x04\
    \x01\x02\x03\x01\x12\x04\xd6\x02\x04\t\n\x0f\n\x07\x04\t\x04\x01\x02\x03\
    \x02\x12\x04\xd6\x02\x0b\x0c\nK\n\x04\x04\t\x02\0\x12\x04\xd9\x02\x02\
    \x1b\x1a=\x20result\x20is\x20logical\x20comparison\x20operation\x20for\
    \x20this\x20comparison.\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\xd9\x02\
    \x02\xd7\x02\x03\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xd9\x02\x02\x0f\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\xd9\x02\x10\x16\n\r\n\x05\x04\t\x02\0\x03\
    \x12\x04\xd9\x02\x19\x1a\nL\n\x04\x04\t\x02\x01\x12\x04\xdb\x02\x02\x1b\
    \x1a>\x20target\x20is\x20the\x20key-value\x20field\x20to\x20inspect\x20f\
    or\x20the\x20comparison.\n\n\x0f\n\x05\x04\t\x02\x01\x04\x12\x06\xdb\x02\
    \x02\xd9\x02\x1b\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xdb\x02\x02\x0f\n\r\
    \n\x05\x04\t\x02\x01\x01\x12\x04\xdb\x02\x10\x16\n\r\n\x05\x04\t\x02\x01\
    \x03\x12\x04\xdb\x02\x19\x1a\nD\n\x04\x04\t\x02\x02\x12\x04\xdd\x02\x02\
    \x10\x1a6\x20key\x20is\x20the\x20subject\x20key\x20for\x20the\x20compari\
    son\x20operation.\n\n\x0f\n\x05\x04\t\x02\x02\x04\x12\x06\xdd\x02\x02\
    \xdb\x02\x1b\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xdd\x02\x02\x07\n\r\n\
    \x05\x04\t\x02\x02\x01\x12\x04\xdd\x02\x08\x0b\n\r\n\x05\x04\t\x02\x02\
    \x03\x12\x04\xdd\x02\x0e\x0f\n\x0e\n\x04\x04\t\x08\0\x12\x06\xde\x02\x02\
    \xe7\x02\x03\n\r\n\x05\x04\t\x08\0\x01\x12\x04\xde\x02\x08\x14\n7\n\x04\
    \x04\t\x02\x03\x12\x04\xe0\x02\x04\x16\x1a)\x20version\x20is\x20the\x20v\
    ersion\x20of\x20the\x20given\x20key\n\n\r\n\x05\x04\t\x02\x03\x05\x12\
    \x04\xe0\x02\x04\t\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xe0\x02\n\x11\n\r\
    \n\x05\x04\t\x02\x03\x03\x12\x04\xe0\x02\x14\x15\nI\n\x04\x04\t\x02\x04\
    \x12\x04\xe2\x02\x04\x1e\x1a;\x20create_revision\x20is\x20the\x20creatio\
    n\x20revision\x20of\x20the\x20given\x20key\n\n\r\n\x05\x04\t\x02\x04\x05\
    \x12\x04\xe2\x02\x04\t\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\xe2\x02\n\x19\
    \n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xe2\x02\x1c\x1d\nL\n\x04\x04\t\x02\
    \x05\x12\x04\xe4\x02\x04\x1b\x1a>\x20mod_revision\x20is\x20the\x20last\
    \x20modified\x20revision\x20of\x20the\x20given\x20key.\n\n\r\n\x05\x04\t\
    \x02\x05\x05\x12\x04\xe4\x02\x04\t\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\
    \xe4\x02\n\x16\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xe4\x02\x19\x1a\n>\n\
    \x04\x04\t\x02\x06\x12\x04\xe6\x02\x04\x14\x1a0\x20value\x20is\x20the\
    \x20value\x20of\x20the\x20given\x20key,\x20in\x20bytes.\n\n\r\n\x05\x04\
    \t\x02\x06\x05\x12\x04\xe6\x02\x04\t\n\r\n\x05\x04\t\x02\x06\x01\x12\x04\
    \xe6\x02\n\x0f\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\xe6\x02\x12\x13\n\xdd\
    \x01\n\x04\x04\t\x02\x07\x12\x04\xea\x02\x02\x16\x1a\x82\x01\x20range_en\
    d\x20compares\x20the\x20given\x20target\x20to\x20all\x20keys\x20in\x20th\
    e\x20range\x20[key,\x20range_end).\n\x20See\x20RangeRequest\x20for\x20mo\
    re\x20details\x20on\x20key\x20ranges.\n\"J\x20TODO:\x20fill\x20out\x20wi\
    th\x20most\x20of\x20the\x20rest\x20of\x20RangeRequest\x20fields\x20when\
    \x20needed.\n\n\x0f\n\x05\x04\t\x02\x07\x04\x12\x06\xea\x02\x02\xe7\x02\
    \x03\n\r\n\x05\x04\t\x02\x07\x05\x12\x04\xea\x02\x02\x07\n\r\n\x05\x04\t\
    \x02\x07\x01\x12\x04\xea\x02\x08\x11\n\r\n\x05\x04\t\x02\x07\x03\x12\x04\
    \xea\x02\x14\x15\n\x89\t\n\x02\x04\n\x12\x06\xfd\x02\0\x88\x03\x01\x1a\
    \xfa\x08\x20From\x20google\x20paxosdb\x20paper:\n\x20Our\x20implementati\
    on\x20hinges\x20around\x20a\x20powerful\x20primitive\x20which\x20we\x20c\
    all\x20MultiOp.\x20All\x20other\x20database\n\x20operations\x20except\
    \x20for\x20iteration\x20are\x20implemented\x20as\x20a\x20single\x20call\
    \x20to\x20MultiOp.\x20A\x20MultiOp\x20is\x20applied\x20atomically\n\x20a\
    nd\x20consists\x20of\x20three\x20components:\n\x201.\x20A\x20list\x20of\
    \x20tests\x20called\x20guard.\x20Each\x20test\x20in\x20guard\x20checks\
    \x20a\x20single\x20entry\x20in\x20the\x20database.\x20It\x20may\x20check\
    \n\x20for\x20the\x20absence\x20or\x20presence\x20of\x20a\x20value,\x20or\
    \x20compare\x20with\x20a\x20given\x20value.\x20Two\x20different\x20tests\
    \x20in\x20the\x20guard\n\x20may\x20apply\x20to\x20the\x20same\x20or\x20d\
    ifferent\x20entries\x20in\x20the\x20database.\x20All\x20tests\x20in\x20t\
    he\x20guard\x20are\x20applied\x20and\n\x20MultiOp\x20returns\x20the\x20r\
    esults.\x20If\x20all\x20tests\x20are\x20true,\x20MultiOp\x20executes\x20\
    t\x20op\x20(see\x20item\x202\x20below),\x20otherwise\n\x20it\x20executes\
    \x20f\x20op\x20(see\x20item\x203\x20below).\n\x202.\x20A\x20list\x20of\
    \x20database\x20operations\x20called\x20t\x20op.\x20Each\x20operation\
    \x20in\x20the\x20list\x20is\x20either\x20an\x20insert,\x20delete,\x20or\
    \n\x20lookup\x20operation,\x20and\x20applies\x20to\x20a\x20single\x20dat\
    abase\x20entry.\x20Two\x20different\x20operations\x20in\x20the\x20list\
    \x20may\x20apply\n\x20to\x20the\x20same\x20or\x20different\x20entries\
    \x20in\x20the\x20database.\x20These\x20operations\x20are\x20executed\n\
    \x20if\x20guard\x20evaluates\x20to\n\x20true.\n\x203.\x20A\x20list\x20of\
    \x20database\x20operations\x20called\x20f\x20op.\x20Like\x20t\x20op,\x20\
    but\x20executed\x20if\x20guard\x20evaluates\x20to\x20false.\n\n\x0b\n\
    \x03\x04\n\x01\x12\x04\xfd\x02\x08\x12\n\x80\x03\n\x04\x04\n\x02\0\x12\
    \x04\x83\x03\x02\x1f\x1a\xf1\x02\x20compare\x20is\x20a\x20list\x20of\x20\
    predicates\x20representing\x20a\x20conjunction\x20of\x20terms.\n\x20If\
    \x20the\x20comparisons\x20succeed,\x20then\x20the\x20success\x20requests\
    \x20will\x20be\x20processed\x20in\x20order,\n\x20and\x20the\x20response\
    \x20will\x20contain\x20their\x20respective\x20responses\x20in\x20order.\
    \n\x20If\x20the\x20comparisons\x20fail,\x20then\x20the\x20failure\x20req\
    uests\x20will\x20be\x20processed\x20in\x20order,\n\x20and\x20the\x20resp\
    onse\x20will\x20contain\x20their\x20respective\x20responses\x20in\x20ord\
    er.\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\x83\x03\x02\n\n\r\n\x05\x04\n\
    \x02\0\x06\x12\x04\x83\x03\x0b\x12\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x83\
    \x03\x13\x1a\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x83\x03\x1d\x1e\nc\n\x04\
    \x04\n\x02\x01\x12\x04\x85\x03\x02!\x1aU\x20success\x20is\x20a\x20list\
    \x20of\x20requests\x20which\x20will\x20be\x20applied\x20when\x20compare\
    \x20evaluates\x20to\x20true.\n\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x85\
    \x03\x02\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x85\x03\x0b\x14\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\x85\x03\x15\x1c\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\x85\x03\x1f\x20\nd\n\x04\x04\n\x02\x02\x12\x04\x87\x03\x02!\x1a\
    V\x20failure\x20is\x20a\x20list\x20of\x20requests\x20which\x20will\x20be\
    \x20applied\x20when\x20compare\x20evaluates\x20to\x20false.\n\n\r\n\x05\
    \x04\n\x02\x02\x04\x12\x04\x87\x03\x02\n\n\r\n\x05\x04\n\x02\x02\x06\x12\
    \x04\x87\x03\x0b\x14\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x87\x03\x15\x1c\
    \n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x87\x03\x1f\x20\n\x0c\n\x02\x04\x0b\
    \x12\x06\x8a\x03\0\x91\x03\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x8a\x03\
    \x08\x13\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x8b\x03\x02\x1c\n\x0f\n\x05\
    \x04\x0b\x02\0\x04\x12\x06\x8b\x03\x02\x8a\x03\x15\n\r\n\x05\x04\x0b\x02\
    \0\x06\x12\x04\x8b\x03\x02\x10\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x8b\
    \x03\x11\x17\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x8b\x03\x1a\x1b\n]\n\
    \x04\x04\x0b\x02\x01\x12\x04\x8d\x03\x02\x15\x1aO\x20succeeded\x20is\x20\
    set\x20to\x20true\x20if\x20the\x20compare\x20evaluated\x20to\x20true\x20\
    or\x20false\x20otherwise.\n\n\x0f\n\x05\x04\x0b\x02\x01\x04\x12\x06\x8d\
    \x03\x02\x8b\x03\x1c\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x8d\x03\x02\
    \x06\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x8d\x03\x07\x10\n\r\n\x05\x04\
    \x0b\x02\x01\x03\x12\x04\x8d\x03\x13\x14\n\x9c\x01\n\x04\x04\x0b\x02\x02\
    \x12\x04\x90\x03\x02$\x1a\x8d\x01\x20responses\x20is\x20a\x20list\x20of\
    \x20responses\x20corresponding\x20to\x20the\x20results\x20from\x20applyi\
    ng\n\x20success\x20if\x20succeeded\x20is\x20true\x20or\x20failure\x20if\
    \x20succeeded\x20is\x20false.\n\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\
    \x90\x03\x02\n\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\x90\x03\x0b\x15\n\r\
    \n\x05\x04\x0b\x02\x02\x01\x12\x04\x90\x03\x16\x1f\n\r\n\x05\x04\x0b\x02\
    \x02\x03\x12\x04\x90\x03\"#\n\xaf\x01\n\x02\x04\x0c\x12\x06\x95\x03\0\
    \x9c\x03\x01\x1a\xa0\x01\x20CompactionRequest\x20compacts\x20the\x20key-\
    value\x20store\x20up\x20to\x20a\x20given\x20revision.\x20All\x20supersed\
    ed\x20keys\n\x20with\x20a\x20revision\x20less\x20than\x20the\x20compacti\
    on\x20revision\x20will\x20be\x20removed.\n\n\x0b\n\x03\x04\x0c\x01\x12\
    \x04\x95\x03\x08\x19\nV\n\x04\x04\x0c\x02\0\x12\x04\x97\x03\x02\x15\x1aH\
    \x20revision\x20is\x20the\x20key-value\x20store\x20revision\x20for\x20th\
    e\x20compaction\x20operation.\n\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\
    \x97\x03\x02\x95\x03\x1b\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x97\x03\x02\
    \x07\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x97\x03\x08\x10\n\r\n\x05\x04\
    \x0c\x02\0\x03\x12\x04\x97\x03\x13\x14\n\xc3\x01\n\x04\x04\x0c\x02\x01\
    \x12\x04\x9b\x03\x02\x14\x1a\xb4\x01\x20physical\x20is\x20set\x20so\x20t\
    he\x20RPC\x20will\x20wait\x20until\x20the\x20compaction\x20is\x20physica\
    lly\n\x20applied\x20to\x20the\x20local\x20database\x20such\x20that\x20co\
    mpacted\x20entries\x20are\x20totally\n\x20removed\x20from\x20the\x20back\
    end\x20database.\n\n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\x9b\x03\x02\
    \x97\x03\x15\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x9b\x03\x02\x06\n\r\n\
    \x05\x04\x0c\x02\x01\x01\x12\x04\x9b\x03\x07\x0f\n\r\n\x05\x04\x0c\x02\
    \x01\x03\x12\x04\x9b\x03\x12\x13\n\x0c\n\x02\x04\r\x12\x06\x9e\x03\0\xa0\
    \x03\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x9e\x03\x08\x1a\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\x9f\x03\x02\x1c\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\x9f\
    \x03\x02\x9e\x03\x1c\n\r\n\x05\x04\r\x02\0\x06\x12\x04\x9f\x03\x02\x10\n\
    \r\n\x05\x04\r\x02\0\x01\x12\x04\x9f\x03\x11\x17\n\r\n\x05\x04\r\x02\0\
    \x03\x12\x04\x9f\x03\x1a\x1b\n\x0c\n\x02\x04\x0e\x12\x06\xa2\x03\0\xa3\
    \x03\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xa2\x03\x08\x13\n\x0c\n\x02\x04\
    \x0f\x12\x06\xa5\x03\0\xa9\x03\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa5\
    \x03\x08\x14\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xa6\x03\x02\x1c\n\x0f\n\
    \x05\x04\x0f\x02\0\x04\x12\x06\xa6\x03\x02\xa5\x03\x16\n\r\n\x05\x04\x0f\
    \x02\0\x06\x12\x04\xa6\x03\x02\x10\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \xa6\x03\x11\x17\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa6\x03\x1a\x1b\n]\
    \n\x04\x04\x0f\x02\x01\x12\x04\xa8\x03\x02\x12\x1aO\x20hash\x20is\x20the\
    \x20hash\x20value\x20computed\x20from\x20the\x20responding\x20member's\
    \x20key-value\x20store.\n\n\x0f\n\x05\x04\x0f\x02\x01\x04\x12\x06\xa8\
    \x03\x02\xa6\x03\x1c\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xa8\x03\x02\
    \x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xa8\x03\t\r\n\r\n\x05\x04\x0f\
    \x02\x01\x03\x12\x04\xa8\x03\x10\x11\n\x0c\n\x02\x04\x10\x12\x06\xab\x03\
    \0\xae\x03\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xab\x03\x08\x15\nP\n\x04\
    \x04\x10\x02\0\x12\x04\xad\x03\x02\x15\x1aB\x20revision\x20is\x20the\x20\
    key-value\x20store\x20revision\x20for\x20the\x20hash\x20operation.\n\n\
    \x0f\n\x05\x04\x10\x02\0\x04\x12\x06\xad\x03\x02\xab\x03\x17\n\r\n\x05\
    \x04\x10\x02\0\x05\x12\x04\xad\x03\x02\x07\n\r\n\x05\x04\x10\x02\0\x01\
    \x12\x04\xad\x03\x08\x10\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xad\x03\x13\
    \x14\n\x0c\n\x02\x04\x11\x12\x06\xb0\x03\0\xb6\x03\x01\n\x0b\n\x03\x04\
    \x11\x01\x12\x04\xb0\x03\x08\x16\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xb1\
    \x03\x02\x1c\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xb1\x03\x02\xb0\x03\
    \x18\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xb1\x03\x02\x10\n\r\n\x05\x04\
    \x11\x02\0\x01\x12\x04\xb1\x03\x11\x17\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\xb1\x03\x1a\x1b\nn\n\x04\x04\x11\x02\x01\x12\x04\xb3\x03\x02\x12\
    \x1a`\x20hash\x20is\x20the\x20hash\x20value\x20computed\x20from\x20the\
    \x20responding\x20member's\x20MVCC\x20keys\x20up\x20to\x20a\x20given\x20\
    revision.\n\n\x0f\n\x05\x04\x11\x02\x01\x04\x12\x06\xb3\x03\x02\xb1\x03\
    \x1c\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xb3\x03\x02\x08\n\r\n\x05\x04\
    \x11\x02\x01\x01\x12\x04\xb3\x03\t\r\n\r\n\x05\x04\x11\x02\x01\x03\x12\
    \x04\xb3\x03\x10\x11\n_\n\x04\x04\x11\x02\x02\x12\x04\xb5\x03\x02\x1d\
    \x1aQ\x20compact_revision\x20is\x20the\x20compacted\x20revision\x20of\
    \x20key-value\x20store\x20when\x20hash\x20begins.\n\n\x0f\n\x05\x04\x11\
    \x02\x02\x04\x12\x06\xb5\x03\x02\xb3\x03\x12\n\r\n\x05\x04\x11\x02\x02\
    \x05\x12\x04\xb5\x03\x02\x07\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xb5\
    \x03\x08\x18\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xb5\x03\x1b\x1c\n\x0c\
    \n\x02\x04\x12\x12\x06\xb8\x03\0\xb9\x03\x01\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xb8\x03\x08\x17\n\x0c\n\x02\x04\x13\x12\x06\xbb\x03\0\xc5\x03\x01\n\
    \x0b\n\x03\x04\x13\x01\x12\x04\xbb\x03\x08\x18\n\x9a\x01\n\x04\x04\x13\
    \x02\0\x12\x04\xbe\x03\x02\x1c\x1a\x8b\x01\x20header\x20has\x20the\x20cu\
    rrent\x20key-value\x20store\x20information.\x20The\x20first\x20header\
    \x20in\x20the\x20snapshot\n\x20stream\x20indicates\x20the\x20point\x20in\
    \x20time\x20of\x20the\x20snapshot.\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\
    \x06\xbe\x03\x02\xbb\x03\x1a\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xbe\x03\
    \x02\x10\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xbe\x03\x11\x17\n\r\n\x05\
    \x04\x13\x02\0\x03\x12\x04\xbe\x03\x1a\x1b\nY\n\x04\x04\x13\x02\x01\x12\
    \x04\xc1\x03\x02\x1d\x1aK\x20remaining_bytes\x20is\x20the\x20number\x20o\
    f\x20blob\x20bytes\x20to\x20be\x20sent\x20after\x20this\x20message\n\n\
    \x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\xc1\x03\x02\xbe\x03\x1c\n\r\n\x05\
    \x04\x13\x02\x01\x05\x12\x04\xc1\x03\x02\x08\n\r\n\x05\x04\x13\x02\x01\
    \x01\x12\x04\xc1\x03\t\x18\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xc1\x03\
    \x1b\x1c\nT\n\x04\x04\x13\x02\x02\x12\x04\xc4\x03\x02\x11\x1aF\x20blob\
    \x20contains\x20the\x20next\x20chunk\x20of\x20the\x20snapshot\x20in\x20t\
    he\x20snapshot\x20stream.\n\n\x0f\n\x05\x04\x13\x02\x02\x04\x12\x06\xc4\
    \x03\x02\xc1\x03\x1d\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xc4\x03\x02\
    \x07\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xc4\x03\x08\x0c\n\r\n\x05\x04\
    \x13\x02\x02\x03\x12\x04\xc4\x03\x0f\x10\n\x0c\n\x02\x04\x14\x12\x06\xc7\
    \x03\0\xcd\x03\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xc7\x03\x08\x14\nj\n\
    \x04\x04\x14\x08\0\x12\x06\xc9\x03\x02\xcc\x03\x03\x1aZ\x20request_union\
    \x20is\x20a\x20request\x20to\x20either\x20create\x20a\x20new\x20watcher\
    \x20or\x20cancel\x20an\x20existing\x20watcher.\n\n\r\n\x05\x04\x14\x08\0\
    \x01\x12\x04\xc9\x03\x08\x15\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xca\x03\
    \x04*\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xca\x03\x04\x16\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\xca\x03\x17%\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\
    \xca\x03()\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xcb\x03\x04*\n\r\n\x05\
    \x04\x14\x02\x01\x06\x12\x04\xcb\x03\x04\x16\n\r\n\x05\x04\x14\x02\x01\
    \x01\x12\x04\xcb\x03\x17%\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xcb\x03(\
    )\n\x0c\n\x02\x04\x15\x12\x06\xcf\x03\0\xec\x03\x01\n\x0b\n\x03\x04\x15\
    \x01\x12\x04\xcf\x03\x08\x1a\n8\n\x04\x04\x15\x02\0\x12\x04\xd1\x03\x02\
    \x10\x1a*\x20key\x20is\x20the\x20key\x20to\x20register\x20for\x20watchin\
    g.\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\xd1\x03\x02\xcf\x03\x1c\n\r\n\
    \x05\x04\x15\x02\0\x05\x12\x04\xd1\x03\x02\x07\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xd1\x03\x08\x0b\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xd1\x03\
    \x0e\x0f\n\xe3\x02\n\x04\x04\x15\x02\x01\x12\x04\xd7\x03\x02\x16\x1a\xd4\
    \x02\x20range_end\x20is\x20the\x20end\x20of\x20the\x20range\x20[key,\x20\
    range_end)\x20to\x20watch.\x20If\x20range_end\x20is\x20not\x20given,\n\
    \x20only\x20the\x20key\x20argument\x20is\x20watched.\x20If\x20range_end\
    \x20is\x20equal\x20to\x20'\\0',\x20all\x20keys\x20greater\x20than\n\x20o\
    r\x20equal\x20to\x20the\x20key\x20argument\x20are\x20watched.\n\x20If\
    \x20the\x20range_end\x20is\x20one\x20bit\x20larger\x20than\x20the\x20giv\
    en\x20key,\n\x20then\x20all\x20keys\x20with\x20the\x20prefix\x20(the\x20\
    given\x20key)\x20will\x20be\x20watched.\n\n\x0f\n\x05\x04\x15\x02\x01\
    \x04\x12\x06\xd7\x03\x02\xd1\x03\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\
    \x04\xd7\x03\x02\x07\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xd7\x03\x08\
    \x11\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xd7\x03\x14\x15\nm\n\x04\x04\
    \x15\x02\x02\x12\x04\xd9\x03\x02\x1b\x1a_\x20start_revision\x20is\x20an\
    \x20optional\x20revision\x20to\x20watch\x20from\x20(inclusive).\x20No\
    \x20start_revision\x20is\x20\"now\".\n\n\x0f\n\x05\x04\x15\x02\x02\x04\
    \x12\x06\xd9\x03\x02\xd7\x03\x16\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\
    \xd9\x03\x02\x07\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xd9\x03\x08\x16\n\
    \r\n\x05\x04\x15\x02\x02\x03\x12\x04\xd9\x03\x19\x1a\n\xe9\x02\n\x04\x04\
    \x15\x02\x03\x12\x04\xde\x03\x02\x1b\x1a\xda\x02\x20progress_notify\x20i\
    s\x20set\x20so\x20that\x20the\x20etcd\x20server\x20will\x20periodically\
    \x20send\x20a\x20WatchResponse\x20with\n\x20no\x20events\x20to\x20the\
    \x20new\x20watcher\x20if\x20there\x20are\x20no\x20recent\x20events.\x20I\
    t\x20is\x20useful\x20when\x20clients\n\x20wish\x20to\x20recover\x20a\x20\
    disconnected\x20watcher\x20starting\x20from\x20a\x20recent\x20known\x20r\
    evision.\n\x20The\x20etcd\x20server\x20may\x20decide\x20how\x20often\x20\
    it\x20will\x20send\x20notifications\x20based\x20on\x20current\x20load.\n\
    \n\x0f\n\x05\x04\x15\x02\x03\x04\x12\x06\xde\x03\x02\xd9\x03\x1b\n\r\n\
    \x05\x04\x15\x02\x03\x05\x12\x04\xde\x03\x02\x06\n\r\n\x05\x04\x15\x02\
    \x03\x01\x12\x04\xde\x03\x07\x16\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\
    \xde\x03\x19\x1a\n\x0e\n\x04\x04\x15\x04\0\x12\x06\xe0\x03\x02\xe5\x03\
    \x03\n\r\n\x05\x04\x15\x04\0\x01\x12\x04\xe0\x03\x07\x11\n'\n\x06\x04\
    \x15\x04\0\x02\0\x12\x04\xe2\x03\x04\x0e\x1a\x17\x20filter\x20out\x20put\
    \x20event.\n\n\x0f\n\x07\x04\x15\x04\0\x02\0\x01\x12\x04\xe2\x03\x04\t\n\
    \x0f\n\x07\x04\x15\x04\0\x02\0\x02\x12\x04\xe2\x03\x0c\r\n*\n\x06\x04\
    \x15\x04\0\x02\x01\x12\x04\xe4\x03\x04\x11\x1a\x1a\x20filter\x20out\x20d\
    elete\x20event.\n\n\x0f\n\x07\x04\x15\x04\0\x02\x01\x01\x12\x04\xe4\x03\
    \x04\x0c\n\x0f\n\x07\x04\x15\x04\0\x02\x01\x02\x12\x04\xe4\x03\x0f\x10\n\
    ]\n\x04\x04\x15\x02\x04\x12\x04\xe7\x03\x02\"\x1aO\x20filters\x20filter\
    \x20the\x20events\x20at\x20server\x20side\x20before\x20it\x20sends\x20ba\
    ck\x20to\x20the\x20watcher.\n\n\r\n\x05\x04\x15\x02\x04\x04\x12\x04\xe7\
    \x03\x02\n\n\r\n\x05\x04\x15\x02\x04\x06\x12\x04\xe7\x03\x0b\x15\n\r\n\
    \x05\x04\x15\x02\x04\x01\x12\x04\xe7\x03\x16\x1d\n\r\n\x05\x04\x15\x02\
    \x04\x03\x12\x04\xe7\x03\x20!\n\xa6\x01\n\x04\x04\x15\x02\x05\x12\x04\
    \xeb\x03\x02\x13\x1a\x97\x01\x20If\x20prev_kv\x20is\x20set,\x20created\
    \x20watcher\x20gets\x20the\x20previous\x20KV\x20before\x20the\x20event\
    \x20happens.\n\x20If\x20the\x20previous\x20KV\x20is\x20already\x20compac\
    ted,\x20nothing\x20will\x20be\x20returned.\n\n\x0f\n\x05\x04\x15\x02\x05\
    \x04\x12\x06\xeb\x03\x02\xe7\x03\"\n\r\n\x05\x04\x15\x02\x05\x05\x12\x04\
    \xeb\x03\x02\x06\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\xeb\x03\x07\x0e\n\
    \r\n\x05\x04\x15\x02\x05\x03\x12\x04\xeb\x03\x11\x12\n\x0c\n\x02\x04\x16\
    \x12\x06\xee\x03\0\xf1\x03\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xee\x03\
    \x08\x1a\n\\\n\x04\x04\x16\x02\0\x12\x04\xf0\x03\x02\x15\x1aN\x20watch_i\
    d\x20is\x20the\x20watcher\x20id\x20to\x20cancel\x20so\x20that\x20no\x20m\
    ore\x20events\x20are\x20transmitted.\n\n\x0f\n\x05\x04\x16\x02\0\x04\x12\
    \x06\xf0\x03\x02\xee\x03\x1c\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xf0\x03\
    \x02\x07\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xf0\x03\x08\x10\n\r\n\x05\
    \x04\x16\x02\0\x03\x12\x04\xf0\x03\x13\x14\n\x0c\n\x02\x04\x17\x12\x06\
    \xf3\x03\0\x8d\x04\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xf3\x03\x08\x15\n\
    \x0c\n\x04\x04\x17\x02\0\x12\x04\xf4\x03\x02\x1c\n\x0f\n\x05\x04\x17\x02\
    \0\x04\x12\x06\xf4\x03\x02\xf3\x03\x17\n\r\n\x05\x04\x17\x02\0\x06\x12\
    \x04\xf4\x03\x02\x10\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xf4\x03\x11\x17\
    \n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xf4\x03\x1a\x1b\nS\n\x04\x04\x17\
    \x02\x01\x12\x04\xf6\x03\x02\x15\x1aE\x20watch_id\x20is\x20the\x20ID\x20\
    of\x20the\x20watcher\x20that\x20corresponds\x20to\x20the\x20response.\n\
    \n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\xf6\x03\x02\xf4\x03\x1c\n\r\n\
    \x05\x04\x17\x02\x01\x05\x12\x04\xf6\x03\x02\x07\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\xf6\x03\x08\x10\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \xf6\x03\x13\x14\n\x95\x02\n\x04\x04\x17\x02\x02\x12\x04\xfb\x03\x02\x13\
    \x1a\x86\x02\x20created\x20is\x20set\x20to\x20true\x20if\x20the\x20respo\
    nse\x20is\x20for\x20a\x20create\x20watch\x20request.\n\x20The\x20client\
    \x20should\x20record\x20the\x20watch_id\x20and\x20expect\x20to\x20receiv\
    e\x20events\x20for\n\x20the\x20created\x20watcher\x20from\x20the\x20same\
    \x20stream.\n\x20All\x20events\x20sent\x20to\x20the\x20created\x20watche\
    r\x20will\x20attach\x20with\x20the\x20same\x20watch_id.\n\n\x0f\n\x05\
    \x04\x17\x02\x02\x04\x12\x06\xfb\x03\x02\xf6\x03\x15\n\r\n\x05\x04\x17\
    \x02\x02\x05\x12\x04\xfb\x03\x02\x06\n\r\n\x05\x04\x17\x02\x02\x01\x12\
    \x04\xfb\x03\x07\x0e\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xfb\x03\x11\
    \x12\n\x90\x01\n\x04\x04\x17\x02\x03\x12\x04\xfe\x03\x02\x14\x1a\x81\x01\
    \x20canceled\x20is\x20set\x20to\x20true\x20if\x20the\x20response\x20is\
    \x20for\x20a\x20cancel\x20watch\x20request.\n\x20No\x20further\x20events\
    \x20will\x20be\x20sent\x20to\x20the\x20canceled\x20watcher.\n\n\x0f\n\
    \x05\x04\x17\x02\x03\x04\x12\x06\xfe\x03\x02\xfb\x03\x13\n\r\n\x05\x04\
    \x17\x02\x03\x05\x12\x04\xfe\x03\x02\x06\n\r\n\x05\x04\x17\x02\x03\x01\
    \x12\x04\xfe\x03\x07\x0f\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xfe\x03\
    \x12\x13\n\xf9\x02\n\x04\x04\x17\x02\x04\x12\x04\x87\x04\x02\x1e\x1a\xea\
    \x02\x20compact_revision\x20is\x20set\x20to\x20the\x20minimum\x20index\
    \x20if\x20a\x20watcher\x20tries\x20to\x20watch\n\x20at\x20a\x20compacted\
    \x20index.\n\n\x20This\x20happens\x20when\x20creating\x20a\x20watcher\
    \x20at\x20a\x20compacted\x20revision\x20or\x20the\x20watcher\x20cannot\n\
    \x20catch\x20up\x20with\x20the\x20progress\x20of\x20the\x20key-value\x20\
    store.\n\n\x20The\x20client\x20should\x20treat\x20the\x20watcher\x20as\
    \x20canceled\x20and\x20should\x20not\x20try\x20to\x20create\x20any\n\x20\
    watcher\x20with\x20the\x20same\x20start_revision\x20again.\n\n\x0f\n\x05\
    \x04\x17\x02\x04\x04\x12\x06\x87\x04\x02\xfe\x03\x14\n\r\n\x05\x04\x17\
    \x02\x04\x05\x12\x04\x87\x04\x02\x07\n\r\n\x05\x04\x17\x02\x04\x01\x12\
    \x04\x87\x04\x08\x18\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\x87\x04\x1c\
    \x1d\nM\n\x04\x04\x17\x02\x05\x12\x04\x8a\x04\x02\x1b\x1a?\x20cancel_rea\
    son\x20indicates\x20the\x20reason\x20for\x20canceling\x20the\x20watcher.\
    \n\n\x0f\n\x05\x04\x17\x02\x05\x04\x12\x06\x8a\x04\x02\x87\x04\x1e\n\r\n\
    \x05\x04\x17\x02\x05\x05\x12\x04\x8a\x04\x02\x08\n\r\n\x05\x04\x17\x02\
    \x05\x01\x12\x04\x8a\x04\t\x16\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\x8a\
    \x04\x19\x1a\n\x0c\n\x04\x04\x17\x02\x06\x12\x04\x8c\x04\x02$\n\r\n\x05\
    \x04\x17\x02\x06\x04\x12\x04\x8c\x04\x02\n\n\r\n\x05\x04\x17\x02\x06\x06\
    \x12\x04\x8c\x04\x0b\x17\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\x8c\x04\
    \x18\x1e\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\x8c\x04!#\n\x0c\n\x02\x04\
    \x18\x12\x06\x8f\x04\0\x94\x04\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\x8f\
    \x04\x08\x19\n<\n\x04\x04\x18\x02\0\x12\x04\x91\x04\x02\x10\x1a.\x20TTL\
    \x20is\x20the\x20advisory\x20time-to-live\x20in\x20seconds.\n\n\x0f\n\
    \x05\x04\x18\x02\0\x04\x12\x06\x91\x04\x02\x8f\x04\x1b\n\r\n\x05\x04\x18\
    \x02\0\x05\x12\x04\x91\x04\x02\x07\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \x91\x04\x08\x0b\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x91\x04\x0e\x0f\nb\
    \n\x04\x04\x18\x02\x01\x12\x04\x93\x04\x02\x0f\x1aT\x20ID\x20is\x20the\
    \x20requested\x20ID\x20for\x20the\x20lease.\x20If\x20ID\x20is\x20set\x20\
    to\x200,\x20the\x20lessor\x20chooses\x20an\x20ID.\n\n\x0f\n\x05\x04\x18\
    \x02\x01\x04\x12\x06\x93\x04\x02\x91\x04\x10\n\r\n\x05\x04\x18\x02\x01\
    \x05\x12\x04\x93\x04\x02\x07\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\x93\
    \x04\x08\n\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x93\x04\r\x0e\n\x0c\n\
    \x02\x04\x19\x12\x06\x96\x04\0\x9d\x04\x01\n\x0b\n\x03\x04\x19\x01\x12\
    \x04\x96\x04\x08\x1a\n\x0c\n\x04\x04\x19\x02\0\x12\x04\x97\x04\x02\x1c\n\
    \x0f\n\x05\x04\x19\x02\0\x04\x12\x06\x97\x04\x02\x96\x04\x1c\n\r\n\x05\
    \x04\x19\x02\0\x06\x12\x04\x97\x04\x02\x10\n\r\n\x05\x04\x19\x02\0\x01\
    \x12\x04\x97\x04\x11\x17\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x97\x04\x1a\
    \x1b\n9\n\x04\x04\x19\x02\x01\x12\x04\x99\x04\x02\x0f\x1a+\x20ID\x20is\
    \x20the\x20lease\x20ID\x20for\x20the\x20granted\x20lease.\n\n\x0f\n\x05\
    \x04\x19\x02\x01\x04\x12\x06\x99\x04\x02\x97\x04\x1c\n\r\n\x05\x04\x19\
    \x02\x01\x05\x12\x04\x99\x04\x02\x07\n\r\n\x05\x04\x19\x02\x01\x01\x12\
    \x04\x99\x04\x08\n\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\x99\x04\r\x0e\n\
    G\n\x04\x04\x19\x02\x02\x12\x04\x9b\x04\x02\x10\x1a9\x20TTL\x20is\x20the\
    \x20server\x20chosen\x20lease\x20time-to-live\x20in\x20seconds.\n\n\x0f\
    \n\x05\x04\x19\x02\x02\x04\x12\x06\x9b\x04\x02\x99\x04\x0f\n\r\n\x05\x04\
    \x19\x02\x02\x05\x12\x04\x9b\x04\x02\x07\n\r\n\x05\x04\x19\x02\x02\x01\
    \x12\x04\x9b\x04\x08\x0b\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\x9b\x04\
    \x0e\x0f\n\x0c\n\x04\x04\x19\x02\x03\x12\x04\x9c\x04\x02\x13\n\x0f\n\x05\
    \x04\x19\x02\x03\x04\x12\x06\x9c\x04\x02\x9b\x04\x10\n\r\n\x05\x04\x19\
    \x02\x03\x05\x12\x04\x9c\x04\x02\x08\n\r\n\x05\x04\x19\x02\x03\x01\x12\
    \x04\x9c\x04\t\x0e\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\x9c\x04\x11\x12\
    \n\x0c\n\x02\x04\x1a\x12\x06\x9f\x04\0\xa2\x04\x01\n\x0b\n\x03\x04\x1a\
    \x01\x12\x04\x9f\x04\x08\x1a\nj\n\x04\x04\x1a\x02\0\x12\x04\xa1\x04\x02\
    \x0f\x1a\\\x20ID\x20is\x20the\x20lease\x20ID\x20to\x20revoke.\x20When\
    \x20the\x20ID\x20is\x20revoked,\x20all\x20associated\x20keys\x20will\x20\
    be\x20deleted.\n\n\x0f\n\x05\x04\x1a\x02\0\x04\x12\x06\xa1\x04\x02\x9f\
    \x04\x1c\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xa1\x04\x02\x07\n\r\n\x05\
    \x04\x1a\x02\0\x01\x12\x04\xa1\x04\x08\n\n\r\n\x05\x04\x1a\x02\0\x03\x12\
    \x04\xa1\x04\r\x0e\n\x0c\n\x02\x04\x1b\x12\x06\xa4\x04\0\xa6\x04\x01\n\
    \x0b\n\x03\x04\x1b\x01\x12\x04\xa4\x04\x08\x1b\n\x0c\n\x04\x04\x1b\x02\0\
    \x12\x04\xa5\x04\x02\x1c\n\x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\xa5\x04\
    \x02\xa4\x04\x1d\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xa5\x04\x02\x10\n\r\
    \n\x05\x04\x1b\x02\0\x01\x12\x04\xa5\x04\x11\x17\n\r\n\x05\x04\x1b\x02\0\
    \x03\x12\x04\xa5\x04\x1a\x1b\n\x0c\n\x02\x04\x1c\x12\x06\xa8\x04\0\xab\
    \x04\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xa8\x04\x08\x1d\n?\n\x04\x04\
    \x1c\x02\0\x12\x04\xaa\x04\x02\x0f\x1a1\x20ID\x20is\x20the\x20lease\x20I\
    D\x20for\x20the\x20lease\x20to\x20keep\x20alive.\n\n\x0f\n\x05\x04\x1c\
    \x02\0\x04\x12\x06\xaa\x04\x02\xa8\x04\x1f\n\r\n\x05\x04\x1c\x02\0\x05\
    \x12\x04\xaa\x04\x02\x07\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xaa\x04\x08\
    \n\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xaa\x04\r\x0e\n\x0c\n\x02\x04\x1d\
    \x12\x06\xad\x04\0\xb3\x04\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xad\x04\
    \x08\x1e\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xae\x04\x02\x1c\n\x0f\n\x05\
    \x04\x1d\x02\0\x04\x12\x06\xae\x04\x02\xad\x04\x20\n\r\n\x05\x04\x1d\x02\
    \0\x06\x12\x04\xae\x04\x02\x10\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xae\
    \x04\x11\x17\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xae\x04\x1a\x1b\n?\n\
    \x04\x04\x1d\x02\x01\x12\x04\xb0\x04\x02\x0f\x1a1\x20ID\x20is\x20the\x20\
    lease\x20ID\x20from\x20the\x20keep\x20alive\x20request.\n\n\x0f\n\x05\
    \x04\x1d\x02\x01\x04\x12\x06\xb0\x04\x02\xae\x04\x1c\n\r\n\x05\x04\x1d\
    \x02\x01\x05\x12\x04\xb0\x04\x02\x07\n\r\n\x05\x04\x1d\x02\x01\x01\x12\
    \x04\xb0\x04\x08\n\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xb0\x04\r\x0e\n\
    :\n\x04\x04\x1d\x02\x02\x12\x04\xb2\x04\x02\x10\x1a,\x20TTL\x20is\x20the\
    \x20new\x20time-to-live\x20for\x20the\x20lease.\n\n\x0f\n\x05\x04\x1d\
    \x02\x02\x04\x12\x06\xb2\x04\x02\xb0\x04\x0f\n\r\n\x05\x04\x1d\x02\x02\
    \x05\x12\x04\xb2\x04\x02\x07\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xb2\
    \x04\x08\x0b\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xb2\x04\x0e\x0f\n\x0c\
    \n\x02\x04\x1e\x12\x06\xb5\x04\0\xba\x04\x01\n\x0b\n\x03\x04\x1e\x01\x12\
    \x04\xb5\x04\x08\x1e\n1\n\x04\x04\x1e\x02\0\x12\x04\xb7\x04\x02\x0f\x1a#\
    \x20ID\x20is\x20the\x20lease\x20ID\x20for\x20the\x20lease.\n\n\x0f\n\x05\
    \x04\x1e\x02\0\x04\x12\x06\xb7\x04\x02\xb5\x04\x20\n\r\n\x05\x04\x1e\x02\
    \0\x05\x12\x04\xb7\x04\x02\x07\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xb7\
    \x04\x08\n\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xb7\x04\r\x0e\nJ\n\x04\
    \x04\x1e\x02\x01\x12\x04\xb9\x04\x02\x10\x1a<\x20keys\x20is\x20true\x20t\
    o\x20query\x20all\x20the\x20keys\x20attached\x20to\x20this\x20lease.\n\n\
    \x0f\n\x05\x04\x1e\x02\x01\x04\x12\x06\xb9\x04\x02\xb7\x04\x0f\n\r\n\x05\
    \x04\x1e\x02\x01\x05\x12\x04\xb9\x04\x02\x06\n\r\n\x05\x04\x1e\x02\x01\
    \x01\x12\x04\xb9\x04\x07\x0b\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xb9\
    \x04\x0e\x0f\n\x0c\n\x02\x04\x1f\x12\x06\xbc\x04\0\xc6\x04\x01\n\x0b\n\
    \x03\x04\x1f\x01\x12\x04\xbc\x04\x08\x1f\n\x0c\n\x04\x04\x1f\x02\0\x12\
    \x04\xbd\x04\x02\x1c\n\x0f\n\x05\x04\x1f\x02\0\x04\x12\x06\xbd\x04\x02\
    \xbc\x04!\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xbd\x04\x02\x10\n\r\n\x05\
    \x04\x1f\x02\0\x01\x12\x04\xbd\x04\x11\x17\n\r\n\x05\x04\x1f\x02\0\x03\
    \x12\x04\xbd\x04\x1a\x1b\n?\n\x04\x04\x1f\x02\x01\x12\x04\xbf\x04\x02\
    \x0f\x1a1\x20ID\x20is\x20the\x20lease\x20ID\x20from\x20the\x20keep\x20al\
    ive\x20request.\n\n\x0f\n\x05\x04\x1f\x02\x01\x04\x12\x06\xbf\x04\x02\
    \xbd\x04\x1c\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xbf\x04\x02\x07\n\r\n\
    \x05\x04\x1f\x02\x01\x01\x12\x04\xbf\x04\x08\n\n\r\n\x05\x04\x1f\x02\x01\
    \x03\x12\x04\xbf\x04\r\x0e\np\n\x04\x04\x1f\x02\x02\x12\x04\xc1\x04\x02\
    \x10\x1ab\x20TTL\x20is\x20the\x20remaining\x20TTL\x20in\x20seconds\x20fo\
    r\x20the\x20lease;\x20the\x20lease\x20will\x20expire\x20in\x20under\x20T\
    TL+1\x20seconds.\n\n\x0f\n\x05\x04\x1f\x02\x02\x04\x12\x06\xc1\x04\x02\
    \xbf\x04\x0f\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\xc1\x04\x02\x07\n\r\n\
    \x05\x04\x1f\x02\x02\x01\x12\x04\xc1\x04\x08\x0b\n\r\n\x05\x04\x1f\x02\
    \x02\x03\x12\x04\xc1\x04\x0e\x0f\n^\n\x04\x04\x1f\x02\x03\x12\x04\xc3\
    \x04\x02\x17\x1aP\x20GrantedTTL\x20is\x20the\x20initial\x20granted\x20ti\
    me\x20in\x20seconds\x20upon\x20lease\x20creation/renewal.\n\n\x0f\n\x05\
    \x04\x1f\x02\x03\x04\x12\x06\xc3\x04\x02\xc1\x04\x10\n\r\n\x05\x04\x1f\
    \x02\x03\x05\x12\x04\xc3\x04\x02\x07\n\r\n\x05\x04\x1f\x02\x03\x01\x12\
    \x04\xc3\x04\x08\x12\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\xc3\x04\x15\
    \x16\n@\n\x04\x04\x1f\x02\x04\x12\x04\xc5\x04\x02\x1a\x1a2\x20Keys\x20is\
    \x20the\x20list\x20of\x20keys\x20attached\x20to\x20this\x20lease.\n\n\r\
    \n\x05\x04\x1f\x02\x04\x04\x12\x04\xc5\x04\x02\n\n\r\n\x05\x04\x1f\x02\
    \x04\x05\x12\x04\xc5\x04\x0b\x10\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\
    \xc5\x04\x11\x15\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\xc5\x04\x18\x19\n\
    \x0c\n\x02\x04\x20\x12\x06\xc8\x04\0\xd1\x04\x01\n\x0b\n\x03\x04\x20\x01\
    \x12\x04\xc8\x04\x08\x0e\n4\n\x04\x04\x20\x02\0\x12\x04\xca\x04\x02\x10\
    \x1a&\x20ID\x20is\x20the\x20member\x20ID\x20for\x20this\x20member.\n\n\
    \x0f\n\x05\x04\x20\x02\0\x04\x12\x06\xca\x04\x02\xc8\x04\x10\n\r\n\x05\
    \x04\x20\x02\0\x05\x12\x04\xca\x04\x02\x08\n\r\n\x05\x04\x20\x02\0\x01\
    \x12\x04\xca\x04\t\x0b\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xca\x04\x0e\
    \x0f\n~\n\x04\x04\x20\x02\x01\x12\x04\xcc\x04\x02\x12\x1ap\x20name\x20is\
    \x20the\x20human-readable\x20name\x20of\x20the\x20member.\x20If\x20the\
    \x20member\x20is\x20not\x20started,\x20the\x20name\x20will\x20be\x20an\
    \x20empty\x20string.\n\n\x0f\n\x05\x04\x20\x02\x01\x04\x12\x06\xcc\x04\
    \x02\xca\x04\x10\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xcc\x04\x02\x08\n\
    \r\n\x05\x04\x20\x02\x01\x01\x12\x04\xcc\x04\t\r\n\r\n\x05\x04\x20\x02\
    \x01\x03\x12\x04\xcc\x04\x10\x11\na\n\x04\x04\x20\x02\x02\x12\x04\xce\
    \x04\x02\x1f\x1aS\x20peerURLs\x20is\x20the\x20list\x20of\x20URLs\x20the\
    \x20member\x20exposes\x20to\x20the\x20cluster\x20for\x20communication.\n\
    \n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\xce\x04\x02\n\n\r\n\x05\x04\x20\
    \x02\x02\x05\x12\x04\xce\x04\x0b\x11\n\r\n\x05\x04\x20\x02\x02\x01\x12\
    \x04\xce\x04\x12\x1a\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xce\x04\x1d\
    \x1e\n\x98\x01\n\x04\x04\x20\x02\x03\x12\x04\xd0\x04\x02!\x1a\x89\x01\
    \x20clientURLs\x20is\x20the\x20list\x20of\x20URLs\x20the\x20member\x20ex\
    poses\x20to\x20clients\x20for\x20communication.\x20If\x20the\x20member\
    \x20is\x20not\x20started,\x20clientURLs\x20will\x20be\x20empty.\n\n\r\n\
    \x05\x04\x20\x02\x03\x04\x12\x04\xd0\x04\x02\n\n\r\n\x05\x04\x20\x02\x03\
    \x05\x12\x04\xd0\x04\x0b\x11\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\xd0\
    \x04\x12\x1c\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\xd0\x04\x1f\x20\n\x0c\
    \n\x02\x04!\x12\x06\xd3\x04\0\xd6\x04\x01\n\x0b\n\x03\x04!\x01\x12\x04\
    \xd3\x04\x08\x18\ng\n\x04\x04!\x02\0\x12\x04\xd5\x04\x02\x1f\x1aY\x20pee\
    rURLs\x20is\x20the\x20list\x20of\x20URLs\x20the\x20added\x20member\x20wi\
    ll\x20use\x20to\x20communicate\x20with\x20the\x20cluster.\n\n\r\n\x05\
    \x04!\x02\0\x04\x12\x04\xd5\x04\x02\n\n\r\n\x05\x04!\x02\0\x05\x12\x04\
    \xd5\x04\x0b\x11\n\r\n\x05\x04!\x02\0\x01\x12\x04\xd5\x04\x12\x1a\n\r\n\
    \x05\x04!\x02\0\x03\x12\x04\xd5\x04\x1d\x1e\n\x0c\n\x02\x04\"\x12\x06\
    \xd8\x04\0\xde\x04\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xd8\x04\x08\x19\n\
    \x0c\n\x04\x04\"\x02\0\x12\x04\xd9\x04\x02\x1c\n\x0f\n\x05\x04\"\x02\0\
    \x04\x12\x06\xd9\x04\x02\xd8\x04\x1b\n\r\n\x05\x04\"\x02\0\x06\x12\x04\
    \xd9\x04\x02\x10\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xd9\x04\x11\x17\n\r\n\
    \x05\x04\"\x02\0\x03\x12\x04\xd9\x04\x1a\x1b\nF\n\x04\x04\"\x02\x01\x12\
    \x04\xdb\x04\x02\x14\x1a8\x20member\x20is\x20the\x20member\x20informatio\
    n\x20for\x20the\x20added\x20member.\n\n\x0f\n\x05\x04\"\x02\x01\x04\x12\
    \x06\xdb\x04\x02\xd9\x04\x1c\n\r\n\x05\x04\"\x02\x01\x06\x12\x04\xdb\x04\
    \x02\x08\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xdb\x04\t\x0f\n\r\n\x05\x04\
    \"\x02\x01\x03\x12\x04\xdb\x04\x12\x13\nM\n\x04\x04\"\x02\x02\x12\x04\
    \xdd\x04\x02\x1e\x1a?\x20members\x20is\x20a\x20list\x20of\x20all\x20memb\
    ers\x20after\x20adding\x20the\x20new\x20member.\n\n\r\n\x05\x04\"\x02\
    \x02\x04\x12\x04\xdd\x04\x02\n\n\r\n\x05\x04\"\x02\x02\x06\x12\x04\xdd\
    \x04\x0b\x11\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xdd\x04\x12\x19\n\r\n\
    \x05\x04\"\x02\x02\x03\x12\x04\xdd\x04\x1c\x1d\n\x0c\n\x02\x04#\x12\x06\
    \xe0\x04\0\xe3\x04\x01\n\x0b\n\x03\x04#\x01\x12\x04\xe0\x04\x08\x1b\n<\n\
    \x04\x04#\x02\0\x12\x04\xe2\x04\x02\x10\x1a.\x20ID\x20is\x20the\x20membe\
    r\x20ID\x20of\x20the\x20member\x20to\x20remove.\n\n\x0f\n\x05\x04#\x02\0\
    \x04\x12\x06\xe2\x04\x02\xe0\x04\x1d\n\r\n\x05\x04#\x02\0\x05\x12\x04\
    \xe2\x04\x02\x08\n\r\n\x05\x04#\x02\0\x01\x12\x04\xe2\x04\t\x0b\n\r\n\
    \x05\x04#\x02\0\x03\x12\x04\xe2\x04\x0e\x0f\n\x0c\n\x02\x04$\x12\x06\xe5\
    \x04\0\xe9\x04\x01\n\x0b\n\x03\x04$\x01\x12\x04\xe5\x04\x08\x1c\n\x0c\n\
    \x04\x04$\x02\0\x12\x04\xe6\x04\x02\x1c\n\x0f\n\x05\x04$\x02\0\x04\x12\
    \x06\xe6\x04\x02\xe5\x04\x1e\n\r\n\x05\x04$\x02\0\x06\x12\x04\xe6\x04\
    \x02\x10\n\r\n\x05\x04$\x02\0\x01\x12\x04\xe6\x04\x11\x17\n\r\n\x05\x04$\
    \x02\0\x03\x12\x04\xe6\x04\x1a\x1b\nK\n\x04\x04$\x02\x01\x12\x04\xe8\x04\
    \x02\x1e\x1a=\x20members\x20is\x20a\x20list\x20of\x20all\x20members\x20a\
    fter\x20removing\x20the\x20member.\n\n\r\n\x05\x04$\x02\x01\x04\x12\x04\
    \xe8\x04\x02\n\n\r\n\x05\x04$\x02\x01\x06\x12\x04\xe8\x04\x0b\x11\n\r\n\
    \x05\x04$\x02\x01\x01\x12\x04\xe8\x04\x12\x19\n\r\n\x05\x04$\x02\x01\x03\
    \x12\x04\xe8\x04\x1c\x1d\n\x0c\n\x02\x04%\x12\x06\xeb\x04\0\xf0\x04\x01\
    \n\x0b\n\x03\x04%\x01\x12\x04\xeb\x04\x08\x1b\n<\n\x04\x04%\x02\0\x12\
    \x04\xed\x04\x02\x10\x1a.\x20ID\x20is\x20the\x20member\x20ID\x20of\x20th\
    e\x20member\x20to\x20update.\n\n\x0f\n\x05\x04%\x02\0\x04\x12\x06\xed\
    \x04\x02\xeb\x04\x1d\n\r\n\x05\x04%\x02\0\x05\x12\x04\xed\x04\x02\x08\n\
    \r\n\x05\x04%\x02\0\x01\x12\x04\xed\x04\t\x0b\n\r\n\x05\x04%\x02\0\x03\
    \x12\x04\xed\x04\x0e\x0f\ne\n\x04\x04%\x02\x01\x12\x04\xef\x04\x02\x1f\
    \x1aW\x20peerURLs\x20is\x20the\x20new\x20list\x20of\x20URLs\x20the\x20me\
    mber\x20will\x20use\x20to\x20communicate\x20with\x20the\x20cluster.\n\n\
    \r\n\x05\x04%\x02\x01\x04\x12\x04\xef\x04\x02\n\n\r\n\x05\x04%\x02\x01\
    \x05\x12\x04\xef\x04\x0b\x11\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xef\x04\
    \x12\x1a\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xef\x04\x1d\x1e\n\x0c\n\x02\
    \x04&\x12\x06\xf2\x04\0\xf6\x04\x01\n\x0b\n\x03\x04&\x01\x12\x04\xf2\x04\
    \x08\x1c\n\x0c\n\x04\x04&\x02\0\x12\x04\xf3\x04\x02\x1c\n\x0f\n\x05\x04&\
    \x02\0\x04\x12\x06\xf3\x04\x02\xf2\x04\x1d\n\r\n\x05\x04&\x02\0\x06\x12\
    \x04\xf3\x04\x02\x10\n\r\n\x05\x04&\x02\0\x01\x12\x04\xf3\x04\x11\x17\n\
    \r\n\x05\x04&\x02\0\x03\x12\x04\xf3\x04\x1a\x1b\nK\n\x04\x04&\x02\x01\
    \x12\x04\xf5\x04\x02\x1e\x1a=\x20members\x20is\x20a\x20list\x20of\x20all\
    \x20members\x20after\x20updating\x20the\x20member.\n\n\r\n\x05\x04&\x02\
    \x01\x04\x12\x04\xf5\x04\x02\n\n\r\n\x05\x04&\x02\x01\x06\x12\x04\xf5\
    \x04\x0b\x11\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xf5\x04\x12\x19\n\r\n\
    \x05\x04&\x02\x01\x03\x12\x04\xf5\x04\x1c\x1d\n\x0c\n\x02\x04'\x12\x06\
    \xf8\x04\0\xf9\x04\x01\n\x0b\n\x03\x04'\x01\x12\x04\xf8\x04\x08\x19\n\
    \x0c\n\x02\x04(\x12\x06\xfb\x04\0\xff\x04\x01\n\x0b\n\x03\x04(\x01\x12\
    \x04\xfb\x04\x08\x1a\n\x0c\n\x04\x04(\x02\0\x12\x04\xfc\x04\x02\x1c\n\
    \x0f\n\x05\x04(\x02\0\x04\x12\x06\xfc\x04\x02\xfb\x04\x1c\n\r\n\x05\x04(\
    \x02\0\x06\x12\x04\xfc\x04\x02\x10\n\r\n\x05\x04(\x02\0\x01\x12\x04\xfc\
    \x04\x11\x17\n\r\n\x05\x04(\x02\0\x03\x12\x04\xfc\x04\x1a\x1b\nM\n\x04\
    \x04(\x02\x01\x12\x04\xfe\x04\x02\x1e\x1a?\x20members\x20is\x20a\x20list\
    \x20of\x20all\x20members\x20associated\x20with\x20the\x20cluster.\n\n\r\
    \n\x05\x04(\x02\x01\x04\x12\x04\xfe\x04\x02\n\n\r\n\x05\x04(\x02\x01\x06\
    \x12\x04\xfe\x04\x0b\x11\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xfe\x04\x12\
    \x19\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xfe\x04\x1c\x1d\n\x0c\n\x02\x04)\
    \x12\x06\x81\x05\0\x82\x05\x01\n\x0b\n\x03\x04)\x01\x12\x04\x81\x05\x08\
    \x19\n\x0c\n\x02\x04*\x12\x06\x84\x05\0\x86\x05\x01\n\x0b\n\x03\x04*\x01\
    \x12\x04\x84\x05\x08\x1a\n\x0c\n\x04\x04*\x02\0\x12\x04\x85\x05\x02\x1c\
    \n\x0f\n\x05\x04*\x02\0\x04\x12\x06\x85\x05\x02\x84\x05\x1c\n\r\n\x05\
    \x04*\x02\0\x06\x12\x04\x85\x05\x02\x10\n\r\n\x05\x04*\x02\0\x01\x12\x04\
    \x85\x05\x11\x17\n\r\n\x05\x04*\x02\0\x03\x12\x04\x85\x05\x1a\x1b\n\x0c\
    \n\x02\x04+\x12\x06\x88\x05\0\x8b\x05\x01\n\x0b\n\x03\x04+\x01\x12\x04\
    \x88\x05\x08\x19\n;\n\x04\x04+\x02\0\x12\x04\x8a\x05\x02\x16\x1a-\x20tar\
    getID\x20is\x20the\x20node\x20ID\x20for\x20the\x20new\x20leader.\n\n\x0f\
    \n\x05\x04+\x02\0\x04\x12\x06\x8a\x05\x02\x88\x05\x1b\n\r\n\x05\x04+\x02\
    \0\x05\x12\x04\x8a\x05\x02\x08\n\r\n\x05\x04+\x02\0\x01\x12\x04\x8a\x05\
    \t\x11\n\r\n\x05\x04+\x02\0\x03\x12\x04\x8a\x05\x14\x15\n\x0c\n\x02\x04,\
    \x12\x06\x8d\x05\0\x8f\x05\x01\n\x0b\n\x03\x04,\x01\x12\x04\x8d\x05\x08\
    \x1a\n\x0c\n\x04\x04,\x02\0\x12\x04\x8e\x05\x02\x1c\n\x0f\n\x05\x04,\x02\
    \0\x04\x12\x06\x8e\x05\x02\x8d\x05\x1c\n\r\n\x05\x04,\x02\0\x06\x12\x04\
    \x8e\x05\x02\x10\n\r\n\x05\x04,\x02\0\x01\x12\x04\x8e\x05\x11\x17\n\r\n\
    \x05\x04,\x02\0\x03\x12\x04\x8e\x05\x1a\x1b\n\x0c\n\x02\x05\0\x12\x06\
    \x91\x05\0\x94\x05\x01\n\x0b\n\x03\x05\0\x01\x12\x04\x91\x05\x05\x0e\n=\
    \n\x04\x05\0\x02\0\x12\x04\x92\x05\x02\x0b\"/\x20default,\x20used\x20to\
    \x20query\x20if\x20any\x20alarm\x20is\x20active\n\n\r\n\x05\x05\0\x02\0\
    \x01\x12\x04\x92\x05\x02\x06\n\r\n\x05\x05\0\x02\0\x02\x12\x04\x92\x05\t\
    \n\n(\n\x04\x05\0\x02\x01\x12\x04\x93\x05\x02\x0e\"\x1a\x20space\x20quot\
    a\x20is\x20exhausted\n\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\x93\x05\x02\t\
    \n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x93\x05\x0c\r\n\x0c\n\x02\x04-\x12\
    \x06\x96\x05\0\xa5\x05\x01\n\x0b\n\x03\x04-\x01\x12\x04\x96\x05\x08\x14\
    \n\x0e\n\x04\x04-\x04\0\x12\x06\x97\x05\x02\x9b\x05\x03\n\r\n\x05\x04-\
    \x04\0\x01\x12\x04\x97\x05\x07\x12\n\x0e\n\x06\x04-\x04\0\x02\0\x12\x04\
    \x98\x05\x04\x0c\n\x0f\n\x07\x04-\x04\0\x02\0\x01\x12\x04\x98\x05\x04\
    \x07\n\x0f\n\x07\x04-\x04\0\x02\0\x02\x12\x04\x98\x05\n\x0b\n\x0e\n\x06\
    \x04-\x04\0\x02\x01\x12\x04\x99\x05\x04\x11\n\x0f\n\x07\x04-\x04\0\x02\
    \x01\x01\x12\x04\x99\x05\x04\x0c\n\x0f\n\x07\x04-\x04\0\x02\x01\x02\x12\
    \x04\x99\x05\x0f\x10\n\x0e\n\x06\x04-\x04\0\x02\x02\x12\x04\x9a\x05\x04\
    \x13\n\x0f\n\x07\x04-\x04\0\x02\x02\x01\x12\x04\x9a\x05\x04\x0e\n\x0f\n\
    \x07\x04-\x04\0\x02\x02\x02\x12\x04\x9a\x05\x11\x12\n\x94\x01\n\x04\x04-\
    \x02\0\x12\x04\x9f\x05\x02\x19\x1a\x85\x01\x20action\x20is\x20the\x20kin\
    d\x20of\x20alarm\x20request\x20to\x20issue.\x20The\x20action\n\x20may\
    \x20GET\x20alarm\x20statuses,\x20ACTIVATE\x20an\x20alarm,\x20or\x20DEACT\
    IVATE\x20a\n\x20raised\x20alarm.\n\n\x0f\n\x05\x04-\x02\0\x04\x12\x06\
    \x9f\x05\x02\x9b\x05\x03\n\r\n\x05\x04-\x02\0\x06\x12\x04\x9f\x05\x02\r\
    \n\r\n\x05\x04-\x02\0\x01\x12\x04\x9f\x05\x0e\x14\n\r\n\x05\x04-\x02\0\
    \x03\x12\x04\x9f\x05\x17\x18\n\x84\x01\n\x04\x04-\x02\x01\x12\x04\xa2\
    \x05\x02\x16\x1av\x20memberID\x20is\x20the\x20ID\x20of\x20the\x20member\
    \x20associated\x20with\x20the\x20alarm.\x20If\x20memberID\x20is\x200,\
    \x20the\n\x20alarm\x20request\x20covers\x20all\x20members.\n\n\x0f\n\x05\
    \x04-\x02\x01\x04\x12\x06\xa2\x05\x02\x9f\x05\x19\n\r\n\x05\x04-\x02\x01\
    \x05\x12\x04\xa2\x05\x02\x08\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xa2\x05\
    \t\x11\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xa2\x05\x14\x15\nH\n\x04\x04-\
    \x02\x02\x12\x04\xa4\x05\x02\x16\x1a:\x20alarm\x20is\x20the\x20type\x20o\
    f\x20alarm\x20to\x20consider\x20for\x20this\x20request.\n\n\x0f\n\x05\
    \x04-\x02\x02\x04\x12\x06\xa4\x05\x02\xa2\x05\x16\n\r\n\x05\x04-\x02\x02\
    \x06\x12\x04\xa4\x05\x02\x0b\n\r\n\x05\x04-\x02\x02\x01\x12\x04\xa4\x05\
    \x0c\x11\n\r\n\x05\x04-\x02\x02\x03\x12\x04\xa4\x05\x14\x15\n\x0c\n\x02\
    \x04.\x12\x06\xa7\x05\0\xac\x05\x01\n\x0b\n\x03\x04.\x01\x12\x04\xa7\x05\
    \x08\x13\nR\n\x04\x04.\x02\0\x12\x04\xa9\x05\x02\x16\x1aD\x20memberID\
    \x20is\x20the\x20ID\x20of\x20the\x20member\x20associated\x20with\x20the\
    \x20raised\x20alarm.\n\n\x0f\n\x05\x04.\x02\0\x04\x12\x06\xa9\x05\x02\
    \xa7\x05\x15\n\r\n\x05\x04.\x02\0\x05\x12\x04\xa9\x05\x02\x08\n\r\n\x05\
    \x04.\x02\0\x01\x12\x04\xa9\x05\t\x11\n\r\n\x05\x04.\x02\0\x03\x12\x04\
    \xa9\x05\x14\x15\nA\n\x04\x04.\x02\x01\x12\x04\xab\x05\x02\x16\x1a3\x20a\
    larm\x20is\x20the\x20type\x20of\x20alarm\x20which\x20has\x20been\x20rais\
    ed.\n\n\x0f\n\x05\x04.\x02\x01\x04\x12\x06\xab\x05\x02\xa9\x05\x16\n\r\n\
    \x05\x04.\x02\x01\x06\x12\x04\xab\x05\x02\x0b\n\r\n\x05\x04.\x02\x01\x01\
    \x12\x04\xab\x05\x0c\x11\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xab\x05\x14\
    \x15\n\x0c\n\x02\x04/\x12\x06\xae\x05\0\xb2\x05\x01\n\x0b\n\x03\x04/\x01\
    \x12\x04\xae\x05\x08\x15\n\x0c\n\x04\x04/\x02\0\x12\x04\xaf\x05\x02\x1c\
    \n\x0f\n\x05\x04/\x02\0\x04\x12\x06\xaf\x05\x02\xae\x05\x17\n\r\n\x05\
    \x04/\x02\0\x06\x12\x04\xaf\x05\x02\x10\n\r\n\x05\x04/\x02\0\x01\x12\x04\
    \xaf\x05\x11\x17\n\r\n\x05\x04/\x02\0\x03\x12\x04\xaf\x05\x1a\x1b\nM\n\
    \x04\x04/\x02\x01\x12\x04\xb1\x05\x02\"\x1a?\x20alarms\x20is\x20a\x20lis\
    t\x20of\x20alarms\x20associated\x20with\x20the\x20alarm\x20request.\n\n\
    \r\n\x05\x04/\x02\x01\x04\x12\x04\xb1\x05\x02\n\n\r\n\x05\x04/\x02\x01\
    \x06\x12\x04\xb1\x05\x0b\x16\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xb1\x05\
    \x17\x1d\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xb1\x05\x20!\n\x0c\n\x02\x04\
    0\x12\x06\xb4\x05\0\xb5\x05\x01\n\x0b\n\x03\x040\x01\x12\x04\xb4\x05\x08\
    \x15\n\x0c\n\x02\x041\x12\x06\xb7\x05\0\xc3\x05\x01\n\x0b\n\x03\x041\x01\
    \x12\x04\xb7\x05\x08\x16\n\x0c\n\x04\x041\x02\0\x12\x04\xb8\x05\x02\x1c\
    \n\x0f\n\x05\x041\x02\0\x04\x12\x06\xb8\x05\x02\xb7\x05\x18\n\r\n\x05\
    \x041\x02\0\x06\x12\x04\xb8\x05\x02\x10\n\r\n\x05\x041\x02\0\x01\x12\x04\
    \xb8\x05\x11\x17\n\r\n\x05\x041\x02\0\x03\x12\x04\xb8\x05\x1a\x1b\nV\n\
    \x04\x041\x02\x01\x12\x04\xba\x05\x02\x15\x1aH\x20version\x20is\x20the\
    \x20cluster\x20protocol\x20version\x20used\x20by\x20the\x20responding\
    \x20member.\n\n\x0f\n\x05\x041\x02\x01\x04\x12\x06\xba\x05\x02\xb8\x05\
    \x1c\n\r\n\x05\x041\x02\x01\x05\x12\x04\xba\x05\x02\x08\n\r\n\x05\x041\
    \x02\x01\x01\x12\x04\xba\x05\t\x10\n\r\n\x05\x041\x02\x01\x03\x12\x04\
    \xba\x05\x13\x14\n_\n\x04\x041\x02\x02\x12\x04\xbc\x05\x02\x13\x1aQ\x20d\
    bSize\x20is\x20the\x20size\x20of\x20the\x20backend\x20database,\x20in\
    \x20bytes,\x20of\x20the\x20responding\x20member.\n\n\x0f\n\x05\x041\x02\
    \x02\x04\x12\x06\xbc\x05\x02\xba\x05\x15\n\r\n\x05\x041\x02\x02\x05\x12\
    \x04\xbc\x05\x02\x07\n\r\n\x05\x041\x02\x02\x01\x12\x04\xbc\x05\x08\x0e\
    \n\r\n\x05\x041\x02\x02\x03\x12\x04\xbc\x05\x11\x12\nc\n\x04\x041\x02\
    \x03\x12\x04\xbe\x05\x02\x14\x1aU\x20leader\x20is\x20the\x20member\x20ID\
    \x20which\x20the\x20responding\x20member\x20believes\x20is\x20the\x20cur\
    rent\x20leader.\n\n\x0f\n\x05\x041\x02\x03\x04\x12\x06\xbe\x05\x02\xbc\
    \x05\x13\n\r\n\x05\x041\x02\x03\x05\x12\x04\xbe\x05\x02\x08\n\r\n\x05\
    \x041\x02\x03\x01\x12\x04\xbe\x05\t\x0f\n\r\n\x05\x041\x02\x03\x03\x12\
    \x04\xbe\x05\x12\x13\nM\n\x04\x041\x02\x04\x12\x04\xc0\x05\x02\x17\x1a?\
    \x20raftIndex\x20is\x20the\x20current\x20raft\x20index\x20of\x20the\x20r\
    esponding\x20member.\n\n\x0f\n\x05\x041\x02\x04\x04\x12\x06\xc0\x05\x02\
    \xbe\x05\x14\n\r\n\x05\x041\x02\x04\x05\x12\x04\xc0\x05\x02\x08\n\r\n\
    \x05\x041\x02\x04\x01\x12\x04\xc0\x05\t\x12\n\r\n\x05\x041\x02\x04\x03\
    \x12\x04\xc0\x05\x15\x16\nK\n\x04\x041\x02\x05\x12\x04\xc2\x05\x02\x16\
    \x1a=\x20raftTerm\x20is\x20the\x20current\x20raft\x20term\x20of\x20the\
    \x20responding\x20member.\n\n\x0f\n\x05\x041\x02\x05\x04\x12\x06\xc2\x05\
    \x02\xc0\x05\x17\n\r\n\x05\x041\x02\x05\x05\x12\x04\xc2\x05\x02\x08\n\r\
    \n\x05\x041\x02\x05\x01\x12\x04\xc2\x05\t\x11\n\r\n\x05\x041\x02\x05\x03\
    \x12\x04\xc2\x05\x14\x15\n\x0c\n\x02\x042\x12\x06\xc5\x05\0\xc6\x05\x01\
    \n\x0b\n\x03\x042\x01\x12\x04\xc5\x05\x08\x19\n\x0c\n\x02\x043\x12\x06\
    \xc8\x05\0\xc9\x05\x01\n\x0b\n\x03\x043\x01\x12\x04\xc8\x05\x08\x1a\n\
    \x0c\n\x02\x044\x12\x06\xcb\x05\0\xce\x05\x01\n\x0b\n\x03\x044\x01\x12\
    \x04\xcb\x05\x08\x1b\n\x0c\n\x04\x044\x02\0\x12\x04\xcc\x05\x02\x12\n\
    \x0f\n\x05\x044\x02\0\x04\x12\x06\xcc\x05\x02\xcb\x05\x1d\n\r\n\x05\x044\
    \x02\0\x05\x12\x04\xcc\x05\x02\x08\n\r\n\x05\x044\x02\0\x01\x12\x04\xcc\
    \x05\t\r\n\r\n\x05\x044\x02\0\x03\x12\x04\xcc\x05\x10\x11\n\x0c\n\x04\
    \x044\x02\x01\x12\x04\xcd\x05\x02\x16\n\x0f\n\x05\x044\x02\x01\x04\x12\
    \x06\xcd\x05\x02\xcc\x05\x12\n\r\n\x05\x044\x02\x01\x05\x12\x04\xcd\x05\
    \x02\x08\n\r\n\x05\x044\x02\x01\x01\x12\x04\xcd\x05\t\x11\n\r\n\x05\x044\
    \x02\x01\x03\x12\x04\xcd\x05\x14\x15\n\x0c\n\x02\x045\x12\x06\xd0\x05\0\
    \xd3\x05\x01\n\x0b\n\x03\x045\x01\x12\x04\xd0\x05\x08\x1a\n\x0c\n\x04\
    \x045\x02\0\x12\x04\xd1\x05\x02\x12\n\x0f\n\x05\x045\x02\0\x04\x12\x06\
    \xd1\x05\x02\xd0\x05\x1c\n\r\n\x05\x045\x02\0\x05\x12\x04\xd1\x05\x02\
    \x08\n\r\n\x05\x045\x02\0\x01\x12\x04\xd1\x05\t\r\n\r\n\x05\x045\x02\0\
    \x03\x12\x04\xd1\x05\x10\x11\n\x0c\n\x04\x045\x02\x01\x12\x04\xd2\x05\
    \x02\x16\n\x0f\n\x05\x045\x02\x01\x04\x12\x06\xd2\x05\x02\xd1\x05\x12\n\
    \r\n\x05\x045\x02\x01\x05\x12\x04\xd2\x05\x02\x08\n\r\n\x05\x045\x02\x01\
    \x01\x12\x04\xd2\x05\t\x11\n\r\n\x05\x045\x02\x01\x03\x12\x04\xd2\x05\
    \x14\x15\n\x0c\n\x02\x046\x12\x06\xd5\x05\0\xd7\x05\x01\n\x0b\n\x03\x046\
    \x01\x12\x04\xd5\x05\x08\x1a\n\x0c\n\x04\x046\x02\0\x12\x04\xd6\x05\x02\
    \x12\n\x0f\n\x05\x046\x02\0\x04\x12\x06\xd6\x05\x02\xd5\x05\x1c\n\r\n\
    \x05\x046\x02\0\x05\x12\x04\xd6\x05\x02\x08\n\r\n\x05\x046\x02\0\x01\x12\
    \x04\xd6\x05\t\r\n\r\n\x05\x046\x02\0\x03\x12\x04\xd6\x05\x10\x11\n\x0c\
    \n\x02\x047\x12\x06\xd9\x05\0\xdc\x05\x01\n\x0b\n\x03\x047\x01\x12\x04\
    \xd9\x05\x08\x1d\n7\n\x04\x047\x02\0\x12\x04\xdb\x05\x02\x12\x1a)\x20nam\
    e\x20is\x20the\x20name\x20of\x20the\x20user\x20to\x20delete.\n\n\x0f\n\
    \x05\x047\x02\0\x04\x12\x06\xdb\x05\x02\xd9\x05\x1f\n\r\n\x05\x047\x02\0\
    \x05\x12\x04\xdb\x05\x02\x08\n\r\n\x05\x047\x02\0\x01\x12\x04\xdb\x05\t\
    \r\n\r\n\x05\x047\x02\0\x03\x12\x04\xdb\x05\x10\x11\n\x0c\n\x02\x048\x12\
    \x06\xde\x05\0\xe3\x05\x01\n\x0b\n\x03\x048\x01\x12\x04\xde\x05\x08%\nM\
    \n\x04\x048\x02\0\x12\x04\xe0\x05\x02\x12\x1a?\x20name\x20is\x20the\x20n\
    ame\x20of\x20the\x20user\x20whose\x20password\x20is\x20being\x20changed.\
    \n\n\x0f\n\x05\x048\x02\0\x04\x12\x06\xe0\x05\x02\xde\x05'\n\r\n\x05\x04\
    8\x02\0\x05\x12\x04\xe0\x05\x02\x08\n\r\n\x05\x048\x02\0\x01\x12\x04\xe0\
    \x05\t\r\n\r\n\x05\x048\x02\0\x03\x12\x04\xe0\x05\x10\x11\n:\n\x04\x048\
    \x02\x01\x12\x04\xe2\x05\x02\x16\x1a,\x20password\x20is\x20the\x20new\
    \x20password\x20for\x20the\x20user.\n\n\x0f\n\x05\x048\x02\x01\x04\x12\
    \x06\xe2\x05\x02\xe0\x05\x12\n\r\n\x05\x048\x02\x01\x05\x12\x04\xe2\x05\
    \x02\x08\n\r\n\x05\x048\x02\x01\x01\x12\x04\xe2\x05\t\x11\n\r\n\x05\x048\
    \x02\x01\x03\x12\x04\xe2\x05\x14\x15\n\x0c\n\x02\x049\x12\x06\xe5\x05\0\
    \xea\x05\x01\n\x0b\n\x03\x049\x01\x12\x04\xe5\x05\x08\x20\nR\n\x04\x049\
    \x02\0\x12\x04\xe7\x05\x02\x12\x1aD\x20user\x20is\x20the\x20name\x20of\
    \x20the\x20user\x20which\x20should\x20be\x20granted\x20a\x20given\x20rol\
    e.\n\n\x0f\n\x05\x049\x02\0\x04\x12\x06\xe7\x05\x02\xe5\x05\"\n\r\n\x05\
    \x049\x02\0\x05\x12\x04\xe7\x05\x02\x08\n\r\n\x05\x049\x02\0\x01\x12\x04\
    \xe7\x05\t\r\n\r\n\x05\x049\x02\0\x03\x12\x04\xe7\x05\x10\x11\nB\n\x04\
    \x049\x02\x01\x12\x04\xe9\x05\x02\x12\x1a4\x20role\x20is\x20the\x20name\
    \x20of\x20the\x20role\x20to\x20grant\x20to\x20the\x20user.\n\n\x0f\n\x05\
    \x049\x02\x01\x04\x12\x06\xe9\x05\x02\xe7\x05\x12\n\r\n\x05\x049\x02\x01\
    \x05\x12\x04\xe9\x05\x02\x08\n\r\n\x05\x049\x02\x01\x01\x12\x04\xe9\x05\
    \t\r\n\r\n\x05\x049\x02\x01\x03\x12\x04\xe9\x05\x10\x11\n\x0c\n\x02\x04:\
    \x12\x06\xec\x05\0\xef\x05\x01\n\x0b\n\x03\x04:\x01\x12\x04\xec\x05\x08!\
    \n\x0c\n\x04\x04:\x02\0\x12\x04\xed\x05\x02\x12\n\x0f\n\x05\x04:\x02\0\
    \x04\x12\x06\xed\x05\x02\xec\x05#\n\r\n\x05\x04:\x02\0\x05\x12\x04\xed\
    \x05\x02\x08\n\r\n\x05\x04:\x02\0\x01\x12\x04\xed\x05\t\r\n\r\n\x05\x04:\
    \x02\0\x03\x12\x04\xed\x05\x10\x11\n\x0c\n\x04\x04:\x02\x01\x12\x04\xee\
    \x05\x02\x12\n\x0f\n\x05\x04:\x02\x01\x04\x12\x06\xee\x05\x02\xed\x05\
    \x12\n\r\n\x05\x04:\x02\x01\x05\x12\x04\xee\x05\x02\x08\n\r\n\x05\x04:\
    \x02\x01\x01\x12\x04\xee\x05\t\r\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xee\
    \x05\x10\x11\n\x0c\n\x02\x04;\x12\x06\xf1\x05\0\xf4\x05\x01\n\x0b\n\x03\
    \x04;\x01\x12\x04\xf1\x05\x08\x1a\nQ\n\x04\x04;\x02\0\x12\x04\xf3\x05\
    \x02\x12\x1aC\x20name\x20is\x20the\x20name\x20of\x20the\x20role\x20to\
    \x20add\x20to\x20the\x20authentication\x20system.\n\n\x0f\n\x05\x04;\x02\
    \0\x04\x12\x06\xf3\x05\x02\xf1\x05\x1c\n\r\n\x05\x04;\x02\0\x05\x12\x04\
    \xf3\x05\x02\x08\n\r\n\x05\x04;\x02\0\x01\x12\x04\xf3\x05\t\r\n\r\n\x05\
    \x04;\x02\0\x03\x12\x04\xf3\x05\x10\x11\n\x0c\n\x02\x04<\x12\x06\xf6\x05\
    \0\xf8\x05\x01\n\x0b\n\x03\x04<\x01\x12\x04\xf6\x05\x08\x1a\n\x0c\n\x04\
    \x04<\x02\0\x12\x04\xf7\x05\x02\x12\n\x0f\n\x05\x04<\x02\0\x04\x12\x06\
    \xf7\x05\x02\xf6\x05\x1c\n\r\n\x05\x04<\x02\0\x05\x12\x04\xf7\x05\x02\
    \x08\n\r\n\x05\x04<\x02\0\x01\x12\x04\xf7\x05\t\r\n\r\n\x05\x04<\x02\0\
    \x03\x12\x04\xf7\x05\x10\x11\n\x0c\n\x02\x04=\x12\x06\xfa\x05\0\xfb\x05\
    \x01\n\x0b\n\x03\x04=\x01\x12\x04\xfa\x05\x08\x1b\n\x0c\n\x02\x04>\x12\
    \x06\xfd\x05\0\xfe\x05\x01\n\x0b\n\x03\x04>\x01\x12\x04\xfd\x05\x08\x1b\
    \n\x0c\n\x02\x04?\x12\x06\x80\x06\0\x82\x06\x01\n\x0b\n\x03\x04?\x01\x12\
    \x04\x80\x06\x08\x1d\n\x0c\n\x04\x04?\x02\0\x12\x04\x81\x06\x02\x12\n\
    \x0f\n\x05\x04?\x02\0\x04\x12\x06\x81\x06\x02\x80\x06\x1f\n\r\n\x05\x04?\
    \x02\0\x05\x12\x04\x81\x06\x02\x08\n\r\n\x05\x04?\x02\0\x01\x12\x04\x81\
    \x06\t\r\n\r\n\x05\x04?\x02\0\x03\x12\x04\x81\x06\x10\x11\n\x0c\n\x02\
    \x04@\x12\x06\x84\x06\0\x89\x06\x01\n\x0b\n\x03\x04@\x01\x12\x04\x84\x06\
    \x08&\nR\n\x04\x04@\x02\0\x12\x04\x86\x06\x02\x12\x1aD\x20name\x20is\x20\
    the\x20name\x20of\x20the\x20role\x20which\x20will\x20be\x20granted\x20th\
    e\x20permission.\n\n\x0f\n\x05\x04@\x02\0\x04\x12\x06\x86\x06\x02\x84\
    \x06(\n\r\n\x05\x04@\x02\0\x05\x12\x04\x86\x06\x02\x08\n\r\n\x05\x04@\
    \x02\0\x01\x12\x04\x86\x06\t\r\n\r\n\x05\x04@\x02\0\x03\x12\x04\x86\x06\
    \x10\x11\n<\n\x04\x04@\x02\x01\x12\x04\x88\x06\x02\x1d\x1a.\x20perm\x20i\
    s\x20the\x20permission\x20to\x20grant\x20to\x20the\x20role.\n\n\x0f\n\
    \x05\x04@\x02\x01\x04\x12\x06\x88\x06\x02\x86\x06\x12\n\r\n\x05\x04@\x02\
    \x01\x06\x12\x04\x88\x06\x02\x13\n\r\n\x05\x04@\x02\x01\x01\x12\x04\x88\
    \x06\x14\x18\n\r\n\x05\x04@\x02\x01\x03\x12\x04\x88\x06\x1b\x1c\n\x0c\n\
    \x02\x04A\x12\x06\x8b\x06\0\x8f\x06\x01\n\x0b\n\x03\x04A\x01\x12\x04\x8b\
    \x06\x08'\n\x0c\n\x04\x04A\x02\0\x12\x04\x8c\x06\x02\x12\n\x0f\n\x05\x04\
    A\x02\0\x04\x12\x06\x8c\x06\x02\x8b\x06)\n\r\n\x05\x04A\x02\0\x05\x12\
    \x04\x8c\x06\x02\x08\n\r\n\x05\x04A\x02\0\x01\x12\x04\x8c\x06\t\r\n\r\n\
    \x05\x04A\x02\0\x03\x12\x04\x8c\x06\x10\x11\n\x0c\n\x04\x04A\x02\x01\x12\
    \x04\x8d\x06\x02\x11\n\x0f\n\x05\x04A\x02\x01\x04\x12\x06\x8d\x06\x02\
    \x8c\x06\x12\n\r\n\x05\x04A\x02\x01\x05\x12\x04\x8d\x06\x02\x08\n\r\n\
    \x05\x04A\x02\x01\x01\x12\x04\x8d\x06\t\x0c\n\r\n\x05\x04A\x02\x01\x03\
    \x12\x04\x8d\x06\x0f\x10\n\x0c\n\x04\x04A\x02\x02\x12\x04\x8e\x06\x02\
    \x17\n\x0f\n\x05\x04A\x02\x02\x04\x12\x06\x8e\x06\x02\x8d\x06\x11\n\r\n\
    \x05\x04A\x02\x02\x05\x12\x04\x8e\x06\x02\x08\n\r\n\x05\x04A\x02\x02\x01\
    \x12\x04\x8e\x06\t\x12\n\r\n\x05\x04A\x02\x02\x03\x12\x04\x8e\x06\x15\
    \x16\n\x0c\n\x02\x04B\x12\x06\x91\x06\0\x93\x06\x01\n\x0b\n\x03\x04B\x01\
    \x12\x04\x91\x06\x08\x1a\n\x0c\n\x04\x04B\x02\0\x12\x04\x92\x06\x02\x1c\
    \n\x0f\n\x05\x04B\x02\0\x04\x12\x06\x92\x06\x02\x91\x06\x1c\n\r\n\x05\
    \x04B\x02\0\x06\x12\x04\x92\x06\x02\x10\n\r\n\x05\x04B\x02\0\x01\x12\x04\
    \x92\x06\x11\x17\n\r\n\x05\x04B\x02\0\x03\x12\x04\x92\x06\x1a\x1b\n\x0c\
    \n\x02\x04C\x12\x06\x95\x06\0\x97\x06\x01\n\x0b\n\x03\x04C\x01\x12\x04\
    \x95\x06\x08\x1b\n\x0c\n\x04\x04C\x02\0\x12\x04\x96\x06\x02\x1c\n\x0f\n\
    \x05\x04C\x02\0\x04\x12\x06\x96\x06\x02\x95\x06\x1d\n\r\n\x05\x04C\x02\0\
    \x06\x12\x04\x96\x06\x02\x10\n\r\n\x05\x04C\x02\0\x01\x12\x04\x96\x06\
    \x11\x17\n\r\n\x05\x04C\x02\0\x03\x12\x04\x96\x06\x1a\x1b\n\x0c\n\x02\
    \x04D\x12\x06\x99\x06\0\x9d\x06\x01\n\x0b\n\x03\x04D\x01\x12\x04\x99\x06\
    \x08\x1c\n\x0c\n\x04\x04D\x02\0\x12\x04\x9a\x06\x02\x1c\n\x0f\n\x05\x04D\
    \x02\0\x04\x12\x06\x9a\x06\x02\x99\x06\x1e\n\r\n\x05\x04D\x02\0\x06\x12\
    \x04\x9a\x06\x02\x10\n\r\n\x05\x04D\x02\0\x01\x12\x04\x9a\x06\x11\x17\n\
    \r\n\x05\x04D\x02\0\x03\x12\x04\x9a\x06\x1a\x1b\nP\n\x04\x04D\x02\x01\
    \x12\x04\x9c\x06\x02\x13\x1aB\x20token\x20is\x20an\x20authorized\x20toke\
    n\x20that\x20can\x20be\x20used\x20in\x20succeeding\x20RPCs\n\n\x0f\n\x05\
    \x04D\x02\x01\x04\x12\x06\x9c\x06\x02\x9a\x06\x1c\n\r\n\x05\x04D\x02\x01\
    \x05\x12\x04\x9c\x06\x02\x08\n\r\n\x05\x04D\x02\x01\x01\x12\x04\x9c\x06\
    \t\x0e\n\r\n\x05\x04D\x02\x01\x03\x12\x04\x9c\x06\x11\x12\n\x0c\n\x02\
    \x04E\x12\x06\x9f\x06\0\xa1\x06\x01\n\x0b\n\x03\x04E\x01\x12\x04\x9f\x06\
    \x08\x1b\n\x0c\n\x04\x04E\x02\0\x12\x04\xa0\x06\x02\x1c\n\x0f\n\x05\x04E\
    \x02\0\x04\x12\x06\xa0\x06\x02\x9f\x06\x1d\n\r\n\x05\x04E\x02\0\x06\x12\
    \x04\xa0\x06\x02\x10\n\r\n\x05\x04E\x02\0\x01\x12\x04\xa0\x06\x11\x17\n\
    \r\n\x05\x04E\x02\0\x03\x12\x04\xa0\x06\x1a\x1b\n\x0c\n\x02\x04F\x12\x06\
    \xa3\x06\0\xa7\x06\x01\n\x0b\n\x03\x04F\x01\x12\x04\xa3\x06\x08\x1b\n\
    \x0c\n\x04\x04F\x02\0\x12\x04\xa4\x06\x02\x1c\n\x0f\n\x05\x04F\x02\0\x04\
    \x12\x06\xa4\x06\x02\xa3\x06\x1d\n\r\n\x05\x04F\x02\0\x06\x12\x04\xa4\
    \x06\x02\x10\n\r\n\x05\x04F\x02\0\x01\x12\x04\xa4\x06\x11\x17\n\r\n\x05\
    \x04F\x02\0\x03\x12\x04\xa4\x06\x1a\x1b\n\x0c\n\x04\x04F\x02\x01\x12\x04\
    \xa6\x06\x02\x1c\n\r\n\x05\x04F\x02\x01\x04\x12\x04\xa6\x06\x02\n\n\r\n\
    \x05\x04F\x02\x01\x05\x12\x04\xa6\x06\x0b\x11\n\r\n\x05\x04F\x02\x01\x01\
    \x12\x04\xa6\x06\x12\x17\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xa6\x06\x1a\
    \x1b\n\x0c\n\x02\x04G\x12\x06\xa9\x06\0\xab\x06\x01\n\x0b\n\x03\x04G\x01\
    \x12\x04\xa9\x06\x08\x1e\n\x0c\n\x04\x04G\x02\0\x12\x04\xaa\x06\x02\x1c\
    \n\x0f\n\x05\x04G\x02\0\x04\x12\x06\xaa\x06\x02\xa9\x06\x20\n\r\n\x05\
    \x04G\x02\0\x06\x12\x04\xaa\x06\x02\x10\n\r\n\x05\x04G\x02\0\x01\x12\x04\
    \xaa\x06\x11\x17\n\r\n\x05\x04G\x02\0\x03\x12\x04\xaa\x06\x1a\x1b\n\x0c\
    \n\x02\x04H\x12\x06\xad\x06\0\xaf\x06\x01\n\x0b\n\x03\x04H\x01\x12\x04\
    \xad\x06\x08&\n\x0c\n\x04\x04H\x02\0\x12\x04\xae\x06\x02\x1c\n\x0f\n\x05\
    \x04H\x02\0\x04\x12\x06\xae\x06\x02\xad\x06(\n\r\n\x05\x04H\x02\0\x06\
    \x12\x04\xae\x06\x02\x10\n\r\n\x05\x04H\x02\0\x01\x12\x04\xae\x06\x11\
    \x17\n\r\n\x05\x04H\x02\0\x03\x12\x04\xae\x06\x1a\x1b\n\x0c\n\x02\x04I\
    \x12\x06\xb1\x06\0\xb3\x06\x01\n\x0b\n\x03\x04I\x01\x12\x04\xb1\x06\x08!\
    \n\x0c\n\x04\x04I\x02\0\x12\x04\xb2\x06\x02\x1c\n\x0f\n\x05\x04I\x02\0\
    \x04\x12\x06\xb2\x06\x02\xb1\x06#\n\r\n\x05\x04I\x02\0\x06\x12\x04\xb2\
    \x06\x02\x10\n\r\n\x05\x04I\x02\0\x01\x12\x04\xb2\x06\x11\x17\n\r\n\x05\
    \x04I\x02\0\x03\x12\x04\xb2\x06\x1a\x1b\n\x0c\n\x02\x04J\x12\x06\xb5\x06\
    \0\xb7\x06\x01\n\x0b\n\x03\x04J\x01\x12\x04\xb5\x06\x08\"\n\x0c\n\x04\
    \x04J\x02\0\x12\x04\xb6\x06\x02\x1c\n\x0f\n\x05\x04J\x02\0\x04\x12\x06\
    \xb6\x06\x02\xb5\x06$\n\r\n\x05\x04J\x02\0\x06\x12\x04\xb6\x06\x02\x10\n\
    \r\n\x05\x04J\x02\0\x01\x12\x04\xb6\x06\x11\x17\n\r\n\x05\x04J\x02\0\x03\
    \x12\x04\xb6\x06\x1a\x1b\n\x0c\n\x02\x04K\x12\x06\xb9\x06\0\xbb\x06\x01\
    \n\x0b\n\x03\x04K\x01\x12\x04\xb9\x06\x08\x1b\n\x0c\n\x04\x04K\x02\0\x12\
    \x04\xba\x06\x02\x1c\n\x0f\n\x05\x04K\x02\0\x04\x12\x06\xba\x06\x02\xb9\
    \x06\x1d\n\r\n\x05\x04K\x02\0\x06\x12\x04\xba\x06\x02\x10\n\r\n\x05\x04K\
    \x02\0\x01\x12\x04\xba\x06\x11\x17\n\r\n\x05\x04K\x02\0\x03\x12\x04\xba\
    \x06\x1a\x1b\n\x0c\n\x02\x04L\x12\x06\xbd\x06\0\xc1\x06\x01\n\x0b\n\x03\
    \x04L\x01\x12\x04\xbd\x06\x08\x1b\n\x0c\n\x04\x04L\x02\0\x12\x04\xbe\x06\
    \x02\x1c\n\x0f\n\x05\x04L\x02\0\x04\x12\x06\xbe\x06\x02\xbd\x06\x1d\n\r\
    \n\x05\x04L\x02\0\x06\x12\x04\xbe\x06\x02\x10\n\r\n\x05\x04L\x02\0\x01\
    \x12\x04\xbe\x06\x11\x17\n\r\n\x05\x04L\x02\0\x03\x12\x04\xbe\x06\x1a\
    \x1b\n\x0c\n\x04\x04L\x02\x01\x12\x04\xc0\x06\x02&\n\r\n\x05\x04L\x02\
    \x01\x04\x12\x04\xc0\x06\x02\n\n\r\n\x05\x04L\x02\x01\x06\x12\x04\xc0\
    \x06\x0b\x1c\n\r\n\x05\x04L\x02\x01\x01\x12\x04\xc0\x06\x1d!\n\r\n\x05\
    \x04L\x02\x01\x03\x12\x04\xc0\x06$%\n\x0c\n\x02\x04M\x12\x06\xc3\x06\0\
    \xc7\x06\x01\n\x0b\n\x03\x04M\x01\x12\x04\xc3\x06\x08\x1c\n\x0c\n\x04\
    \x04M\x02\0\x12\x04\xc4\x06\x02\x1c\n\x0f\n\x05\x04M\x02\0\x04\x12\x06\
    \xc4\x06\x02\xc3\x06\x1e\n\r\n\x05\x04M\x02\0\x06\x12\x04\xc4\x06\x02\
    \x10\n\r\n\x05\x04M\x02\0\x01\x12\x04\xc4\x06\x11\x17\n\r\n\x05\x04M\x02\
    \0\x03\x12\x04\xc4\x06\x1a\x1b\n\x0c\n\x04\x04M\x02\x01\x12\x04\xc6\x06\
    \x02\x1c\n\r\n\x05\x04M\x02\x01\x04\x12\x04\xc6\x06\x02\n\n\r\n\x05\x04M\
    \x02\x01\x05\x12\x04\xc6\x06\x0b\x11\n\r\n\x05\x04M\x02\x01\x01\x12\x04\
    \xc6\x06\x12\x17\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xc6\x06\x1a\x1b\n\
    \x0c\n\x02\x04N\x12\x06\xc9\x06\0\xcd\x06\x01\n\x0b\n\x03\x04N\x01\x12\
    \x04\xc9\x06\x08\x1c\n\x0c\n\x04\x04N\x02\0\x12\x04\xca\x06\x02\x1c\n\
    \x0f\n\x05\x04N\x02\0\x04\x12\x06\xca\x06\x02\xc9\x06\x1e\n\r\n\x05\x04N\
    \x02\0\x06\x12\x04\xca\x06\x02\x10\n\r\n\x05\x04N\x02\0\x01\x12\x04\xca\
    \x06\x11\x17\n\r\n\x05\x04N\x02\0\x03\x12\x04\xca\x06\x1a\x1b\n\x0c\n\
    \x04\x04N\x02\x01\x12\x04\xcc\x06\x02\x1c\n\r\n\x05\x04N\x02\x01\x04\x12\
    \x04\xcc\x06\x02\n\n\r\n\x05\x04N\x02\x01\x05\x12\x04\xcc\x06\x0b\x11\n\
    \r\n\x05\x04N\x02\x01\x01\x12\x04\xcc\x06\x12\x17\n\r\n\x05\x04N\x02\x01\
    \x03\x12\x04\xcc\x06\x1a\x1b\n\x0c\n\x02\x04O\x12\x06\xcf\x06\0\xd1\x06\
    \x01\n\x0b\n\x03\x04O\x01\x12\x04\xcf\x06\x08\x1e\n\x0c\n\x04\x04O\x02\0\
    \x12\x04\xd0\x06\x02\x1c\n\x0f\n\x05\x04O\x02\0\x04\x12\x06\xd0\x06\x02\
    \xcf\x06\x20\n\r\n\x05\x04O\x02\0\x06\x12\x04\xd0\x06\x02\x10\n\r\n\x05\
    \x04O\x02\0\x01\x12\x04\xd0\x06\x11\x17\n\r\n\x05\x04O\x02\0\x03\x12\x04\
    \xd0\x06\x1a\x1b\n\x0c\n\x02\x04P\x12\x06\xd3\x06\0\xd5\x06\x01\n\x0b\n\
    \x03\x04P\x01\x12\x04\xd3\x06\x08'\n\x0c\n\x04\x04P\x02\0\x12\x04\xd4\
    \x06\x02\x1c\n\x0f\n\x05\x04P\x02\0\x04\x12\x06\xd4\x06\x02\xd3\x06)\n\r\
    \n\x05\x04P\x02\0\x06\x12\x04\xd4\x06\x02\x10\n\r\n\x05\x04P\x02\0\x01\
    \x12\x04\xd4\x06\x11\x17\n\r\n\x05\x04P\x02\0\x03\x12\x04\xd4\x06\x1a\
    \x1b\n\x0c\n\x02\x04Q\x12\x06\xd7\x06\0\xd9\x06\x01\n\x0b\n\x03\x04Q\x01\
    \x12\x04\xd7\x06\x08(\n\x0c\n\x04\x04Q\x02\0\x12\x04\xd8\x06\x02\x1c\n\
    \x0f\n\x05\x04Q\x02\0\x04\x12\x06\xd8\x06\x02\xd7\x06*\n\r\n\x05\x04Q\
    \x02\0\x06\x12\x04\xd8\x06\x02\x10\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xd8\
    \x06\x11\x17\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xd8\x06\x1a\x1bb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
